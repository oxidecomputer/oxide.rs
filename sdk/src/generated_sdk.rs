// The contents of this file are generated; do not modify them.

#[allow(unused_imports)]
use progenitor_client::{encode_path, ClientHooks, OperationInfo, RequestBuilderExt};
#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }

        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }

        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }

        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }

    /// An address tied to an address lot.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An address tied to an address lot.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "address_lot"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address and prefix length of this address.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    },
    ///    "address_lot": {
    ///      "description": "The address lot this address is drawn from.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    },
    ///    "vlan_id": {
    ///      "description": "Optional VLAN ID for this address",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Address {
        /// The address and prefix length of this address.
        pub address: IpNet,
        /// The address lot this address is drawn from.
        pub address_lot: NameOrId,
        /// Optional VLAN ID for this address
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vlan_id: ::std::option::Option<u16>,
    }

    impl ::std::convert::From<&Address> for Address {
        fn from(value: &Address) -> Self {
            value.clone()
        }
    }

    impl Address {
        pub fn builder() -> builder::Address {
            Default::default()
        }
    }

    /// A set of addresses associated with a port configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A set of addresses associated with a port
    /// configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "The set of addresses assigned to the port
    /// configuration.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Address"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressConfig {
        /// The set of addresses assigned to the port configuration.
        pub addresses: ::std::vec::Vec<Address>,
    }

    impl ::std::convert::From<&AddressConfig> for AddressConfig {
        fn from(value: &AddressConfig) -> Self {
            value.clone()
        }
    }

    impl AddressConfig {
        pub fn builder() -> builder::AddressConfig {
            Default::default()
        }
    }

    /// Represents an address lot object, containing the id of the lot that can
    /// be used in other API calls.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Represents an address lot object, containing the id of
    /// the lot that can be used in other API calls.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "description": "Desired use of `AddressLot`",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/AddressLotKind"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLot {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// Desired use of `AddressLot`
        pub kind: AddressLotKind,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&AddressLot> for AddressLot {
        fn from(value: &AddressLot) -> Self {
            value.clone()
        }
    }

    impl AddressLot {
        pub fn builder() -> builder::AddressLot {
            Default::default()
        }
    }

    /// An address lot block is a part of an address lot and contains a range of
    /// addresses. The range is inclusive.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An address lot block is a part of an address lot and
    /// contains a range of addresses. The range is inclusive.",
    ///  "type": "object",
    ///  "required": [
    ///    "first_address",
    ///    "id",
    ///    "last_address"
    ///  ],
    ///  "properties": {
    ///    "first_address": {
    ///      "description": "The first address of the block (inclusive).",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "id": {
    ///      "description": "The id of the address lot block.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "last_address": {
    ///      "description": "The last address of the block (inclusive).",
    ///      "type": "string",
    ///      "format": "ip"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLotBlock {
        /// The first address of the block (inclusive).
        pub first_address: ::std::net::IpAddr,
        /// The id of the address lot block.
        pub id: ::uuid::Uuid,
        /// The last address of the block (inclusive).
        pub last_address: ::std::net::IpAddr,
    }

    impl ::std::convert::From<&AddressLotBlock> for AddressLotBlock {
        fn from(value: &AddressLotBlock) -> Self {
            value.clone()
        }
    }

    impl AddressLotBlock {
        pub fn builder() -> builder::AddressLotBlock {
            Default::default()
        }
    }

    /// Parameters for creating an address lot block. Fist and last addresses
    /// are inclusive.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating an address lot block. Fist and
    /// last addresses are inclusive.",
    ///  "type": "object",
    ///  "required": [
    ///    "first_address",
    ///    "last_address"
    ///  ],
    ///  "properties": {
    ///    "first_address": {
    ///      "description": "The first address in the lot (inclusive).",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "last_address": {
    ///      "description": "The last address in the lot (inclusive).",
    ///      "type": "string",
    ///      "format": "ip"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLotBlockCreate {
        /// The first address in the lot (inclusive).
        pub first_address: ::std::net::IpAddr,
        /// The last address in the lot (inclusive).
        pub last_address: ::std::net::IpAddr,
    }

    impl ::std::convert::From<&AddressLotBlockCreate> for AddressLotBlockCreate {
        fn from(value: &AddressLotBlockCreate) -> Self {
            value.clone()
        }
    }

    impl AddressLotBlockCreate {
        pub fn builder() -> builder::AddressLotBlockCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressLotBlock"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLotBlockResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<AddressLotBlock>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AddressLotBlockResultsPage> for AddressLotBlockResultsPage {
        fn from(value: &AddressLotBlockResultsPage) -> Self {
            value.clone()
        }
    }

    impl AddressLotBlockResultsPage {
        pub fn builder() -> builder::AddressLotBlockResultsPage {
            Default::default()
        }
    }

    /// Parameters for creating an address lot.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating an address lot.",
    ///  "type": "object",
    ///  "required": [
    ///    "blocks",
    ///    "description",
    ///    "kind",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "blocks": {
    ///      "description": "The blocks to add along with the new address lot.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressLotBlockCreate"
    ///      }
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "kind": {
    ///      "description": "The kind of address lot to create.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/AddressLotKind"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLotCreate {
        /// The blocks to add along with the new address lot.
        pub blocks: ::std::vec::Vec<AddressLotBlockCreate>,
        pub description: ::std::string::String,
        /// The kind of address lot to create.
        pub kind: AddressLotKind,
        pub name: Name,
    }

    impl ::std::convert::From<&AddressLotCreate> for AddressLotCreate {
        fn from(value: &AddressLotCreate) -> Self {
            value.clone()
        }
    }

    impl AddressLotCreate {
        pub fn builder() -> builder::AddressLotCreate {
            Default::default()
        }
    }

    /// An address lot and associated blocks resulting from creating an address
    /// lot.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An address lot and associated blocks resulting from
    /// creating an address lot.",
    ///  "type": "object",
    ///  "required": [
    ///    "blocks",
    ///    "lot"
    ///  ],
    ///  "properties": {
    ///    "blocks": {
    ///      "description": "The address lot blocks that were created.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressLotBlock"
    ///      }
    ///    },
    ///    "lot": {
    ///      "description": "The address lot that was created.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/AddressLot"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLotCreateResponse {
        /// The address lot blocks that were created.
        pub blocks: ::std::vec::Vec<AddressLotBlock>,
        /// The address lot that was created.
        pub lot: AddressLot,
    }

    impl ::std::convert::From<&AddressLotCreateResponse> for AddressLotCreateResponse {
        fn from(value: &AddressLotCreateResponse) -> Self {
            value.clone()
        }
    }

    impl AddressLotCreateResponse {
        pub fn builder() -> builder::AddressLotCreateResponse {
            Default::default()
        }
    }

    /// The kind associated with an address lot.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The kind associated with an address lot.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Infrastructure address lots are used for network
    /// infrastructure like addresses assigned to rack switches.",
    ///      "type": "string",
    ///      "enum": [
    ///        "infra"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Pool address lots are used by IP pools.",
    ///      "type": "string",
    ///      "enum": [
    ///        "pool"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum AddressLotKind {
        /// Infrastructure address lots are used for network infrastructure like
        /// addresses assigned to rack switches.
        #[serde(rename = "infra")]
        Infra,
        /// Pool address lots are used by IP pools.
        #[serde(rename = "pool")]
        Pool,
    }

    impl ::std::convert::From<&Self> for AddressLotKind {
        fn from(value: &AddressLotKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AddressLotKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Infra => write!(f, "infra"),
                Self::Pool => write!(f, "pool"),
            }
        }
    }

    impl ::std::str::FromStr for AddressLotKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "infra" => Ok(Self::Infra),
                "pool" => Ok(Self::Pool),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AddressLotKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AddressLotKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AddressLotKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AddressLot"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AddressLotResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<AddressLot>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AddressLotResultsPage> for AddressLotResultsPage {
        fn from(value: &AddressLotResultsPage) -> Self {
            value.clone()
        }
    }

    impl AddressLotResultsPage {
        pub fn builder() -> builder::AddressLotResultsPage {
            Default::default()
        }
    }

    /// View of an Affinity Group
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an Affinity Group",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "failure_domain",
    ///    "id",
    ///    "name",
    ///    "policy",
    ///    "project_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "failure_domain": {
    ///      "$ref": "#/components/schemas/FailureDomain"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "policy": {
    ///      "$ref": "#/components/schemas/AffinityPolicy"
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AffinityGroup {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub failure_domain: FailureDomain,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub policy: AffinityPolicy,
        pub project_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&AffinityGroup> for AffinityGroup {
        fn from(value: &AffinityGroup) -> Self {
            value.clone()
        }
    }

    impl AffinityGroup {
        pub fn builder() -> builder::AffinityGroup {
            Default::default()
        }
    }

    /// Create-time parameters for an `AffinityGroup`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `AffinityGroup`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "failure_domain",
    ///    "name",
    ///    "policy"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "failure_domain": {
    ///      "$ref": "#/components/schemas/FailureDomain"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "policy": {
    ///      "$ref": "#/components/schemas/AffinityPolicy"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AffinityGroupCreate {
        pub description: ::std::string::String,
        pub failure_domain: FailureDomain,
        pub name: Name,
        pub policy: AffinityPolicy,
    }

    impl ::std::convert::From<&AffinityGroupCreate> for AffinityGroupCreate {
        fn from(value: &AffinityGroupCreate) -> Self {
            value.clone()
        }
    }

    impl AffinityGroupCreate {
        pub fn builder() -> builder::AffinityGroupCreate {
            Default::default()
        }
    }

    /// A member of an Affinity Group
    ///
    /// Membership in a group is not exclusive - members may belong to multiple
    /// affinity / anti-affinity groups.
    ///
    /// Affinity Groups can contain up to 32 members.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A member of an Affinity Group\n\nMembership in a group is not exclusive - members may belong to multiple affinity / anti-affinity groups.\n\nAffinity Groups can contain up to 32 members.",
    ///  "oneOf": [
    ///    {
    ///      "description": "An instance belonging to this group\n\nInstances
    /// can belong to up to 16 affinity groups.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "object",
    ///          "required": [
    ///            "id",
    ///            "name",
    ///            "run_state"
    ///          ],
    ///          "properties": {
    ///            "id": {
    ///              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
    ///            },
    ///            "name": {
    ///              "$ref": "#/components/schemas/Name"
    ///            },
    ///            "run_state": {
    ///              "$ref": "#/components/schemas/InstanceState"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum AffinityGroupMember {
        /// An instance belonging to this group
        ///
        /// Instances can belong to up to 16 affinity groups.
        #[serde(rename = "instance")]
        Instance {
            id: TypedUuidForInstanceKind,
            name: Name,
            run_state: InstanceState,
        },
    }

    impl ::std::convert::From<&Self> for AffinityGroupMember {
        fn from(value: &AffinityGroupMember) -> Self {
            value.clone()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AffinityGroupMember"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AffinityGroupMemberResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<AffinityGroupMember>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AffinityGroupMemberResultsPage> for AffinityGroupMemberResultsPage {
        fn from(value: &AffinityGroupMemberResultsPage) -> Self {
            value.clone()
        }
    }

    impl AffinityGroupMemberResultsPage {
        pub fn builder() -> builder::AffinityGroupMemberResultsPage {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AffinityGroup"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AffinityGroupResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<AffinityGroup>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AffinityGroupResultsPage> for AffinityGroupResultsPage {
        fn from(value: &AffinityGroupResultsPage) -> Self {
            value.clone()
        }
    }

    impl AffinityGroupResultsPage {
        pub fn builder() -> builder::AffinityGroupResultsPage {
            Default::default()
        }
    }

    /// Updateable properties of an `AffinityGroup`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of an `AffinityGroup`",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AffinityGroupUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&AffinityGroupUpdate> for AffinityGroupUpdate {
        fn from(value: &AffinityGroupUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AffinityGroupUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl AffinityGroupUpdate {
        pub fn builder() -> builder::AffinityGroupUpdate {
            Default::default()
        }
    }

    /// Affinity policy used to describe "what to do when a request cannot be
    /// satisfied"
    ///
    /// Used for both Affinity and Anti-Affinity Groups
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Affinity policy used to describe \"what to do when a
    /// request cannot be satisfied\"\n\nUsed for both Affinity and
    /// Anti-Affinity Groups",
    ///  "oneOf": [
    ///    {
    ///      "description": "If the affinity request cannot be satisfied, allow
    /// it anyway.\n\nThis enables a \"best-effort\" attempt to satisfy the
    /// affinity policy.",
    ///      "type": "string",
    ///      "enum": [
    ///        "allow"
    ///      ]
    ///    },
    ///    {
    ///      "description": "If the affinity request cannot be satisfied, fail
    /// explicitly.",
    ///      "type": "string",
    ///      "enum": [
    ///        "fail"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum AffinityPolicy {
        /// If the affinity request cannot be satisfied, allow it anyway.
        ///
        /// This enables a "best-effort" attempt to satisfy the affinity policy.
        #[serde(rename = "allow")]
        Allow,
        /// If the affinity request cannot be satisfied, fail explicitly.
        #[serde(rename = "fail")]
        Fail,
    }

    impl ::std::convert::From<&Self> for AffinityPolicy {
        fn from(value: &AffinityPolicy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AffinityPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allow => write!(f, "allow"),
                Self::Fail => write!(f, "fail"),
            }
        }
    }

    impl ::std::str::FromStr for AffinityPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "allow" => Ok(Self::Allow),
                "fail" => Ok(Self::Fail),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AffinityPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AffinityPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AffinityPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// BGP message history for rack switches.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "BGP message history for rack switches.",
    ///  "type": "object",
    ///  "required": [
    ///    "switch_histories"
    ///  ],
    ///  "properties": {
    ///    "switch_histories": {
    ///      "description": "BGP history organized by switch.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchBgpHistory"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AggregateBgpMessageHistory {
        /// BGP history organized by switch.
        pub switch_histories: ::std::vec::Vec<SwitchBgpHistory>,
    }

    impl ::std::convert::From<&AggregateBgpMessageHistory> for AggregateBgpMessageHistory {
        fn from(value: &AggregateBgpMessageHistory) -> Self {
            value.clone()
        }
    }

    impl AggregateBgpMessageHistory {
        pub fn builder() -> builder::AggregateBgpMessageHistory {
            Default::default()
        }
    }

    /// Allowlist of IPs or subnets that can make requests to user-facing
    /// services.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Allowlist of IPs or subnets that can make requests to
    /// user-facing services.",
    ///  "type": "object",
    ///  "required": [
    ///    "allowed_ips",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "allowed_ips": {
    ///      "description": "The allowlist of IPs or subnets.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/AllowedSourceIps"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "Time the list was created.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "Time the list was last modified.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AllowList {
        /// The allowlist of IPs or subnets.
        pub allowed_ips: AllowedSourceIps,
        /// Time the list was created.
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// Time the list was last modified.
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&AllowList> for AllowList {
        fn from(value: &AllowList) -> Self {
            value.clone()
        }
    }

    impl AllowList {
        pub fn builder() -> builder::AllowList {
            Default::default()
        }
    }

    /// Parameters for updating allowed source IPs
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for updating allowed source IPs",
    ///  "type": "object",
    ///  "required": [
    ///    "allowed_ips"
    ///  ],
    ///  "properties": {
    ///    "allowed_ips": {
    ///      "description": "The new list of allowed source IPs.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/AllowedSourceIps"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AllowListUpdate {
        /// The new list of allowed source IPs.
        pub allowed_ips: AllowedSourceIps,
    }

    impl ::std::convert::From<&AllowListUpdate> for AllowListUpdate {
        fn from(value: &AllowListUpdate) -> Self {
            value.clone()
        }
    }

    impl AllowListUpdate {
        pub fn builder() -> builder::AllowListUpdate {
            Default::default()
        }
    }

    /// Description of source IPs allowed to reach rack services.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Description of source IPs allowed to reach rack
    /// services.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Allow traffic from any external IP address.",
    ///      "type": "object",
    ///      "required": [
    ///        "allow"
    ///      ],
    ///      "properties": {
    ///        "allow": {
    ///          "type": "string",
    ///          "enum": [
    ///            "any"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Restrict access to a specific set of source IP
    /// addresses or subnets.\n\nAll others are prevented from reaching rack
    /// services.",
    ///      "type": "object",
    ///      "required": [
    ///        "allow",
    ///        "ips"
    ///      ],
    ///      "properties": {
    ///        "allow": {
    ///          "type": "string",
    ///          "enum": [
    ///            "list"
    ///          ]
    ///        },
    ///        "ips": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/IpNet"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "allow", content = "ips")]
    pub enum AllowedSourceIps {
        #[serde(rename = "any")]
        Any,
        /// Restrict access to a specific set of source IP addresses or subnets.
        ///
        /// All others are prevented from reaching rack services.
        #[serde(rename = "list")]
        List(::std::vec::Vec<IpNet>),
    }

    impl ::std::convert::From<&Self> for AllowedSourceIps {
        fn from(value: &AllowedSourceIps) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<IpNet>> for AllowedSourceIps {
        fn from(value: ::std::vec::Vec<IpNet>) -> Self {
            Self::List(value)
        }
    }

    /// View of an Anti-Affinity Group
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an Anti-Affinity Group",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "failure_domain",
    ///    "id",
    ///    "name",
    ///    "policy",
    ///    "project_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "failure_domain": {
    ///      "$ref": "#/components/schemas/FailureDomain"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "policy": {
    ///      "$ref": "#/components/schemas/AffinityPolicy"
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AntiAffinityGroup {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub failure_domain: FailureDomain,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub policy: AffinityPolicy,
        pub project_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&AntiAffinityGroup> for AntiAffinityGroup {
        fn from(value: &AntiAffinityGroup) -> Self {
            value.clone()
        }
    }

    impl AntiAffinityGroup {
        pub fn builder() -> builder::AntiAffinityGroup {
            Default::default()
        }
    }

    /// Create-time parameters for an `AntiAffinityGroup`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `AntiAffinityGroup`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "failure_domain",
    ///    "name",
    ///    "policy"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "failure_domain": {
    ///      "$ref": "#/components/schemas/FailureDomain"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "policy": {
    ///      "$ref": "#/components/schemas/AffinityPolicy"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AntiAffinityGroupCreate {
        pub description: ::std::string::String,
        pub failure_domain: FailureDomain,
        pub name: Name,
        pub policy: AffinityPolicy,
    }

    impl ::std::convert::From<&AntiAffinityGroupCreate> for AntiAffinityGroupCreate {
        fn from(value: &AntiAffinityGroupCreate) -> Self {
            value.clone()
        }
    }

    impl AntiAffinityGroupCreate {
        pub fn builder() -> builder::AntiAffinityGroupCreate {
            Default::default()
        }
    }

    /// A member of an Anti-Affinity Group
    ///
    /// Membership in a group is not exclusive - members may belong to multiple
    /// affinity / anti-affinity groups.
    ///
    /// Anti-Affinity Groups can contain up to 32 members.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A member of an Anti-Affinity Group\n\nMembership in a
    /// group is not exclusive - members may belong to multiple affinity /
    /// anti-affinity groups.\n\nAnti-Affinity Groups can contain up to 32
    /// members.",
    ///  "oneOf": [
    ///    {
    ///      "description": "An instance belonging to this group\n\nInstances
    /// can belong to up to 16 anti-affinity groups.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "object",
    ///          "required": [
    ///            "id",
    ///            "name",
    ///            "run_state"
    ///          ],
    ///          "properties": {
    ///            "id": {
    ///              "$ref": "#/components/schemas/TypedUuidForInstanceKind"
    ///            },
    ///            "name": {
    ///              "$ref": "#/components/schemas/Name"
    ///            },
    ///            "run_state": {
    ///              "$ref": "#/components/schemas/InstanceState"
    ///            }
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum AntiAffinityGroupMember {
        /// An instance belonging to this group
        ///
        /// Instances can belong to up to 16 anti-affinity groups.
        #[serde(rename = "instance")]
        Instance {
            id: TypedUuidForInstanceKind,
            name: Name,
            run_state: InstanceState,
        },
    }

    impl ::std::convert::From<&Self> for AntiAffinityGroupMember {
        fn from(value: &AntiAffinityGroupMember) -> Self {
            value.clone()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AntiAffinityGroupMember"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AntiAffinityGroupMemberResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<AntiAffinityGroupMember>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AntiAffinityGroupMemberResultsPage>
        for AntiAffinityGroupMemberResultsPage
    {
        fn from(value: &AntiAffinityGroupMemberResultsPage) -> Self {
            value.clone()
        }
    }

    impl AntiAffinityGroupMemberResultsPage {
        pub fn builder() -> builder::AntiAffinityGroupMemberResultsPage {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/AntiAffinityGroup"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AntiAffinityGroupResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<AntiAffinityGroup>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&AntiAffinityGroupResultsPage> for AntiAffinityGroupResultsPage {
        fn from(value: &AntiAffinityGroupResultsPage) -> Self {
            value.clone()
        }
    }

    impl AntiAffinityGroupResultsPage {
        pub fn builder() -> builder::AntiAffinityGroupResultsPage {
            Default::default()
        }
    }

    /// Updateable properties of an `AntiAffinityGroup`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of an `AntiAffinityGroup`",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct AntiAffinityGroupUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&AntiAffinityGroupUpdate> for AntiAffinityGroupUpdate {
        fn from(value: &AntiAffinityGroupUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for AntiAffinityGroupUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl AntiAffinityGroupUpdate {
        pub fn builder() -> builder::AntiAffinityGroupUpdate {
            Default::default()
        }
    }

    /// Authorization scope for a timeseries.
    ///
    /// This describes the level at which a user must be authorized to read data
    /// from a timeseries. For example, fleet-scoping means the data is only
    /// visible to an operator or fleet reader. Project-scoped, on the other
    /// hand, indicates that a user will see data limited to the projects on
    /// which they have read permissions.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Authorization scope for a timeseries.\n\nThis describes
    /// the level at which a user must be authorized to read data from a
    /// timeseries. For example, fleet-scoping means the data is only visible to
    /// an operator or fleet reader. Project-scoped, on the other hand,
    /// indicates that a user will see data limited to the projects on which
    /// they have read permissions.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Timeseries data is limited to fleet readers.",
    ///      "type": "string",
    ///      "enum": [
    ///        "fleet"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Timeseries data is limited to the authorized silo
    /// for a user.",
    ///      "type": "string",
    ///      "enum": [
    ///        "silo"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Timeseries data is limited to the authorized
    /// projects for a user.",
    ///      "type": "string",
    ///      "enum": [
    ///        "project"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The timeseries is viewable to all without
    /// limitation.",
    ///      "type": "string",
    ///      "enum": [
    ///        "viewable_to_all"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum AuthzScope {
        /// Timeseries data is limited to fleet readers.
        #[serde(rename = "fleet")]
        Fleet,
        /// Timeseries data is limited to the authorized silo for a user.
        #[serde(rename = "silo")]
        Silo,
        /// Timeseries data is limited to the authorized projects for a user.
        #[serde(rename = "project")]
        Project,
        /// The timeseries is viewable to all without limitation.
        #[serde(rename = "viewable_to_all")]
        ViewableToAll,
    }

    impl ::std::convert::From<&Self> for AuthzScope {
        fn from(value: &AuthzScope) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for AuthzScope {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Fleet => write!(f, "fleet"),
                Self::Silo => write!(f, "silo"),
                Self::Project => write!(f, "project"),
                Self::ViewableToAll => write!(f, "viewable_to_all"),
            }
        }
    }

    impl ::std::str::FromStr for AuthzScope {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "fleet" => Ok(Self::Fleet),
                "silo" => Ok(Self::Silo),
                "project" => Ok(Self::Project),
                "viewable_to_all" => Ok(Self::ViewableToAll),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for AuthzScope {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for AuthzScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for AuthzScope {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Properties that uniquely identify an Oxide hardware component
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Properties that uniquely identify an Oxide hardware
    /// component",
    ///  "type": "object",
    ///  "required": [
    ///    "part",
    ///    "revision",
    ///    "serial"
    ///  ],
    ///  "properties": {
    ///    "part": {
    ///      "type": "string"
    ///    },
    ///    "revision": {
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Baseboard {
        pub part: ::std::string::String,
        pub revision: u32,
        pub serial: ::std::string::String,
    }

    impl ::std::convert::From<&Baseboard> for Baseboard {
        fn from(value: &Baseboard) -> Self {
            value.clone()
        }
    }

    impl Baseboard {
        pub fn builder() -> builder::Baseboard {
            Default::default()
        }
    }

    /// BFD connection mode.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "BFD connection mode.",
    ///  "type": "string",
    ///  "enum": [
    ///    "single_hop",
    ///    "multi_hop"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum BfdMode {
        #[serde(rename = "single_hop")]
        SingleHop,
        #[serde(rename = "multi_hop")]
        MultiHop,
    }

    impl ::std::convert::From<&Self> for BfdMode {
        fn from(value: &BfdMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BfdMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SingleHop => write!(f, "single_hop"),
                Self::MultiHop => write!(f, "multi_hop"),
            }
        }
    }

    impl ::std::str::FromStr for BfdMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "single_hop" => Ok(Self::SingleHop),
                "multi_hop" => Ok(Self::MultiHop),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BfdMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BfdMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BfdMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Information needed to disable a BFD session
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Information needed to disable a BFD session",
    ///  "type": "object",
    ///  "required": [
    ///    "remote",
    ///    "switch"
    ///  ],
    ///  "properties": {
    ///    "remote": {
    ///      "description": "Address of the remote peer to disable a BFD session
    /// for.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "switch": {
    ///      "description": "The switch to enable this session on. Must be
    /// `switch0` or `switch1`.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BfdSessionDisable {
        /// Address of the remote peer to disable a BFD session for.
        pub remote: ::std::net::IpAddr,
        /// The switch to enable this session on. Must be `switch0` or
        /// `switch1`.
        pub switch: Name,
    }

    impl ::std::convert::From<&BfdSessionDisable> for BfdSessionDisable {
        fn from(value: &BfdSessionDisable) -> Self {
            value.clone()
        }
    }

    impl BfdSessionDisable {
        pub fn builder() -> builder::BfdSessionDisable {
            Default::default()
        }
    }

    /// Information about a bidirectional forwarding detection (BFD) session.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Information about a bidirectional forwarding detection
    /// (BFD) session.",
    ///  "type": "object",
    ///  "required": [
    ///    "detection_threshold",
    ///    "mode",
    ///    "remote",
    ///    "required_rx",
    ///    "switch"
    ///  ],
    ///  "properties": {
    ///    "detection_threshold": {
    ///      "description": "The negotiated Control packet transmission
    /// interval, multiplied by this variable, will be the Detection Time for
    /// this session (as seen by the remote system)",
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "local": {
    ///      "description": "Address the Oxide switch will listen on for BFD
    /// traffic. If `None` then the unspecified address (0.0.0.0 or ::) is
    /// used.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "mode": {
    ///      "description": "Select either single-hop (RFC 5881) or multi-hop
    /// (RFC 5883)",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BfdMode"
    ///        }
    ///      ]
    ///    },
    ///    "remote": {
    ///      "description": "Address of the remote peer to establish a BFD
    /// session with.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "required_rx": {
    ///      "description": "The minimum interval, in microseconds, between
    /// received BFD Control packets that this system requires",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "switch": {
    ///      "description": "The switch to enable this session on. Must be
    /// `switch0` or `switch1`.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BfdSessionEnable {
        /// The negotiated Control packet transmission interval, multiplied by
        /// this variable, will be the Detection Time for this session (as seen
        /// by the remote system)
        pub detection_threshold: u8,
        /// Address the Oxide switch will listen on for BFD traffic. If `None`
        /// then the unspecified address (0.0.0.0 or ::) is used.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub local: ::std::option::Option<::std::net::IpAddr>,
        /// Select either single-hop (RFC 5881) or multi-hop (RFC 5883)
        pub mode: BfdMode,
        /// Address of the remote peer to establish a BFD session with.
        pub remote: ::std::net::IpAddr,
        /// The minimum interval, in microseconds, between received BFD Control
        /// packets that this system requires
        pub required_rx: u64,
        /// The switch to enable this session on. Must be `switch0` or
        /// `switch1`.
        pub switch: Name,
    }

    impl ::std::convert::From<&BfdSessionEnable> for BfdSessionEnable {
        fn from(value: &BfdSessionEnable) -> Self {
            value.clone()
        }
    }

    impl BfdSessionEnable {
        pub fn builder() -> builder::BfdSessionEnable {
            Default::default()
        }
    }

    /// `BfdState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "description": "A stable down state. Non-responsive to incoming
    /// messages.",
    ///      "type": "string",
    ///      "enum": [
    ///        "admin_down"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The initial state.",
    ///      "type": "string",
    ///      "enum": [
    ///        "down"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The peer has detected a remote peer in the down
    /// state.",
    ///      "type": "string",
    ///      "enum": [
    ///        "init"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The peer has detected a remote peer in the up or
    /// init state while in the init state.",
    ///      "type": "string",
    ///      "enum": [
    ///        "up"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum BfdState {
        /// A stable down state. Non-responsive to incoming messages.
        #[serde(rename = "admin_down")]
        AdminDown,
        /// The initial state.
        #[serde(rename = "down")]
        Down,
        /// The peer has detected a remote peer in the down state.
        #[serde(rename = "init")]
        Init,
        /// The peer has detected a remote peer in the up or init state while in
        /// the init state.
        #[serde(rename = "up")]
        Up,
    }

    impl ::std::convert::From<&Self> for BfdState {
        fn from(value: &BfdState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BfdState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::AdminDown => write!(f, "admin_down"),
                Self::Down => write!(f, "down"),
                Self::Init => write!(f, "init"),
                Self::Up => write!(f, "up"),
            }
        }
    }

    impl ::std::str::FromStr for BfdState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin_down" => Ok(Self::AdminDown),
                "down" => Ok(Self::Down),
                "init" => Ok(Self::Init),
                "up" => Ok(Self::Up),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BfdState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BfdState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BfdState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `BfdStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "detection_threshold",
    ///    "mode",
    ///    "peer",
    ///    "required_rx",
    ///    "state",
    ///    "switch"
    ///  ],
    ///  "properties": {
    ///    "detection_threshold": {
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "local": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "mode": {
    ///      "$ref": "#/components/schemas/BfdMode"
    ///    },
    ///    "peer": {
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "required_rx": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/BfdState"
    ///    },
    ///    "switch": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BfdStatus {
        pub detection_threshold: u8,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub local: ::std::option::Option<::std::net::IpAddr>,
        pub mode: BfdMode,
        pub peer: ::std::net::IpAddr,
        pub required_rx: u64,
        pub state: BfdState,
        pub switch: Name,
    }

    impl ::std::convert::From<&BfdStatus> for BfdStatus {
        fn from(value: &BfdStatus) -> Self {
            value.clone()
        }
    }

    impl BfdStatus {
        pub fn builder() -> builder::BfdStatus {
            Default::default()
        }
    }

    /// Represents a BGP announce set by id. The id can be used with other API
    /// calls to view and manage the announce set.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Represents a BGP announce set by id. The id can be used
    /// with other API calls to view and manage the announce set.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpAnnounceSet {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&BgpAnnounceSet> for BgpAnnounceSet {
        fn from(value: &BgpAnnounceSet) -> Self {
            value.clone()
        }
    }

    impl BgpAnnounceSet {
        pub fn builder() -> builder::BgpAnnounceSet {
            Default::default()
        }
    }

    /// Parameters for creating a named set of BGP announcements.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating a named set of BGP
    /// announcements.",
    ///  "type": "object",
    ///  "required": [
    ///    "announcement",
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "announcement": {
    ///      "description": "The announcements in this set.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BgpAnnouncementCreate"
    ///      }
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpAnnounceSetCreate {
        /// The announcements in this set.
        pub announcement: ::std::vec::Vec<BgpAnnouncementCreate>,
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&BgpAnnounceSetCreate> for BgpAnnounceSetCreate {
        fn from(value: &BgpAnnounceSetCreate) -> Self {
            value.clone()
        }
    }

    impl BgpAnnounceSetCreate {
        pub fn builder() -> builder::BgpAnnounceSetCreate {
            Default::default()
        }
    }

    /// A BGP announcement tied to an address lot block.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A BGP announcement tied to an address lot block.",
    ///  "type": "object",
    ///  "required": [
    ///    "address_lot_block_id",
    ///    "announce_set_id",
    ///    "network"
    ///  ],
    ///  "properties": {
    ///    "address_lot_block_id": {
    ///      "description": "The address block the IP network being announced is
    /// drawn from.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "announce_set_id": {
    ///      "description": "The id of the set this announcement is a part of.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "network": {
    ///      "description": "The IP network being announced.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpAnnouncement {
        /// The address block the IP network being announced is drawn from.
        pub address_lot_block_id: ::uuid::Uuid,
        /// The id of the set this announcement is a part of.
        pub announce_set_id: ::uuid::Uuid,
        /// The IP network being announced.
        pub network: IpNet,
    }

    impl ::std::convert::From<&BgpAnnouncement> for BgpAnnouncement {
        fn from(value: &BgpAnnouncement) -> Self {
            value.clone()
        }
    }

    impl BgpAnnouncement {
        pub fn builder() -> builder::BgpAnnouncement {
            Default::default()
        }
    }

    /// A BGP announcement tied to a particular address lot block.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A BGP announcement tied to a particular address lot
    /// block.",
    ///  "type": "object",
    ///  "required": [
    ///    "address_lot_block",
    ///    "network"
    ///  ],
    ///  "properties": {
    ///    "address_lot_block": {
    ///      "description": "Address lot this announcement is drawn from.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    },
    ///    "network": {
    ///      "description": "The network being announced.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpAnnouncementCreate {
        /// Address lot this announcement is drawn from.
        pub address_lot_block: NameOrId,
        /// The network being announced.
        pub network: IpNet,
    }

    impl ::std::convert::From<&BgpAnnouncementCreate> for BgpAnnouncementCreate {
        fn from(value: &BgpAnnouncementCreate) -> Self {
            value.clone()
        }
    }

    impl BgpAnnouncementCreate {
        pub fn builder() -> builder::BgpAnnouncementCreate {
            Default::default()
        }
    }

    /// A base BGP configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A base BGP configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "asn",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "asn": {
    ///      "description": "The autonomous system number of this BGP
    /// configuration.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vrf": {
    ///      "description": "Optional virtual routing and forwarding identifier
    /// for this BGP configuration.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpConfig {
        /// The autonomous system number of this BGP configuration.
        pub asn: u32,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// Optional virtual routing and forwarding identifier for this BGP
        /// configuration.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vrf: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&BgpConfig> for BgpConfig {
        fn from(value: &BgpConfig) -> Self {
            value.clone()
        }
    }

    impl BgpConfig {
        pub fn builder() -> builder::BgpConfig {
            Default::default()
        }
    }

    /// Parameters for creating a BGP configuration. This includes and
    /// autonomous system number (ASN) and a virtual routing and forwarding
    /// (VRF) identifier.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating a BGP configuration. This
    /// includes and autonomous system number (ASN) and a virtual routing and
    /// forwarding (VRF) identifier.",
    ///  "type": "object",
    ///  "required": [
    ///    "asn",
    ///    "bgp_announce_set_id",
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "asn": {
    ///      "description": "The autonomous system number of this BGP
    /// configuration.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "bgp_announce_set_id": {
    ///      "$ref": "#/components/schemas/NameOrId"
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "vrf": {
    ///      "description": "Optional virtual routing and forwarding identifier
    /// for this BGP configuration.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpConfigCreate {
        /// The autonomous system number of this BGP configuration.
        pub asn: u32,
        pub bgp_announce_set_id: NameOrId,
        pub description: ::std::string::String,
        pub name: Name,
        /// Optional virtual routing and forwarding identifier for this BGP
        /// configuration.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vrf: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&BgpConfigCreate> for BgpConfigCreate {
        fn from(value: &BgpConfigCreate) -> Self {
            value.clone()
        }
    }

    impl BgpConfigCreate {
        pub fn builder() -> builder::BgpConfigCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BgpConfig"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpConfigResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<BgpConfig>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&BgpConfigResultsPage> for BgpConfigResultsPage {
        fn from(value: &BgpConfigResultsPage) -> Self {
            value.clone()
        }
    }

    impl BgpConfigResultsPage {
        pub fn builder() -> builder::BgpConfigResultsPage {
            Default::default()
        }
    }

    /// The current status of a BGP peer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The current status of a BGP peer.",
    ///  "type": "object",
    ///  "required": [
    ///    "exports"
    ///  ],
    ///  "properties": {
    ///    "exports": {
    ///      "description": "Exported routes indexed by peer address.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "array",
    ///        "items": {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpExported {
        /// Exported routes indexed by peer address.
        pub exports: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<Ipv4Net>>,
    }

    impl ::std::convert::From<&BgpExported> for BgpExported {
        fn from(value: &BgpExported) -> Self {
            value.clone()
        }
    }

    impl BgpExported {
        pub fn builder() -> builder::BgpExported {
            Default::default()
        }
    }

    /// A route imported from a BGP peer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A route imported from a BGP peer.",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "nexthop",
    ///    "prefix",
    ///    "switch"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "BGP identifier of the originating router.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "nexthop": {
    ///      "description": "The nexthop the prefix is reachable through.",
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    },
    ///    "prefix": {
    ///      "description": "The destination network prefix.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "switch": {
    ///      "description": "Switch the route is imported into.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchLocation"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpImportedRouteIpv4 {
        /// BGP identifier of the originating router.
        pub id: u32,
        /// The nexthop the prefix is reachable through.
        pub nexthop: ::std::net::Ipv4Addr,
        /// The destination network prefix.
        pub prefix: Ipv4Net,
        /// Switch the route is imported into.
        pub switch: SwitchLocation,
    }

    impl ::std::convert::From<&BgpImportedRouteIpv4> for BgpImportedRouteIpv4 {
        fn from(value: &BgpImportedRouteIpv4) -> Self {
            value.clone()
        }
    }

    impl BgpImportedRouteIpv4 {
        pub fn builder() -> builder::BgpImportedRouteIpv4 {
            Default::default()
        }
    }

    /// `BgpMessageHistory`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct BgpMessageHistory(pub ::serde_json::Value);
    impl ::std::ops::Deref for BgpMessageHistory {
        type Target = ::serde_json::Value;
        fn deref(&self) -> &::serde_json::Value {
            &self.0
        }
    }

    impl ::std::convert::From<BgpMessageHistory> for ::serde_json::Value {
        fn from(value: BgpMessageHistory) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&BgpMessageHistory> for BgpMessageHistory {
        fn from(value: &BgpMessageHistory) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Value> for BgpMessageHistory {
        fn from(value: ::serde_json::Value) -> Self {
            Self(value)
        }
    }

    /// A BGP peer configuration for an interface. Includes the set of
    /// announcements that will be advertised to the peer identified by `addr`.
    /// The `bgp_config` parameter is a reference to global BGP parameters. The
    /// `interface_name` indicates what interface the peer should be contacted
    /// on.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A BGP peer configuration for an interface. Includes the
    /// set of announcements that will be advertised to the peer identified by
    /// `addr`. The `bgp_config` parameter is a reference to global BGP
    /// parameters. The `interface_name` indicates what interface the peer
    /// should be contacted on.",
    ///  "type": "object",
    ///  "required": [
    ///    "addr",
    ///    "allowed_export",
    ///    "allowed_import",
    ///    "bgp_config",
    ///    "communities",
    ///    "connect_retry",
    ///    "delay_open",
    ///    "enforce_first_as",
    ///    "hold_time",
    ///    "idle_hold_time",
    ///    "interface_name",
    ///    "keepalive"
    ///  ],
    ///  "properties": {
    ///    "addr": {
    ///      "description": "The address of the host to peer with.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "allowed_export": {
    ///      "description": "Define export policy for a peer.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImportExportPolicy"
    ///        }
    ///      ]
    ///    },
    ///    "allowed_import": {
    ///      "description": "Define import policy for a peer.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImportExportPolicy"
    ///        }
    ///      ]
    ///    },
    ///    "bgp_config": {
    ///      "description": "The global BGP configuration used for establishing
    /// a session with this peer.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    },
    ///    "communities": {
    ///      "description": "Include the provided communities in updates sent to
    /// the peer.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint32",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "connect_retry": {
    ///      "description": "How long to to wait between TCP connection retries
    /// (seconds).",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "delay_open": {
    ///      "description": "How long to delay sending an open request after
    /// establishing a TCP session (seconds).",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "enforce_first_as": {
    ///      "description": "Enforce that the first AS in paths received from
    /// this peer is the peer's AS.",
    ///      "type": "boolean"
    ///    },
    ///    "hold_time": {
    ///      "description": "How long to hold peer connections between
    /// keepalives (seconds).",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "idle_hold_time": {
    ///      "description": "How long to hold a peer in idle before attempting a
    /// new session (seconds).",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "interface_name": {
    ///      "description": "The name of interface to peer on. This is relative
    /// to the port configuration this BGP peer configuration is a part of. For
    /// example this value could be phy0 to refer to a primary physical
    /// interface. Or it could be vlan47 to refer to a VLAN interface.",
    ///      "type": "string"
    ///    },
    ///    "keepalive": {
    ///      "description": "How often to send keepalive requests (seconds).",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "local_pref": {
    ///      "description": "Apply a local preference to routes received from
    /// this peer.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "md5_auth_key": {
    ///      "description": "Use the given key for TCP-MD5 authentication with
    /// the peer.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "min_ttl": {
    ///      "description": "Require messages from a peer have a minimum IP time
    /// to live field.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "multi_exit_discriminator": {
    ///      "description": "Apply the provided multi-exit discriminator (MED)
    /// updates sent to the peer.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "remote_asn": {
    ///      "description": "Require that a peer has a specified ASN.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "vlan_id": {
    ///      "description": "Associate a VLAN ID with a peer.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpPeer {
        /// The address of the host to peer with.
        pub addr: ::std::net::IpAddr,
        /// Define export policy for a peer.
        pub allowed_export: ImportExportPolicy,
        /// Define import policy for a peer.
        pub allowed_import: ImportExportPolicy,
        /// The global BGP configuration used for establishing a session with
        /// this peer.
        pub bgp_config: NameOrId,
        /// Include the provided communities in updates sent to the peer.
        pub communities: ::std::vec::Vec<u32>,
        /// How long to to wait between TCP connection retries (seconds).
        pub connect_retry: u32,
        /// How long to delay sending an open request after establishing a TCP
        /// session (seconds).
        pub delay_open: u32,
        /// Enforce that the first AS in paths received from this peer is the
        /// peer's AS.
        pub enforce_first_as: bool,
        /// How long to hold peer connections between keepalives (seconds).
        pub hold_time: u32,
        /// How long to hold a peer in idle before attempting a new session
        /// (seconds).
        pub idle_hold_time: u32,
        /// The name of interface to peer on. This is relative to the port
        /// configuration this BGP peer configuration is a part of. For example
        /// this value could be phy0 to refer to a primary physical interface.
        /// Or it could be vlan47 to refer to a VLAN interface.
        pub interface_name: ::std::string::String,
        /// How often to send keepalive requests (seconds).
        pub keepalive: u32,
        /// Apply a local preference to routes received from this peer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub local_pref: ::std::option::Option<u32>,
        /// Use the given key for TCP-MD5 authentication with the peer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub md5_auth_key: ::std::option::Option<::std::string::String>,
        /// Require messages from a peer have a minimum IP time to live field.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min_ttl: ::std::option::Option<u8>,
        /// Apply the provided multi-exit discriminator (MED) updates sent to
        /// the peer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub multi_exit_discriminator: ::std::option::Option<u32>,
        /// Require that a peer has a specified ASN.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub remote_asn: ::std::option::Option<u32>,
        /// Associate a VLAN ID with a peer.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vlan_id: ::std::option::Option<u16>,
    }

    impl ::std::convert::From<&BgpPeer> for BgpPeer {
        fn from(value: &BgpPeer) -> Self {
            value.clone()
        }
    }

    impl BgpPeer {
        pub fn builder() -> builder::BgpPeer {
            Default::default()
        }
    }

    /// `BgpPeerConfig`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "peers"
    ///  ],
    ///  "properties": {
    ///    "peers": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BgpPeer"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpPeerConfig {
        pub peers: ::std::vec::Vec<BgpPeer>,
    }

    impl ::std::convert::From<&BgpPeerConfig> for BgpPeerConfig {
        fn from(value: &BgpPeerConfig) -> Self {
            value.clone()
        }
    }

    impl BgpPeerConfig {
        pub fn builder() -> builder::BgpPeerConfig {
            Default::default()
        }
    }

    /// The current state of a BGP peer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The current state of a BGP peer.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Initial state. Refuse all incoming BGP connections.
    /// No resources allocated to peer.",
    ///      "type": "string",
    ///      "enum": [
    ///        "idle"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Waiting for the TCP connection to be completed.",
    ///      "type": "string",
    ///      "enum": [
    ///        "connect"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Trying to acquire peer by listening for and
    /// accepting a TCP connection.",
    ///      "type": "string",
    ///      "enum": [
    ///        "active"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Waiting for open message from peer.",
    ///      "type": "string",
    ///      "enum": [
    ///        "open_sent"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Waiting for keepaliave or notification from peer.",
    ///      "type": "string",
    ///      "enum": [
    ///        "open_confirm"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Synchronizing with peer.",
    ///      "type": "string",
    ///      "enum": [
    ///        "session_setup"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Session established. Able to exchange update,
    /// notification and keepalive messages with peers.",
    ///      "type": "string",
    ///      "enum": [
    ///        "established"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum BgpPeerState {
        /// Initial state. Refuse all incoming BGP connections. No resources
        /// allocated to peer.
        #[serde(rename = "idle")]
        Idle,
        /// Waiting for the TCP connection to be completed.
        #[serde(rename = "connect")]
        Connect,
        /// Trying to acquire peer by listening for and accepting a TCP
        /// connection.
        #[serde(rename = "active")]
        Active,
        /// Waiting for open message from peer.
        #[serde(rename = "open_sent")]
        OpenSent,
        /// Waiting for keepaliave or notification from peer.
        #[serde(rename = "open_confirm")]
        OpenConfirm,
        /// Synchronizing with peer.
        #[serde(rename = "session_setup")]
        SessionSetup,
        /// Session established. Able to exchange update, notification and
        /// keepalive messages with peers.
        #[serde(rename = "established")]
        Established,
    }

    impl ::std::convert::From<&Self> for BgpPeerState {
        fn from(value: &BgpPeerState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for BgpPeerState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Idle => write!(f, "idle"),
                Self::Connect => write!(f, "connect"),
                Self::Active => write!(f, "active"),
                Self::OpenSent => write!(f, "open_sent"),
                Self::OpenConfirm => write!(f, "open_confirm"),
                Self::SessionSetup => write!(f, "session_setup"),
                Self::Established => write!(f, "established"),
            }
        }
    }

    impl ::std::str::FromStr for BgpPeerState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "idle" => Ok(Self::Idle),
                "connect" => Ok(Self::Connect),
                "active" => Ok(Self::Active),
                "open_sent" => Ok(Self::OpenSent),
                "open_confirm" => Ok(Self::OpenConfirm),
                "session_setup" => Ok(Self::SessionSetup),
                "established" => Ok(Self::Established),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for BgpPeerState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for BgpPeerState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for BgpPeerState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The current status of a BGP peer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The current status of a BGP peer.",
    ///  "type": "object",
    ///  "required": [
    ///    "addr",
    ///    "local_asn",
    ///    "remote_asn",
    ///    "state",
    ///    "state_duration_millis",
    ///    "switch"
    ///  ],
    ///  "properties": {
    ///    "addr": {
    ///      "description": "IP address of the peer.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "local_asn": {
    ///      "description": "Local autonomous system number.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "remote_asn": {
    ///      "description": "Remote autonomous system number.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "state": {
    ///      "description": "State of the peer.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BgpPeerState"
    ///        }
    ///      ]
    ///    },
    ///    "state_duration_millis": {
    ///      "description": "Time of last state change.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "switch": {
    ///      "description": "Switch with the peer session.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchLocation"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct BgpPeerStatus {
        /// IP address of the peer.
        pub addr: ::std::net::IpAddr,
        /// Local autonomous system number.
        pub local_asn: u32,
        /// Remote autonomous system number.
        pub remote_asn: u32,
        /// State of the peer.
        pub state: BgpPeerState,
        /// Time of last state change.
        pub state_duration_millis: u64,
        /// Switch with the peer session.
        pub switch: SwitchLocation,
    }

    impl ::std::convert::From<&BgpPeerStatus> for BgpPeerStatus {
        fn from(value: &BgpPeerStatus) -> Self {
            value.clone()
        }
    }

    impl BgpPeerStatus {
        pub fn builder() -> builder::BgpPeerStatus {
            Default::default()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "start": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangedouble {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: f64 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: f64, start: f64 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: f64 },
    }

    impl ::std::convert::From<&Self> for BinRangedouble {
        fn from(value: &BinRangedouble) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "start": {
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangefloat {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: f32 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: f32, start: f32 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: f32 },
    }

    impl ::std::convert::From<&Self> for BinRangefloat {
        fn from(value: &BinRangefloat) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int16"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int16"
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int16"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int16"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeint16 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: i16 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: i16, start: i16 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: i16 },
    }

    impl ::std::convert::From<&Self> for BinRangeint16 {
        fn from(value: &BinRangeint16) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeint32 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: i32 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: i32, start: i32 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: i32 },
    }

    impl ::std::convert::From<&Self> for BinRangeint32 {
        fn from(value: &BinRangeint32) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeint64 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: i64 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: i64, start: i64 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: i64 },
    }

    impl ::std::convert::From<&Self> for BinRangeint64 {
        fn from(value: &BinRangeint64) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int8"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "int8"
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int8"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "int8"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeint8 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: i8 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: i8, start: i8 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: i8 },
    }

    impl ::std::convert::From<&Self> for BinRangeint8 {
        fn from(value: &BinRangeint8) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeuint16 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: u16 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: u16, start: u16 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: u16 },
    }

    impl ::std::convert::From<&Self> for BinRangeuint16 {
        fn from(value: &BinRangeuint16) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeuint32 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: u32 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: u32, start: u32 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: u32 },
    }

    impl ::std::convert::From<&Self> for BinRangeuint32 {
        fn from(value: &BinRangeuint32) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeuint64 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: u64 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: u64, start: u64 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: u64 },
    }

    impl ::std::convert::From<&Self> for BinRangeuint64 {
        fn from(value: &BinRangeuint64) -> Self {
            value.clone()
        }
    }

    /// A type storing a range over `T`.
    ///
    /// This type supports ranges similar to the `RangeTo`, `Range` and
    /// `RangeFrom` types in the standard library. Those cover `(..end)`,
    /// `(start..end)`, and `(start..)` respectively.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A type storing a range over `T`.\n\nThis type supports
    /// ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the
    /// standard library. Those cover `(..end)`, `(start..end)`, and `(start..)`
    /// respectively.",
    ///  "oneOf": [
    ///    {
    ///      "description": "A range unbounded below and exclusively above,
    /// `..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint8",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_to"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and exclusively
    /// above, `start..end`.",
    ///      "type": "object",
    ///      "required": [
    ///        "end",
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "end": {
    ///          "type": "integer",
    ///          "format": "uint8",
    ///          "minimum": 0.0
    ///        },
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint8",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A range bounded inclusively below and unbounded
    /// above, `start..`.",
    ///      "type": "object",
    ///      "required": [
    ///        "start",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "start": {
    ///          "type": "integer",
    ///          "format": "uint8",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "range_from"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum BinRangeuint8 {
        /// A range unbounded below and exclusively above, `..end`.
        #[serde(rename = "range_to")]
        RangeTo { end: u8 },
        /// A range bounded inclusively below and exclusively above,
        /// `start..end`.
        #[serde(rename = "range")]
        Range { end: u8, start: u8 },
        /// A range bounded inclusively below and unbounded above, `start..`.
        #[serde(rename = "range_from")]
        RangeFrom { start: u8 },
    }

    impl ::std::convert::From<&Self> for BinRangeuint8 {
        fn from(value: &BinRangeuint8) -> Self {
            value.clone()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangedouble"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Bindouble {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangedouble,
    }

    impl ::std::convert::From<&Bindouble> for Bindouble {
        fn from(value: &Bindouble) -> Self {
            value.clone()
        }
    }

    impl Bindouble {
        pub fn builder() -> builder::Bindouble {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangefloat"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binfloat {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangefloat,
    }

    impl ::std::convert::From<&Binfloat> for Binfloat {
        fn from(value: &Binfloat) -> Self {
            value.clone()
        }
    }

    impl Binfloat {
        pub fn builder() -> builder::Binfloat {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeint16"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binint16 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeint16,
    }

    impl ::std::convert::From<&Binint16> for Binint16 {
        fn from(value: &Binint16) -> Self {
            value.clone()
        }
    }

    impl Binint16 {
        pub fn builder() -> builder::Binint16 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeint32"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binint32 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeint32,
    }

    impl ::std::convert::From<&Binint32> for Binint32 {
        fn from(value: &Binint32) -> Self {
            value.clone()
        }
    }

    impl Binint32 {
        pub fn builder() -> builder::Binint32 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeint64"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binint64 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeint64,
    }

    impl ::std::convert::From<&Binint64> for Binint64 {
        fn from(value: &Binint64) -> Self {
            value.clone()
        }
    }

    impl Binint64 {
        pub fn builder() -> builder::Binint64 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeint8"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binint8 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeint8,
    }

    impl ::std::convert::From<&Binint8> for Binint8 {
        fn from(value: &Binint8) -> Self {
            value.clone()
        }
    }

    impl Binint8 {
        pub fn builder() -> builder::Binint8 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeuint16"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binuint16 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeuint16,
    }

    impl ::std::convert::From<&Binuint16> for Binuint16 {
        fn from(value: &Binuint16) -> Self {
            value.clone()
        }
    }

    impl Binuint16 {
        pub fn builder() -> builder::Binuint16 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeuint32"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binuint32 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeuint32,
    }

    impl ::std::convert::From<&Binuint32> for Binuint32 {
        fn from(value: &Binuint32) -> Self {
            value.clone()
        }
    }

    impl Binuint32 {
        pub fn builder() -> builder::Binuint32 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeuint64"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binuint64 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeuint64,
    }

    impl ::std::convert::From<&Binuint64> for Binuint64 {
        fn from(value: &Binuint64) -> Self {
            value.clone()
        }
    }

    impl Binuint64 {
        pub fn builder() -> builder::Binuint64 {
            Default::default()
        }
    }

    /// Type storing bin edges and a count of samples within it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Type storing bin edges and a count of samples within
    /// it.",
    ///  "type": "object",
    ///  "required": [
    ///    "count",
    ///    "range"
    ///  ],
    ///  "properties": {
    ///    "count": {
    ///      "description": "The total count of samples in this bin.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "range": {
    ///      "description": "The range of the support covered by this bin.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/BinRangeuint8"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Binuint8 {
        /// The total count of samples in this bin.
        pub count: u64,
        /// The range of the support covered by this bin.
        pub range: BinRangeuint8,
    }

    impl ::std::convert::From<&Binuint8> for Binuint8 {
        fn from(value: &Binuint8) -> Self {
            value.clone()
        }
    }

    impl Binuint8 {
        pub fn builder() -> builder::Binuint8 {
            Default::default()
        }
    }

    /// `BlockSize`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "disk block size in bytes",
    ///  "type": "integer",
    ///  "enum": [
    ///    512,
    ///    2048,
    ///    4096
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(:: serde :: Serialize, Clone, Debug, schemars :: JsonSchema)]
    #[serde(transparent)]
    pub struct BlockSize(i64);
    impl ::std::ops::Deref for BlockSize {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl ::std::convert::From<BlockSize> for i64 {
        fn from(value: BlockSize) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&BlockSize> for BlockSize {
        fn from(value: &BlockSize) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::TryFrom<i64> for BlockSize {
        type Error = self::error::ConversionError;
        fn try_from(value: i64) -> ::std::result::Result<Self, self::error::ConversionError> {
            if ![512_i64, 2048_i64, 4096_i64].contains(&value) {
                Err("invalid value".into())
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> ::serde::Deserialize<'de> for BlockSize {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            Self::try_from(<i64>::deserialize(deserializer)?)
                .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
        }
    }

    /// Byte count to express memory or storage capacity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Byte count to express memory or storage capacity.",
    ///  "type": "integer",
    ///  "format": "uint64",
    ///  "minimum": 0.0
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct ByteCount(pub u64);
    impl ::std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }

    impl ::std::convert::From<ByteCount> for u64 {
        fn from(value: ByteCount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&ByteCount> for ByteCount {
        fn from(value: &ByteCount) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<u64> for ByteCount {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for ByteCount {
        type Err = <u64 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for ByteCount {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for ByteCount {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for ByteCount {
        type Error = <u64 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for ByteCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// View of a Certificate
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Certificate",
    ///  "type": "object",
    ///  "required": [
    ///    "cert",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "service",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "cert": {
    ///      "description": "PEM-formatted string containing public certificate
    /// chain",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "service": {
    ///      "description": "The service using this certificate",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ServiceUsingCertificate"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Certificate {
        /// PEM-formatted string containing public certificate chain
        pub cert: ::std::string::String,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// The service using this certificate
        pub service: ServiceUsingCertificate,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Certificate> for Certificate {
        fn from(value: &Certificate) -> Self {
            value.clone()
        }
    }

    impl Certificate {
        pub fn builder() -> builder::Certificate {
            Default::default()
        }
    }

    /// Create-time parameters for a `Certificate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `Certificate`",
    ///  "type": "object",
    ///  "required": [
    ///    "cert",
    ///    "description",
    ///    "key",
    ///    "name",
    ///    "service"
    ///  ],
    ///  "properties": {
    ///    "cert": {
    ///      "description": "PEM-formatted string containing public certificate
    /// chain",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "key": {
    ///      "description": "PEM-formatted string containing private key",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "service": {
    ///      "description": "The service using this certificate",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ServiceUsingCertificate"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct CertificateCreate {
        /// PEM-formatted string containing public certificate chain
        pub cert: ::std::string::String,
        pub description: ::std::string::String,
        /// PEM-formatted string containing private key
        pub key: ::std::string::String,
        pub name: Name,
        /// The service using this certificate
        pub service: ServiceUsingCertificate,
    }

    impl ::std::convert::From<&CertificateCreate> for CertificateCreate {
        fn from(value: &CertificateCreate) -> Self {
            value.clone()
        }
    }

    impl CertificateCreate {
        pub fn builder() -> builder::CertificateCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Certificate"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct CertificateResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Certificate>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&CertificateResultsPage> for CertificateResultsPage {
        fn from(value: &CertificateResultsPage) -> Self {
            value.clone()
        }
    }

    impl CertificateResultsPage {
        pub fn builder() -> builder::CertificateResultsPage {
            Default::default()
        }
    }

    /// A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Cumulativedouble {
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub value: f64,
    }

    impl ::std::convert::From<&Cumulativedouble> for Cumulativedouble {
        fn from(value: &Cumulativedouble) -> Self {
            value.clone()
        }
    }

    impl Cumulativedouble {
        pub fn builder() -> builder::Cumulativedouble {
            Default::default()
        }
    }

    /// A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "number",
    ///      "format": "float"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Cumulativefloat {
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub value: f32,
    }

    impl ::std::convert::From<&Cumulativefloat> for Cumulativefloat {
        fn from(value: &Cumulativefloat) -> Self {
            value.clone()
        }
    }

    impl Cumulativefloat {
        pub fn builder() -> builder::Cumulativefloat {
            Default::default()
        }
    }

    /// A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Cumulativeint64 {
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub value: i64,
    }

    impl ::std::convert::From<&Cumulativeint64> for Cumulativeint64 {
        fn from(value: &Cumulativeint64) -> Self {
            value.clone()
        }
    }

    impl Cumulativeint64 {
        pub fn builder() -> builder::Cumulativeint64 {
            Default::default()
        }
    }

    /// A cumulative or counter data type.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A cumulative or counter data type.",
    ///  "type": "object",
    ///  "required": [
    ///    "start_time",
    ///    "value"
    ///  ],
    ///  "properties": {
    ///    "start_time": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "value": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Cumulativeuint64 {
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub value: u64,
    }

    impl ::std::convert::From<&Cumulativeuint64> for Cumulativeuint64 {
        fn from(value: &Cumulativeuint64) -> Self {
            value.clone()
        }
    }

    impl Cumulativeuint64 {
        pub fn builder() -> builder::Cumulativeuint64 {
            Default::default()
        }
    }

    /// Info about the current user
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Info about the current user",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id",
    ///    "silo_name"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the user",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this user belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_name": {
    ///      "description": "Name of the silo to which this user belongs.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct CurrentUser {
        /// Human-readable name that can identify the user
        pub display_name: ::std::string::String,
        pub id: ::uuid::Uuid,
        /// Uuid of the silo to which this user belongs
        pub silo_id: ::uuid::Uuid,
        /// Name of the silo to which this user belongs.
        pub silo_name: Name,
    }

    impl ::std::convert::From<&CurrentUser> for CurrentUser {
        fn from(value: &CurrentUser) -> Self {
            value.clone()
        }
    }

    impl CurrentUser {
        pub fn builder() -> builder::CurrentUser {
            Default::default()
        }
    }

    /// A `Datum` is a single sampled data point from a metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A `Datum` is a single sampled data point from a
    /// metric.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "boolean"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bool"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "int8"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i8"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "uint8",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u8"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "int16"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i16"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u16"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "int32"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "number",
    ///          "format": "float"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "f32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "number",
    ///          "format": "double"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "string"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "integer",
    ///            "format": "uint8",
    ///            "minimum": 0.0
    ///          }
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bytes"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativeint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativeuint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_u64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativefloat"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_f32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Cumulativedouble"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "cumulative_f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramint8"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_i8"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramuint8"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_u8"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramint16"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_i16"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramuint16"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_u16"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramint32"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_i32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramuint32"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_u32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_i64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramuint64"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_u64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramfloat"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_f32"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/Histogramdouble"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "histogram_f64"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "datum",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "datum": {
    ///          "$ref": "#/components/schemas/MissingDatum"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "missing"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "datum")]
    pub enum Datum {
        #[serde(rename = "bool")]
        Bool(bool),
        #[serde(rename = "i8")]
        I8(i8),
        #[serde(rename = "u8")]
        U8(u8),
        #[serde(rename = "i16")]
        I16(i16),
        #[serde(rename = "u16")]
        U16(u16),
        #[serde(rename = "i32")]
        I32(i32),
        #[serde(rename = "u32")]
        U32(u32),
        #[serde(rename = "i64")]
        I64(i64),
        #[serde(rename = "u64")]
        U64(u64),
        #[serde(rename = "f32")]
        F32(f32),
        #[serde(rename = "f64")]
        F64(f64),
        #[serde(rename = "string")]
        String(::std::string::String),
        #[serde(rename = "bytes")]
        Bytes(::std::vec::Vec<u8>),
        #[serde(rename = "cumulative_i64")]
        CumulativeI64(Cumulativeint64),
        #[serde(rename = "cumulative_u64")]
        CumulativeU64(Cumulativeuint64),
        #[serde(rename = "cumulative_f32")]
        CumulativeF32(Cumulativefloat),
        #[serde(rename = "cumulative_f64")]
        CumulativeF64(Cumulativedouble),
        #[serde(rename = "histogram_i8")]
        HistogramI8(Histogramint8),
        #[serde(rename = "histogram_u8")]
        HistogramU8(Histogramuint8),
        #[serde(rename = "histogram_i16")]
        HistogramI16(Histogramint16),
        #[serde(rename = "histogram_u16")]
        HistogramU16(Histogramuint16),
        #[serde(rename = "histogram_i32")]
        HistogramI32(Histogramint32),
        #[serde(rename = "histogram_u32")]
        HistogramU32(Histogramuint32),
        #[serde(rename = "histogram_i64")]
        HistogramI64(Histogramint64),
        #[serde(rename = "histogram_u64")]
        HistogramU64(Histogramuint64),
        #[serde(rename = "histogram_f32")]
        HistogramF32(Histogramfloat),
        #[serde(rename = "histogram_f64")]
        HistogramF64(Histogramdouble),
        #[serde(rename = "missing")]
        Missing(MissingDatum),
    }

    impl ::std::convert::From<&Self> for Datum {
        fn from(value: &Datum) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<bool> for Datum {
        fn from(value: bool) -> Self {
            Self::Bool(value)
        }
    }

    impl ::std::convert::From<i8> for Datum {
        fn from(value: i8) -> Self {
            Self::I8(value)
        }
    }

    impl ::std::convert::From<u8> for Datum {
        fn from(value: u8) -> Self {
            Self::U8(value)
        }
    }

    impl ::std::convert::From<i16> for Datum {
        fn from(value: i16) -> Self {
            Self::I16(value)
        }
    }

    impl ::std::convert::From<u16> for Datum {
        fn from(value: u16) -> Self {
            Self::U16(value)
        }
    }

    impl ::std::convert::From<i32> for Datum {
        fn from(value: i32) -> Self {
            Self::I32(value)
        }
    }

    impl ::std::convert::From<u32> for Datum {
        fn from(value: u32) -> Self {
            Self::U32(value)
        }
    }

    impl ::std::convert::From<i64> for Datum {
        fn from(value: i64) -> Self {
            Self::I64(value)
        }
    }

    impl ::std::convert::From<u64> for Datum {
        fn from(value: u64) -> Self {
            Self::U64(value)
        }
    }

    impl ::std::convert::From<f32> for Datum {
        fn from(value: f32) -> Self {
            Self::F32(value)
        }
    }

    impl ::std::convert::From<f64> for Datum {
        fn from(value: f64) -> Self {
            Self::F64(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<u8>> for Datum {
        fn from(value: ::std::vec::Vec<u8>) -> Self {
            Self::Bytes(value)
        }
    }

    impl ::std::convert::From<Cumulativeint64> for Datum {
        fn from(value: Cumulativeint64) -> Self {
            Self::CumulativeI64(value)
        }
    }

    impl ::std::convert::From<Cumulativeuint64> for Datum {
        fn from(value: Cumulativeuint64) -> Self {
            Self::CumulativeU64(value)
        }
    }

    impl ::std::convert::From<Cumulativefloat> for Datum {
        fn from(value: Cumulativefloat) -> Self {
            Self::CumulativeF32(value)
        }
    }

    impl ::std::convert::From<Cumulativedouble> for Datum {
        fn from(value: Cumulativedouble) -> Self {
            Self::CumulativeF64(value)
        }
    }

    impl ::std::convert::From<Histogramint8> for Datum {
        fn from(value: Histogramint8) -> Self {
            Self::HistogramI8(value)
        }
    }

    impl ::std::convert::From<Histogramuint8> for Datum {
        fn from(value: Histogramuint8) -> Self {
            Self::HistogramU8(value)
        }
    }

    impl ::std::convert::From<Histogramint16> for Datum {
        fn from(value: Histogramint16) -> Self {
            Self::HistogramI16(value)
        }
    }

    impl ::std::convert::From<Histogramuint16> for Datum {
        fn from(value: Histogramuint16) -> Self {
            Self::HistogramU16(value)
        }
    }

    impl ::std::convert::From<Histogramint32> for Datum {
        fn from(value: Histogramint32) -> Self {
            Self::HistogramI32(value)
        }
    }

    impl ::std::convert::From<Histogramuint32> for Datum {
        fn from(value: Histogramuint32) -> Self {
            Self::HistogramU32(value)
        }
    }

    impl ::std::convert::From<Histogramint64> for Datum {
        fn from(value: Histogramint64) -> Self {
            Self::HistogramI64(value)
        }
    }

    impl ::std::convert::From<Histogramuint64> for Datum {
        fn from(value: Histogramuint64) -> Self {
            Self::HistogramU64(value)
        }
    }

    impl ::std::convert::From<Histogramfloat> for Datum {
        fn from(value: Histogramfloat) -> Self {
            Self::HistogramF32(value)
        }
    }

    impl ::std::convert::From<Histogramdouble> for Datum {
        fn from(value: Histogramdouble) -> Self {
            Self::HistogramF64(value)
        }
    }

    impl ::std::convert::From<MissingDatum> for Datum {
        fn from(value: MissingDatum) -> Self {
            Self::Missing(value)
        }
    }

    /// The type of an individual datum of a metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The type of an individual datum of a metric.",
    ///  "type": "string",
    ///  "enum": [
    ///    "bool",
    ///    "i8",
    ///    "u8",
    ///    "i16",
    ///    "u16",
    ///    "i32",
    ///    "u32",
    ///    "i64",
    ///    "u64",
    ///    "f32",
    ///    "f64",
    ///    "string",
    ///    "bytes",
    ///    "cumulative_i64",
    ///    "cumulative_u64",
    ///    "cumulative_f32",
    ///    "cumulative_f64",
    ///    "histogram_i8",
    ///    "histogram_u8",
    ///    "histogram_i16",
    ///    "histogram_u16",
    ///    "histogram_i32",
    ///    "histogram_u32",
    ///    "histogram_i64",
    ///    "histogram_u64",
    ///    "histogram_f32",
    ///    "histogram_f64"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum DatumType {
        #[serde(rename = "bool")]
        Bool,
        #[serde(rename = "i8")]
        I8,
        #[serde(rename = "u8")]
        U8,
        #[serde(rename = "i16")]
        I16,
        #[serde(rename = "u16")]
        U16,
        #[serde(rename = "i32")]
        I32,
        #[serde(rename = "u32")]
        U32,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "u64")]
        U64,
        #[serde(rename = "f32")]
        F32,
        #[serde(rename = "f64")]
        F64,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "bytes")]
        Bytes,
        #[serde(rename = "cumulative_i64")]
        CumulativeI64,
        #[serde(rename = "cumulative_u64")]
        CumulativeU64,
        #[serde(rename = "cumulative_f32")]
        CumulativeF32,
        #[serde(rename = "cumulative_f64")]
        CumulativeF64,
        #[serde(rename = "histogram_i8")]
        HistogramI8,
        #[serde(rename = "histogram_u8")]
        HistogramU8,
        #[serde(rename = "histogram_i16")]
        HistogramI16,
        #[serde(rename = "histogram_u16")]
        HistogramU16,
        #[serde(rename = "histogram_i32")]
        HistogramI32,
        #[serde(rename = "histogram_u32")]
        HistogramU32,
        #[serde(rename = "histogram_i64")]
        HistogramI64,
        #[serde(rename = "histogram_u64")]
        HistogramU64,
        #[serde(rename = "histogram_f32")]
        HistogramF32,
        #[serde(rename = "histogram_f64")]
        HistogramF64,
    }

    impl ::std::convert::From<&Self> for DatumType {
        fn from(value: &DatumType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DatumType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Bool => write!(f, "bool"),
                Self::I8 => write!(f, "i8"),
                Self::U8 => write!(f, "u8"),
                Self::I16 => write!(f, "i16"),
                Self::U16 => write!(f, "u16"),
                Self::I32 => write!(f, "i32"),
                Self::U32 => write!(f, "u32"),
                Self::I64 => write!(f, "i64"),
                Self::U64 => write!(f, "u64"),
                Self::F32 => write!(f, "f32"),
                Self::F64 => write!(f, "f64"),
                Self::String => write!(f, "string"),
                Self::Bytes => write!(f, "bytes"),
                Self::CumulativeI64 => write!(f, "cumulative_i64"),
                Self::CumulativeU64 => write!(f, "cumulative_u64"),
                Self::CumulativeF32 => write!(f, "cumulative_f32"),
                Self::CumulativeF64 => write!(f, "cumulative_f64"),
                Self::HistogramI8 => write!(f, "histogram_i8"),
                Self::HistogramU8 => write!(f, "histogram_u8"),
                Self::HistogramI16 => write!(f, "histogram_i16"),
                Self::HistogramU16 => write!(f, "histogram_u16"),
                Self::HistogramI32 => write!(f, "histogram_i32"),
                Self::HistogramU32 => write!(f, "histogram_u32"),
                Self::HistogramI64 => write!(f, "histogram_i64"),
                Self::HistogramU64 => write!(f, "histogram_u64"),
                Self::HistogramF32 => write!(f, "histogram_f32"),
                Self::HistogramF64 => write!(f, "histogram_f64"),
            }
        }
    }

    impl ::std::str::FromStr for DatumType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "bool" => Ok(Self::Bool),
                "i8" => Ok(Self::I8),
                "u8" => Ok(Self::U8),
                "i16" => Ok(Self::I16),
                "u16" => Ok(Self::U16),
                "i32" => Ok(Self::I32),
                "u32" => Ok(Self::U32),
                "i64" => Ok(Self::I64),
                "u64" => Ok(Self::U64),
                "f32" => Ok(Self::F32),
                "f64" => Ok(Self::F64),
                "string" => Ok(Self::String),
                "bytes" => Ok(Self::Bytes),
                "cumulative_i64" => Ok(Self::CumulativeI64),
                "cumulative_u64" => Ok(Self::CumulativeU64),
                "cumulative_f32" => Ok(Self::CumulativeF32),
                "cumulative_f64" => Ok(Self::CumulativeF64),
                "histogram_i8" => Ok(Self::HistogramI8),
                "histogram_u8" => Ok(Self::HistogramU8),
                "histogram_i16" => Ok(Self::HistogramI16),
                "histogram_u16" => Ok(Self::HistogramU16),
                "histogram_i32" => Ok(Self::HistogramI32),
                "histogram_u32" => Ok(Self::HistogramU32),
                "histogram_i64" => Ok(Self::HistogramI64),
                "histogram_u64" => Ok(Self::HistogramU64),
                "histogram_f32" => Ok(Self::HistogramF32),
                "histogram_f64" => Ok(Self::HistogramF64),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DatumType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `DerEncodedKeyPair`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "private_key",
    ///    "public_cert"
    ///  ],
    ///  "properties": {
    ///    "private_key": {
    ///      "description": "request signing RSA private key in PKCS#1 format
    /// (base64 encoded der file)",
    ///      "type": "string"
    ///    },
    ///    "public_cert": {
    ///      "description": "request signing public certificate (base64 encoded
    /// der file)",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DerEncodedKeyPair {
        /// request signing RSA private key in PKCS#1 format (base64 encoded der
        /// file)
        pub private_key: ::std::string::String,
        /// request signing public certificate (base64 encoded der file)
        pub public_cert: ::std::string::String,
    }

    impl ::std::convert::From<&DerEncodedKeyPair> for DerEncodedKeyPair {
        fn from(value: &DerEncodedKeyPair) -> Self {
            value.clone()
        }
    }

    impl DerEncodedKeyPair {
        pub fn builder() -> builder::DerEncodedKeyPair {
            Default::default()
        }
    }

    /// `DeviceAccessTokenRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "client_id",
    ///    "device_code",
    ///    "grant_type"
    ///  ],
    ///  "properties": {
    ///    "client_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "device_code": {
    ///      "type": "string"
    ///    },
    ///    "grant_type": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DeviceAccessTokenRequest {
        pub client_id: ::uuid::Uuid,
        pub device_code: ::std::string::String,
        pub grant_type: ::std::string::String,
    }

    impl ::std::convert::From<&DeviceAccessTokenRequest> for DeviceAccessTokenRequest {
        fn from(value: &DeviceAccessTokenRequest) -> Self {
            value.clone()
        }
    }

    impl DeviceAccessTokenRequest {
        pub fn builder() -> builder::DeviceAccessTokenRequest {
            Default::default()
        }
    }

    /// `DeviceAuthRequest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "client_id"
    ///  ],
    ///  "properties": {
    ///    "client_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DeviceAuthRequest {
        pub client_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&DeviceAuthRequest> for DeviceAuthRequest {
        fn from(value: &DeviceAuthRequest) -> Self {
            value.clone()
        }
    }

    impl DeviceAuthRequest {
        pub fn builder() -> builder::DeviceAuthRequest {
            Default::default()
        }
    }

    /// `DeviceAuthVerify`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "user_code"
    ///  ],
    ///  "properties": {
    ///    "user_code": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DeviceAuthVerify {
        pub user_code: ::std::string::String,
    }

    impl ::std::convert::From<&DeviceAuthVerify> for DeviceAuthVerify {
        fn from(value: &DeviceAuthVerify) -> Self {
            value.clone()
        }
    }

    impl DeviceAuthVerify {
        pub fn builder() -> builder::DeviceAuthVerify {
            Default::default()
        }
    }

    /// `Digest`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "sha256"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum Digest {
        #[serde(rename = "sha256")]
        Sha256(::std::string::String),
    }

    impl ::std::convert::From<&Self> for Digest {
        fn from(value: &Digest) -> Self {
            value.clone()
        }
    }

    /// View of a Disk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Disk",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "device_path",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "device_path": {
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "image_id": {
    ///      "description": "ID of image from which disk was created, if any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "snapshot_id": {
    ///      "description": "ID of snapshot from which disk was created, if
    /// any",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/DiskState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Disk {
        pub block_size: ByteCount,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub device_path: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// ID of image from which disk was created, if any
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub image_id: ::std::option::Option<::uuid::Uuid>,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: ::uuid::Uuid,
        pub size: ByteCount,
        /// ID of snapshot from which disk was created, if any
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub snapshot_id: ::std::option::Option<::uuid::Uuid>,
        pub state: DiskState,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Disk> for Disk {
        fn from(value: &Disk) -> Self {
            value.clone()
        }
    }

    impl Disk {
        pub fn builder() -> builder::Disk {
            Default::default()
        }
    }

    /// Create-time parameters for a `Disk`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `Disk`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk_source",
    ///    "name",
    ///    "size"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disk_source": {
    ///      "description": "The initial source for this disk",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/DiskSource"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "size": {
    ///      "description": "The total size of the Disk (in bytes)",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DiskCreate {
        pub description: ::std::string::String,
        /// The initial source for this disk
        pub disk_source: DiskSource,
        pub name: Name,
        /// The total size of the Disk (in bytes)
        pub size: ByteCount,
    }

    impl ::std::convert::From<&DiskCreate> for DiskCreate {
        fn from(value: &DiskCreate) -> Self {
            value.clone()
        }
    }

    impl DiskCreate {
        pub fn builder() -> builder::DiskCreate {
            Default::default()
        }
    }

    /// `DiskMetricName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "activated",
    ///    "flush",
    ///    "read",
    ///    "read_bytes",
    ///    "write",
    ///    "write_bytes"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum DiskMetricName {
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "flush")]
        Flush,
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "read_bytes")]
        ReadBytes,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "write_bytes")]
        WriteBytes,
    }

    impl ::std::convert::From<&Self> for DiskMetricName {
        fn from(value: &DiskMetricName) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for DiskMetricName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Activated => write!(f, "activated"),
                Self::Flush => write!(f, "flush"),
                Self::Read => write!(f, "read"),
                Self::ReadBytes => write!(f, "read_bytes"),
                Self::Write => write!(f, "write"),
                Self::WriteBytes => write!(f, "write_bytes"),
            }
        }
    }

    impl ::std::str::FromStr for DiskMetricName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "activated" => Ok(Self::Activated),
                "flush" => Ok(Self::Flush),
                "read" => Ok(Self::Read),
                "read_bytes" => Ok(Self::ReadBytes),
                "write" => Ok(Self::Write),
                "write_bytes" => Ok(Self::WriteBytes),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for DiskMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `DiskPath`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "disk"
    ///  ],
    ///  "properties": {
    ///    "disk": {
    ///      "description": "Name or ID of the disk",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DiskPath {
        /// Name or ID of the disk
        pub disk: NameOrId,
    }

    impl ::std::convert::From<&DiskPath> for DiskPath {
        fn from(value: &DiskPath) -> Self {
            value.clone()
        }
    }

    impl DiskPath {
        pub fn builder() -> builder::DiskPath {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Disk"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct DiskResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Disk>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&DiskResultsPage> for DiskResultsPage {
        fn from(value: &DiskResultsPage) -> Self {
            value.clone()
        }
    }

    impl DiskResultsPage {
        pub fn builder() -> builder::DiskResultsPage {
            Default::default()
        }
    }

    /// Different sources for a disk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Different sources for a disk",
    ///  "oneOf": [
    ///    {
    ///      "description": "Create a blank disk",
    ///      "type": "object",
    ///      "required": [
    ///        "block_size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "block_size": {
    ///          "description": "size of blocks for this Disk. valid values are:
    /// 512, 2048, or 4096",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/BlockSize"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "blank"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from a disk snapshot",
    ///      "type": "object",
    ///      "required": [
    ///        "snapshot_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "snapshot_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "snapshot"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a disk from an image",
    ///      "type": "object",
    ///      "required": [
    ///        "image_id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "image_id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "image"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Create a blank disk that will accept bulk writes or
    /// pull blocks from an external source.",
    ///      "type": "object",
    ///      "required": [
    ///        "block_size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "block_size": {
    ///          "$ref": "#/components/schemas/BlockSize"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "importing_blocks"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum DiskSource {
        /// Create a blank disk
        #[serde(rename = "blank")]
        Blank {
            /// size of blocks for this Disk. valid values are: 512, 2048, or
            /// 4096
            block_size: BlockSize,
        },
        /// Create a disk from a disk snapshot
        #[serde(rename = "snapshot")]
        Snapshot { snapshot_id: ::uuid::Uuid },
        /// Create a disk from an image
        #[serde(rename = "image")]
        Image { image_id: ::uuid::Uuid },
        /// Create a blank disk that will accept bulk writes or pull blocks from
        /// an external source.
        #[serde(rename = "importing_blocks")]
        ImportingBlocks { block_size: BlockSize },
    }

    impl ::std::convert::From<&Self> for DiskSource {
        fn from(value: &DiskSource) -> Self {
            value.clone()
        }
    }

    /// State of a Disk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "State of a Disk",
    ///  "oneOf": [
    ///    {
    ///      "description": "Disk is being initialized",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "creating"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is ready but detached from any Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "detached"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is ready to receive blocks from an external
    /// source",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "import_ready"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is importing blocks from a URL",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "importing_from_url"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is importing blocks from bulk writes",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "importing_from_bulk_writes"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being finalized to state Detached",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "finalizing"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is undergoing maintenance",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "maintenance"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being attached to the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attaching"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is attached to the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attached"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is being detached from the given Instance",
    ///      "type": "object",
    ///      "required": [
    ///        "instance",
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "instance": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "detaching"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk has been destroyed",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "destroyed"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Disk is unavailable",
    ///      "type": "object",
    ///      "required": [
    ///        "state"
    ///      ],
    ///      "properties": {
    ///        "state": {
    ///          "type": "string",
    ///          "enum": [
    ///            "faulted"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        #[serde(rename = "import_ready")]
        ImportReady,
        #[serde(rename = "importing_from_url")]
        ImportingFromUrl,
        #[serde(rename = "importing_from_bulk_writes")]
        ImportingFromBulkWrites,
        #[serde(rename = "finalizing")]
        Finalizing,
        #[serde(rename = "maintenance")]
        Maintenance,
        /// Disk is being attached to the given Instance
        #[serde(rename = "attaching")]
        Attaching(::uuid::Uuid),
        /// Disk is attached to the given Instance
        #[serde(rename = "attached")]
        Attached(::uuid::Uuid),
        /// Disk is being detached from the given Instance
        #[serde(rename = "detaching")]
        Detaching(::uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    impl ::std::convert::From<&Self> for DiskState {
        fn from(value: &DiskState) -> Self {
            value.clone()
        }
    }

    /// A distribution is a sequence of bins and counts in those bins, and some
    /// statistical information tracked to compute the mean, standard deviation,
    /// and quantile estimates.
    ///
    /// Min, max, and the p-* quantiles are treated as optional due to the
    /// possibility of distribution operations, like subtraction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A distribution is a sequence of bins and counts in
    /// those bins, and some statistical information tracked to compute the
    /// mean, standard deviation, and quantile estimates.\n\nMin, max, and the
    /// p-* quantiles are treated as optional due to the possibility of
    /// distribution operations, like subtraction.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "counts",
    ///    "squared_mean",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "number",
    ///        "format": "double"
    ///      }
    ///    },
    ///    "counts": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "max": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ],
    ///      "format": "double"
    ///    },
    ///    "min": {
    ///      "type": [
    ///        "number",
    ///        "null"
    ///      ],
    ///      "format": "double"
    ///    },
    ///    "p50": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Quantile"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Quantile"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Quantile"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "sum_of_samples": {
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Distributiondouble {
        pub bins: ::std::vec::Vec<f64>,
        pub counts: ::std::vec::Vec<u64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min: ::std::option::Option<f64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub p50: ::std::option::Option<Quantile>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub p90: ::std::option::Option<Quantile>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub p99: ::std::option::Option<Quantile>,
        pub squared_mean: f64,
        pub sum_of_samples: f64,
    }

    impl ::std::convert::From<&Distributiondouble> for Distributiondouble {
        fn from(value: &Distributiondouble) -> Self {
            value.clone()
        }
    }

    impl Distributiondouble {
        pub fn builder() -> builder::Distributiondouble {
            Default::default()
        }
    }

    /// A distribution is a sequence of bins and counts in those bins, and some
    /// statistical information tracked to compute the mean, standard deviation,
    /// and quantile estimates.
    ///
    /// Min, max, and the p-* quantiles are treated as optional due to the
    /// possibility of distribution operations, like subtraction.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A distribution is a sequence of bins and counts in
    /// those bins, and some statistical information tracked to compute the
    /// mean, standard deviation, and quantile estimates.\n\nMin, max, and the
    /// p-* quantiles are treated as optional due to the possibility of
    /// distribution operations, like subtraction.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "counts",
    ///    "squared_mean",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "int64"
    ///      }
    ///    },
    ///    "counts": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "max": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64"
    ///    },
    ///    "min": {
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64"
    ///    },
    ///    "p50": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Quantile"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Quantile"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Quantile"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "sum_of_samples": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Distributionint64 {
        pub bins: ::std::vec::Vec<i64>,
        pub counts: ::std::vec::Vec<u64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub max: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub min: ::std::option::Option<i64>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub p50: ::std::option::Option<Quantile>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub p90: ::std::option::Option<Quantile>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub p99: ::std::option::Option<Quantile>,
        pub squared_mean: f64,
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Distributionint64> for Distributionint64 {
        fn from(value: &Distributionint64) -> Self {
            value.clone()
        }
    }

    impl Distributionint64 {
        pub fn builder() -> builder::Distributionint64 {
            Default::default()
        }
    }

    /// Parameters for creating an ephemeral IP address for an instance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating an ephemeral IP address for an
    /// instance.",
    ///  "type": "object",
    ///  "properties": {
    ///    "pool": {
    ///      "description": "Name or ID of the IP pool used to allocate an
    /// address. If unspecified, the default IP pool will be used.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/NameOrId"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct EphemeralIpCreate {
        /// Name or ID of the IP pool used to allocate an address. If
        /// unspecified, the default IP pool will be used.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pool: ::std::option::Option<NameOrId>,
    }

    impl ::std::convert::From<&EphemeralIpCreate> for EphemeralIpCreate {
        fn from(value: &EphemeralIpCreate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for EphemeralIpCreate {
        fn default() -> Self {
            Self {
                pool: Default::default(),
            }
        }
    }

    impl EphemeralIpCreate {
        pub fn builder() -> builder::EphemeralIpCreate {
            Default::default()
        }
    }

    /// Error information from a response.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Error information from a response.",
    ///  "type": "object",
    ///  "required": [
    ///    "message",
    ///    "request_id"
    ///  ],
    ///  "properties": {
    ///    "error_code": {
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "type": "string"
    ///    },
    ///    "request_id": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Error {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub error_code: ::std::option::Option<::std::string::String>,
        pub message: ::std::string::String,
        pub request_id: ::std::string::String,
    }

    impl ::std::convert::From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }

    impl Error {
        pub fn builder() -> builder::Error {
            Default::default()
        }
    }

    /// A webhook event class.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A webhook event class.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "A description of what this event class
    /// represents.",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "The name of the event class.",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct EventClass {
        /// A description of what this event class represents.
        pub description: ::std::string::String,
        /// The name of the event class.
        pub name: ::std::string::String,
    }

    impl ::std::convert::From<&EventClass> for EventClass {
        fn from(value: &EventClass) -> Self {
            value.clone()
        }
    }

    impl EventClass {
        pub fn builder() -> builder::EventClass {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/EventClass"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct EventClassResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<EventClass>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&EventClassResultsPage> for EventClassResultsPage {
        fn from(value: &EventClassResultsPage) -> Self {
            value.clone()
        }
    }

    impl EventClassResultsPage {
        pub fn builder() -> builder::EventClassResultsPage {
            Default::default()
        }
    }

    /// `ExternalIp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "ip",
    ///        "kind"
    ///      ],
    ///      "properties": {
    ///        "ip": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ephemeral"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A Floating IP is a well-known IP address which can
    /// be attached and detached from instances.",
    ///      "type": "object",
    ///      "required": [
    ///        "description",
    ///        "id",
    ///        "ip",
    ///        "ip_pool_id",
    ///        "kind",
    ///        "name",
    ///        "project_id",
    ///        "time_created",
    ///        "time_modified"
    ///      ],
    ///      "properties": {
    ///        "description": {
    ///          "description": "human-readable free-form text about a
    /// resource",
    ///          "type": "string"
    ///        },
    ///        "id": {
    ///          "description": "unique, immutable, system-controlled identifier
    /// for each resource",
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "instance_id": {
    ///          "description": "The ID of the instance that this Floating IP is
    /// attached to, if it is presently in use.",
    ///          "type": [
    ///            "string",
    ///            "null"
    ///          ],
    ///          "format": "uuid"
    ///        },
    ///        "ip": {
    ///          "description": "The IP address held by this resource.",
    ///          "type": "string",
    ///          "format": "ip"
    ///        },
    ///        "ip_pool_id": {
    ///          "description": "The ID of the IP pool this resource belongs
    /// to.",
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "floating"
    ///          ]
    ///        },
    ///        "name": {
    ///          "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        },
    ///        "project_id": {
    ///          "description": "The project this resource exists within.",
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "time_created": {
    ///          "description": "timestamp when this resource was created",
    ///          "type": "string",
    ///          "format": "date-time"
    ///        },
    ///        "time_modified": {
    ///          "description": "timestamp when this resource was last
    /// modified",
    ///          "type": "string",
    ///          "format": "date-time"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "kind")]
    pub enum ExternalIp {
        #[serde(rename = "ephemeral")]
        Ephemeral { ip: ::std::net::IpAddr },
        /// A Floating IP is a well-known IP address which can be attached and
        /// detached from instances.
        #[serde(rename = "floating")]
        Floating {
            /// human-readable free-form text about a resource
            description: ::std::string::String,
            /// unique, immutable, system-controlled identifier for each
            /// resource
            id: ::uuid::Uuid,
            /// The ID of the instance that this Floating IP is attached to, if
            /// it is presently in use.
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            instance_id: ::std::option::Option<::uuid::Uuid>,
            /// The IP address held by this resource.
            ip: ::std::net::IpAddr,
            /// The ID of the IP pool this resource belongs to.
            ip_pool_id: ::uuid::Uuid,
            /// unique, mutable, user-controlled identifier for each resource
            name: Name,
            /// The project this resource exists within.
            project_id: ::uuid::Uuid,
            /// timestamp when this resource was created
            time_created: ::chrono::DateTime<::chrono::offset::Utc>,
            /// timestamp when this resource was last modified
            time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        },
    }

    impl ::std::convert::From<&Self> for ExternalIp {
        fn from(value: &ExternalIp) -> Self {
            value.clone()
        }
    }

    /// Parameters for creating an external IP address for instances.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating an external IP address for
    /// instances.",
    ///  "oneOf": [
    ///    {
    ///      "description": "An IP address providing both inbound and outbound
    /// access. The address is automatically assigned from the provided IP pool
    /// or the default IP pool if not specified.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "pool": {
    ///          "oneOf": [
    ///            {
    ///              "type": "null"
    ///            },
    ///            {
    ///              "allOf": [
    ///                {
    ///                  "$ref": "#/components/schemas/NameOrId"
    ///                }
    ///              ]
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ephemeral"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "An IP address providing both inbound and outbound
    /// access. The address is an existing floating IP object assigned to the
    /// current project.\n\nThe floating IP must not be in use by another
    /// instance or service.",
    ///      "type": "object",
    ///      "required": [
    ///        "floating_ip",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "floating_ip": {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "floating"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum ExternalIpCreate {
        /// An IP address providing both inbound and outbound access. The
        /// address is automatically assigned from the provided IP pool or the
        /// default IP pool if not specified.
        #[serde(rename = "ephemeral")]
        Ephemeral {
            #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
            pool: ::std::option::Option<NameOrId>,
        },
        /// An IP address providing both inbound and outbound access. The
        /// address is an existing floating IP object assigned to the current
        /// project.
        ///
        /// The floating IP must not be in use by another instance or service.
        #[serde(rename = "floating")]
        Floating { floating_ip: NameOrId },
    }

    impl ::std::convert::From<&Self> for ExternalIpCreate {
        fn from(value: &ExternalIpCreate) -> Self {
            value.clone()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalIp"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ExternalIpResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<ExternalIp>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ExternalIpResultsPage> for ExternalIpResultsPage {
        fn from(value: &ExternalIpResultsPage) -> Self {
            value.clone()
        }
    }

    impl ExternalIpResultsPage {
        pub fn builder() -> builder::ExternalIpResultsPage {
            Default::default()
        }
    }

    /// Describes the scope of affinity for the purposes of co-location.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes the scope of affinity for the purposes of
    /// co-location.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Instances are considered co-located if they are on
    /// the same sled",
    ///      "type": "string",
    ///      "enum": [
    ///        "sled"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum FailureDomain {
        /// Instances are considered co-located if they are on the same sled
        #[serde(rename = "sled")]
        Sled,
    }

    impl ::std::convert::From<&Self> for FailureDomain {
        fn from(value: &FailureDomain) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FailureDomain {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Sled => write!(f, "sled"),
            }
        }
    }

    impl ::std::str::FromStr for FailureDomain {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "sled" => Ok(Self::Sled),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FailureDomain {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FailureDomain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FailureDomain {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The name and type information for a field of a timeseries schema.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The name and type information for a field of a
    /// timeseries schema.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "field_type",
    ///    "name",
    ///    "source"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "field_type": {
    ///      "$ref": "#/components/schemas/FieldType"
    ///    },
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "$ref": "#/components/schemas/FieldSource"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FieldSchema {
        pub description: ::std::string::String,
        pub field_type: FieldType,
        pub name: ::std::string::String,
        pub source: FieldSource,
    }

    impl ::std::convert::From<&FieldSchema> for FieldSchema {
        fn from(value: &FieldSchema) -> Self {
            value.clone()
        }
    }

    impl FieldSchema {
        pub fn builder() -> builder::FieldSchema {
            Default::default()
        }
    }

    /// The source from which a field is derived, the target or metric.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The source from which a field is derived, the target or
    /// metric.",
    ///  "type": "string",
    ///  "enum": [
    ///    "target",
    ///    "metric"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum FieldSource {
        #[serde(rename = "target")]
        Target,
        #[serde(rename = "metric")]
        Metric,
    }

    impl ::std::convert::From<&Self> for FieldSource {
        fn from(value: &FieldSource) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FieldSource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Target => write!(f, "target"),
                Self::Metric => write!(f, "metric"),
            }
        }
    }

    impl ::std::str::FromStr for FieldSource {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "target" => Ok(Self::Target),
                "metric" => Ok(Self::Metric),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FieldSource {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The `FieldType` identifies the data type of a target or metric field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The `FieldType` identifies the data type of a target or
    /// metric field.",
    ///  "type": "string",
    ///  "enum": [
    ///    "string",
    ///    "i8",
    ///    "u8",
    ///    "i16",
    ///    "u16",
    ///    "i32",
    ///    "u32",
    ///    "i64",
    ///    "u64",
    ///    "ip_addr",
    ///    "uuid",
    ///    "bool"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum FieldType {
        #[serde(rename = "string")]
        String,
        #[serde(rename = "i8")]
        I8,
        #[serde(rename = "u8")]
        U8,
        #[serde(rename = "i16")]
        I16,
        #[serde(rename = "u16")]
        U16,
        #[serde(rename = "i32")]
        I32,
        #[serde(rename = "u32")]
        U32,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "u64")]
        U64,
        #[serde(rename = "ip_addr")]
        IpAddr,
        #[serde(rename = "uuid")]
        Uuid,
        #[serde(rename = "bool")]
        Bool,
    }

    impl ::std::convert::From<&Self> for FieldType {
        fn from(value: &FieldType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FieldType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::String => write!(f, "string"),
                Self::I8 => write!(f, "i8"),
                Self::U8 => write!(f, "u8"),
                Self::I16 => write!(f, "i16"),
                Self::U16 => write!(f, "u16"),
                Self::I32 => write!(f, "i32"),
                Self::U32 => write!(f, "u32"),
                Self::I64 => write!(f, "i64"),
                Self::U64 => write!(f, "u64"),
                Self::IpAddr => write!(f, "ip_addr"),
                Self::Uuid => write!(f, "uuid"),
                Self::Bool => write!(f, "bool"),
            }
        }
    }

    impl ::std::str::FromStr for FieldType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "string" => Ok(Self::String),
                "i8" => Ok(Self::I8),
                "u8" => Ok(Self::U8),
                "i16" => Ok(Self::I16),
                "u16" => Ok(Self::U16),
                "i32" => Ok(Self::I32),
                "u32" => Ok(Self::U32),
                "i64" => Ok(Self::I64),
                "u64" => Ok(Self::U64),
                "ip_addr" => Ok(Self::IpAddr),
                "uuid" => Ok(Self::Uuid),
                "bool" => Ok(Self::Bool),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FieldType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The `FieldValue` contains the value of a target or metric field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The `FieldValue` contains the value of a target or
    /// metric field.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "string"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i8"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "int8"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u8"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "uint8",
    ///          "minimum": 0.0
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i16"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "int16"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u16"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i32"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "int32"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u32"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "i64"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "int64"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "u64"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "integer",
    ///          "format": "uint64",
    ///          "minimum": 0.0
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_addr"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "uuid"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "bool"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "boolean"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum FieldValue {
        #[serde(rename = "string")]
        String(::std::string::String),
        #[serde(rename = "i8")]
        I8(i8),
        #[serde(rename = "u8")]
        U8(u8),
        #[serde(rename = "i16")]
        I16(i16),
        #[serde(rename = "u16")]
        U16(u16),
        #[serde(rename = "i32")]
        I32(i32),
        #[serde(rename = "u32")]
        U32(u32),
        #[serde(rename = "i64")]
        I64(i64),
        #[serde(rename = "u64")]
        U64(u64),
        #[serde(rename = "ip_addr")]
        IpAddr(::std::net::IpAddr),
        #[serde(rename = "uuid")]
        Uuid(::uuid::Uuid),
        #[serde(rename = "bool")]
        Bool(bool),
    }

    impl ::std::convert::From<&Self> for FieldValue {
        fn from(value: &FieldValue) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<i8> for FieldValue {
        fn from(value: i8) -> Self {
            Self::I8(value)
        }
    }

    impl ::std::convert::From<u8> for FieldValue {
        fn from(value: u8) -> Self {
            Self::U8(value)
        }
    }

    impl ::std::convert::From<i16> for FieldValue {
        fn from(value: i16) -> Self {
            Self::I16(value)
        }
    }

    impl ::std::convert::From<u16> for FieldValue {
        fn from(value: u16) -> Self {
            Self::U16(value)
        }
    }

    impl ::std::convert::From<i32> for FieldValue {
        fn from(value: i32) -> Self {
            Self::I32(value)
        }
    }

    impl ::std::convert::From<u32> for FieldValue {
        fn from(value: u32) -> Self {
            Self::U32(value)
        }
    }

    impl ::std::convert::From<i64> for FieldValue {
        fn from(value: i64) -> Self {
            Self::I64(value)
        }
    }

    impl ::std::convert::From<u64> for FieldValue {
        fn from(value: u64) -> Self {
            Self::U64(value)
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for FieldValue {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::IpAddr(value)
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for FieldValue {
        fn from(value: ::uuid::Uuid) -> Self {
            Self::Uuid(value)
        }
    }

    impl ::std::convert::From<bool> for FieldValue {
        fn from(value: bool) -> Self {
            Self::Bool(value)
        }
    }

    /// Parameters for finalizing a disk
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for finalizing a disk",
    ///  "type": "object",
    ///  "properties": {
    ///    "snapshot_name": {
    ///      "description": "If specified a snapshot of the disk will be created
    /// with the given name during finalization. If not specified, a snapshot
    /// for the disk will _not_ be created. A snapshot can be manually created
    /// once the disk transitions into the `Detached` state.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FinalizeDisk {
        /// If specified a snapshot of the disk will be created with the given
        /// name during finalization. If not specified, a snapshot for the disk
        /// will _not_ be created. A snapshot can be manually created once the
        /// disk transitions into the `Detached` state.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub snapshot_name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&FinalizeDisk> for FinalizeDisk {
        fn from(value: &FinalizeDisk) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for FinalizeDisk {
        fn default() -> Self {
            Self {
                snapshot_name: Default::default(),
            }
        }
    }

    impl FinalizeDisk {
        pub fn builder() -> builder::FinalizeDisk {
            Default::default()
        }
    }

    /// `FleetRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum FleetRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for FleetRole {
        fn from(value: &FleetRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FleetRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for FleetRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FleetRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Policy for a particular resource
    ///
    /// Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Policy for a particular resource\n\nNote that the
    /// Policy only describes access granted explicitly for this resource.  The
    /// policies of parent resources can also cause a user to have access to
    /// this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FleetRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FleetRolePolicy {
        /// Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<FleetRoleRoleAssignment>,
    }

    impl ::std::convert::From<&FleetRolePolicy> for FleetRolePolicy {
        fn from(value: &FleetRolePolicy) -> Self {
            value.clone()
        }
    }

    impl FleetRolePolicy {
        pub fn builder() -> builder::FleetRolePolicy {
            Default::default()
        }
    }

    /// Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    /// The resource is not part of this structure.  Rather, `RoleAssignment`s
    /// are put into a `Policy` and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, `RoleAssignment`s are
    /// put into a `Policy` and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/FleetRole"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FleetRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: FleetRole,
    }

    impl ::std::convert::From<&FleetRoleRoleAssignment> for FleetRoleRoleAssignment {
        fn from(value: &FleetRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl FleetRoleRoleAssignment {
        pub fn builder() -> builder::FleetRoleRoleAssignment {
            Default::default()
        }
    }

    /// A Floating IP is a well-known IP address which can be attached and
    /// detached from instances.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A Floating IP is a well-known IP address which can be
    /// attached and detached from instances.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "ip",
    ///    "ip_pool_id",
    ///    "name",
    ///    "project_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "instance_id": {
    ///      "description": "The ID of the instance that this Floating IP is
    /// attached to, if it is presently in use.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address held by this resource.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "ip_pool_id": {
    ///      "description": "The ID of the IP pool this resource belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "The project this resource exists within.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FloatingIp {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The ID of the instance that this Floating IP is attached to, if it
        /// is presently in use.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub instance_id: ::std::option::Option<::uuid::Uuid>,
        /// The IP address held by this resource.
        pub ip: ::std::net::IpAddr,
        /// The ID of the IP pool this resource belongs to.
        pub ip_pool_id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// The project this resource exists within.
        pub project_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&FloatingIp> for FloatingIp {
        fn from(value: &FloatingIp) -> Self {
            value.clone()
        }
    }

    impl FloatingIp {
        pub fn builder() -> builder::FloatingIp {
            Default::default()
        }
    }

    /// Parameters for attaching a floating IP address to another resource
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for attaching a floating IP address to
    /// another resource",
    ///  "type": "object",
    ///  "required": [
    ///    "kind",
    ///    "parent"
    ///  ],
    ///  "properties": {
    ///    "kind": {
    ///      "description": "The type of `parent`'s resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/FloatingIpParentKind"
    ///        }
    ///      ]
    ///    },
    ///    "parent": {
    ///      "description": "Name or ID of the resource that this IP address
    /// should be attached to",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FloatingIpAttach {
        /// The type of `parent`'s resource
        pub kind: FloatingIpParentKind,
        /// Name or ID of the resource that this IP address should be attached
        /// to
        pub parent: NameOrId,
    }

    impl ::std::convert::From<&FloatingIpAttach> for FloatingIpAttach {
        fn from(value: &FloatingIpAttach) -> Self {
            value.clone()
        }
    }

    impl FloatingIpAttach {
        pub fn builder() -> builder::FloatingIpAttach {
            Default::default()
        }
    }

    /// Parameters for creating a new floating IP address for instances.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating a new floating IP address for
    /// instances.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ip": {
    ///      "description": "An IP address to reserve for use as a floating IP.
    /// This field is optional: when not set, an address will be automatically
    /// chosen from `pool`. If set, then the IP must be available in the
    /// resolved `pool`.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "pool": {
    ///      "description": "The parent IP pool that a floating IP is pulled
    /// from. If unset, the default pool is selected.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/NameOrId"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FloatingIpCreate {
        pub description: ::std::string::String,
        /// An IP address to reserve for use as a floating IP. This field is
        /// optional: when not set, an address will be automatically chosen from
        /// `pool`. If set, then the IP must be available in the resolved
        /// `pool`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ip: ::std::option::Option<::std::net::IpAddr>,
        pub name: Name,
        /// The parent IP pool that a floating IP is pulled from. If unset, the
        /// default pool is selected.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pool: ::std::option::Option<NameOrId>,
    }

    impl ::std::convert::From<&FloatingIpCreate> for FloatingIpCreate {
        fn from(value: &FloatingIpCreate) -> Self {
            value.clone()
        }
    }

    impl FloatingIpCreate {
        pub fn builder() -> builder::FloatingIpCreate {
            Default::default()
        }
    }

    /// The type of resource that a floating IP is attached to
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The type of resource that a floating IP is attached
    /// to",
    ///  "type": "string",
    ///  "enum": [
    ///    "instance"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum FloatingIpParentKind {
        #[serde(rename = "instance")]
        Instance,
    }

    impl ::std::convert::From<&Self> for FloatingIpParentKind {
        fn from(value: &FloatingIpParentKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for FloatingIpParentKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Instance => write!(f, "instance"),
            }
        }
    }

    impl ::std::str::FromStr for FloatingIpParentKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "instance" => Ok(Self::Instance),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for FloatingIpParentKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for FloatingIpParentKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for FloatingIpParentKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FloatingIp"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FloatingIpResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<FloatingIp>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&FloatingIpResultsPage> for FloatingIpResultsPage {
        fn from(value: &FloatingIpResultsPage) -> Self {
            value.clone()
        }
    }

    impl FloatingIpResultsPage {
        pub fn builder() -> builder::FloatingIpResultsPage {
            Default::default()
        }
    }

    /// Updateable identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable identity-related parameters",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct FloatingIpUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&FloatingIpUpdate> for FloatingIpUpdate {
        fn from(value: &FloatingIpUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for FloatingIpUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl FloatingIpUpdate {
        pub fn builder() -> builder::FloatingIpUpdate {
            Default::default()
        }
    }

    /// View of a Group
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Group",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the group",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this group belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Group {
        /// Human-readable name that can identify the group
        pub display_name: ::std::string::String,
        pub id: ::uuid::Uuid,
        /// Uuid of the silo to which this group belongs
        pub silo_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&Group> for Group {
        fn from(value: &Group) -> Self {
            value.clone()
        }
    }

    impl Group {
        pub fn builder() -> builder::Group {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Group"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct GroupResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Group>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&GroupResultsPage> for GroupResultsPage {
        fn from(value: &GroupResultsPage) -> Self {
            value.clone()
        }
    }

    impl GroupResultsPage {
        pub fn builder() -> builder::GroupResultsPage {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Bindouble"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramdouble {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Bindouble>,
        pub max: f64,
        pub min: f64,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub sum_of_samples: f64,
    }

    impl ::std::convert::From<&Histogramdouble> for Histogramdouble {
        fn from(value: &Histogramdouble) -> Self {
            value.clone()
        }
    }

    impl Histogramdouble {
        pub fn builder() -> builder::Histogramdouble {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binfloat"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "number",
    ///      "format": "float"
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramfloat {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binfloat>,
        pub max: f32,
        pub min: f32,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        pub sum_of_samples: f64,
    }

    impl ::std::convert::From<&Histogramfloat> for Histogramfloat {
        fn from(value: &Histogramfloat) -> Self {
            value.clone()
        }
    }

    impl Histogramfloat {
        pub fn builder() -> builder::Histogramfloat {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binint16"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int16"
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int16"
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramint16 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binint16>,
        /// The maximum value of all samples in the histogram.
        pub max: i16,
        /// The minimum value of all samples in the histogram.
        pub min: i16,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramint16> for Histogramint16 {
        fn from(value: &Histogramint16) -> Self {
            value.clone()
        }
    }

    impl Histogramint16 {
        pub fn builder() -> builder::Histogramint16 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binint32"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int32"
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramint32 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binint32>,
        /// The maximum value of all samples in the histogram.
        pub max: i32,
        /// The minimum value of all samples in the histogram.
        pub min: i32,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramint32> for Histogramint32 {
        fn from(value: &Histogramint32) -> Self {
            value.clone()
        }
    }

    impl Histogramint32 {
        pub fn builder() -> builder::Histogramint32 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binint64"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramint64 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binint64>,
        /// The maximum value of all samples in the histogram.
        pub max: i64,
        /// The minimum value of all samples in the histogram.
        pub min: i64,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramint64> for Histogramint64 {
        fn from(value: &Histogramint64) -> Self {
            value.clone()
        }
    }

    impl Histogramint64 {
        pub fn builder() -> builder::Histogramint64 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binint8"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int8"
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "int8"
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramint8 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binint8>,
        /// The maximum value of all samples in the histogram.
        pub max: i8,
        /// The minimum value of all samples in the histogram.
        pub min: i8,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramint8> for Histogramint8 {
        fn from(value: &Histogramint8) -> Self {
            value.clone()
        }
    }

    impl Histogramint8 {
        pub fn builder() -> builder::Histogramint8 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binuint16"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramuint16 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binuint16>,
        /// The maximum value of all samples in the histogram.
        pub max: u16,
        /// The minimum value of all samples in the histogram.
        pub min: u16,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramuint16> for Histogramuint16 {
        fn from(value: &Histogramuint16) -> Self {
            value.clone()
        }
    }

    impl Histogramuint16 {
        pub fn builder() -> builder::Histogramuint16 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binuint32"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramuint32 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binuint32>,
        /// The maximum value of all samples in the histogram.
        pub max: u32,
        /// The minimum value of all samples in the histogram.
        pub min: u32,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramuint32> for Histogramuint32 {
        fn from(value: &Histogramuint32) -> Self {
            value.clone()
        }
    }

    impl Histogramuint32 {
        pub fn builder() -> builder::Histogramuint32 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binuint64"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramuint64 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binuint64>,
        /// The maximum value of all samples in the histogram.
        pub max: u64,
        /// The minimum value of all samples in the histogram.
        pub min: u64,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramuint64> for Histogramuint64 {
        fn from(value: &Histogramuint64) -> Self {
            value.clone()
        }
    }

    impl Histogramuint64 {
        pub fn builder() -> builder::Histogramuint64 {
            Default::default()
        }
    }

    /// Histogram metric
    ///
    /// A histogram maintains the count of any number of samples, over a set of
    /// bins. Bins are specified on construction via their _left_ edges,
    /// inclusive. There can't be any "gaps" in the bins, and an additional bin
    /// may be added to the left, right, or both so that the bins extend to the
    /// entire range of the support.
    ///
    /// Note that any gaps, unsorted bins, or non-finite values will result in
    /// an error.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Histogram metric\n\nA histogram maintains the count of
    /// any number of samples, over a set of bins. Bins are specified on
    /// construction via their _left_ edges, inclusive. There can't be any
    /// \"gaps\" in the bins, and an additional bin may be added to the left,
    /// right, or both so that the bins extend to the entire range of the
    /// support.\n\nNote that any gaps, unsorted bins, or non-finite values will
    /// result in an error.",
    ///  "type": "object",
    ///  "required": [
    ///    "bins",
    ///    "max",
    ///    "min",
    ///    "n_samples",
    ///    "p50",
    ///    "p90",
    ///    "p99",
    ///    "squared_mean",
    ///    "start_time",
    ///    "sum_of_samples"
    ///  ],
    ///  "properties": {
    ///    "bins": {
    ///      "description": "The bins of the histogram.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Binuint8"
    ///      }
    ///    },
    ///    "max": {
    ///      "description": "The maximum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "min": {
    ///      "description": "The minimum value of all samples in the
    /// histogram.",
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "n_samples": {
    ///      "description": "The total number of samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    },
    ///    "p50": {
    ///      "description": "p50 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p90": {
    ///      "description": "p95 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "p99": {
    ///      "description": "p99 Quantile",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Quantile"
    ///        }
    ///      ]
    ///    },
    ///    "squared_mean": {
    ///      "description": "M2 for Welford's algorithm for variance calculation.\n\nRead about [Welford's algorithm](https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Welford's_online_algorithm) for more information on the algorithm.",
    ///      "type": "number",
    ///      "format": "double"
    ///    },
    ///    "start_time": {
    ///      "description": "The start time of the histogram.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "sum_of_samples": {
    ///      "description": "The sum of all samples in the histogram.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Histogramuint8 {
        /// The bins of the histogram.
        pub bins: ::std::vec::Vec<Binuint8>,
        /// The maximum value of all samples in the histogram.
        pub max: u8,
        /// The minimum value of all samples in the histogram.
        pub min: u8,
        /// The total number of samples in the histogram.
        pub n_samples: u64,
        /// p50 Quantile
        pub p50: Quantile,
        /// p95 Quantile
        pub p90: Quantile,
        /// p99 Quantile
        pub p99: Quantile,
        pub squared_mean: f64,
        /// The start time of the histogram.
        pub start_time: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The sum of all samples in the histogram.
        pub sum_of_samples: i64,
    }

    impl ::std::convert::From<&Histogramuint8> for Histogramuint8 {
        fn from(value: &Histogramuint8) -> Self {
            value.clone()
        }
    }

    impl Histogramuint8 {
        pub fn builder() -> builder::Histogramuint8 {
            Default::default()
        }
    }

    /// A hostname identifies a host on a network, and is usually a
    /// dot-delimited sequence of labels, where each label contains only
    /// letters, digits, or the hyphen. See RFCs 1035 and 952 for more details.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "An RFC-1035-compliant hostname",
    ///  "description": "A hostname identifies a host on a network, and is
    /// usually a dot-delimited sequence of labels, where each label contains
    /// only letters, digits, or the hyphen. See RFCs 1035 and 952 for more
    /// details.",
    ///  "type": "string",
    ///  "maxLength": 253,
    ///  "minLength": 1,
    ///  "pattern":
    /// "^([a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))(\\.[a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!
    /// -))*$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct Hostname(::std::string::String);
    impl ::std::ops::Deref for Hostname {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Hostname> for ::std::string::String {
        fn from(value: Hostname) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Hostname> for Hostname {
        fn from(value: &Hostname) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Hostname {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 253usize {
                return Err("longer than 253 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            if regress::Regex::new(
                "^([a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))(\\.[a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))*$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^([a-zA-Z0-9]+[a-zA-Z0-9\\-]*(?<!-))(\\.[a-zA-Z0-9]+[a-zA-Z0-9\\\
                            -]*(?<!-))*$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Hostname {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Hostname {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Hostname {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Hostname {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// Supported set of sort modes for scanning by id only.
    ///
    /// Currently, we only support scanning in ascending order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Supported set of sort modes for scanning by id
    /// only.\n\nCurrently, we only support scanning in ascending order.",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"id\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "id_ascending"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum IdSortMode {
        /// sort in increasing order of "id"
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl ::std::convert::From<&Self> for IdSortMode {
        fn from(value: &IdSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IdSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::IdAscending => write!(f, "id_ascending"),
            }
        }
    }

    impl ::std::str::FromStr for IdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// View of an Identity Provider
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an Identity Provider",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "provider_type",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "provider_type": {
    ///      "description": "Identity provider type",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IdentityProviderType"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IdentityProvider {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// Identity provider type
        pub provider_type: IdentityProviderType,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&IdentityProvider> for IdentityProvider {
        fn from(value: &IdentityProvider) -> Self {
            value.clone()
        }
    }

    impl IdentityProvider {
        pub fn builder() -> builder::IdentityProvider {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IdentityProvider"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IdentityProviderResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<IdentityProvider>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IdentityProviderResultsPage> for IdentityProviderResultsPage {
        fn from(value: &IdentityProviderResultsPage) -> Self {
            value.clone()
        }
    }

    impl IdentityProviderResultsPage {
        pub fn builder() -> builder::IdentityProviderResultsPage {
            Default::default()
        }
    }

    /// `IdentityProviderType`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "description": "SAML identity provider",
    ///      "type": "string",
    ///      "enum": [
    ///        "saml"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum IdentityProviderType {
        /// SAML identity provider
        #[serde(rename = "saml")]
        Saml,
    }

    impl ::std::convert::From<&Self> for IdentityProviderType {
        fn from(value: &IdentityProviderType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IdentityProviderType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Saml => write!(f, "saml"),
            }
        }
    }

    impl ::std::str::FromStr for IdentityProviderType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "saml" => Ok(Self::Saml),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IdentityProviderType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Describes what kind of identity is described by an id
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes what kind of identity is described by an id",
    ///  "type": "string",
    ///  "enum": [
    ///    "silo_user",
    ///    "silo_group"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum IdentityType {
        #[serde(rename = "silo_user")]
        SiloUser,
        #[serde(rename = "silo_group")]
        SiloGroup,
    }

    impl ::std::convert::From<&Self> for IdentityType {
        fn from(value: &IdentityType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for IdentityType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SiloUser => write!(f, "silo_user"),
                Self::SiloGroup => write!(f, "silo_group"),
            }
        }
    }

    impl ::std::str::FromStr for IdentityType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "silo_user" => Ok(Self::SiloUser),
                "silo_group" => Ok(Self::SiloGroup),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IdentityType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `IdpMetadataSource`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "url"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "url"
    ///          ]
    ///        },
    ///        "url": {
    ///          "type": "string"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "data",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "data": {
    ///          "type": "string"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "base64_encoded_xml"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum IdpMetadataSource {
        #[serde(rename = "url")]
        Url { url: ::std::string::String },
        #[serde(rename = "base64_encoded_xml")]
        Base64EncodedXml { data: ::std::string::String },
    }

    impl ::std::convert::From<&Self> for IdpMetadataSource {
        fn from(value: &IdpMetadataSource) -> Self {
            value.clone()
        }
    }

    /// View of an image
    ///
    /// If `project_id` is present then the image is only visible inside that
    /// project. If it's not present then the image is visible to all projects
    /// in the silo.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an image\n\nIf `project_id` is present then the
    /// image is only visible inside that project. If it's not present then the
    /// image is visible to all projects in the silo.",
    ///  "type": "object",
    ///  "required": [
    ///    "block_size",
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "os",
    ///    "size",
    ///    "time_created",
    ///    "time_modified",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "block_size": {
    ///      "description": "size of blocks in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "digest": {
    ///      "description": "Hash of the image contents, if applicable",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Digest"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "os": {
    ///      "description": "The family of the operating system like Debian,
    /// Ubuntu, etc.",
    ///      "type": "string"
    ///    },
    ///    "project_id": {
    ///      "description": "ID of the parent project if the image is a project
    /// image",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "description": "total size in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "version": {
    ///      "description": "Version of the operating system",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Image {
        /// size of blocks in bytes
        pub block_size: ByteCount,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// Hash of the image contents, if applicable
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub digest: ::std::option::Option<Digest>,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// The family of the operating system like Debian, Ubuntu, etc.
        pub os: ::std::string::String,
        /// ID of the parent project if the image is a project image
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub project_id: ::std::option::Option<::uuid::Uuid>,
        /// total size in bytes
        pub size: ByteCount,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// Version of the operating system
        pub version: ::std::string::String,
    }

    impl ::std::convert::From<&Image> for Image {
        fn from(value: &Image) -> Self {
            value.clone()
        }
    }

    impl Image {
        pub fn builder() -> builder::Image {
            Default::default()
        }
    }

    /// Create-time parameters for an `Image`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `Image`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "os",
    ///    "source",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "os": {
    ///      "description": "The family of the operating system (e.g. Debian,
    /// Ubuntu, etc.)",
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "description": "The source of the image's contents.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ImageSource"
    ///        }
    ///      ]
    ///    },
    ///    "version": {
    ///      "description": "The version of the operating system (e.g. 18.04,
    /// 20.04, etc.)",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ImageCreate {
        pub description: ::std::string::String,
        pub name: Name,
        /// The family of the operating system (e.g. Debian, Ubuntu, etc.)
        pub os: ::std::string::String,
        /// The source of the image's contents.
        pub source: ImageSource,
        /// The version of the operating system (e.g. 18.04, 20.04, etc.)
        pub version: ::std::string::String,
    }

    impl ::std::convert::From<&ImageCreate> for ImageCreate {
        fn from(value: &ImageCreate) -> Self {
            value.clone()
        }
    }

    impl ImageCreate {
        pub fn builder() -> builder::ImageCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Image"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ImageResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Image>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ImageResultsPage> for ImageResultsPage {
        fn from(value: &ImageResultsPage) -> Self {
            value.clone()
        }
    }

    impl ImageResultsPage {
        pub fn builder() -> builder::ImageResultsPage {
            Default::default()
        }
    }

    /// The source of the underlying image.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The source of the underlying image.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "snapshot"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "id")]
    pub enum ImageSource {
        #[serde(rename = "snapshot")]
        Snapshot(::uuid::Uuid),
    }

    impl ::std::convert::From<&Self> for ImageSource {
        fn from(value: &ImageSource) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for ImageSource {
        fn from(value: ::uuid::Uuid) -> Self {
            Self::Snapshot(value)
        }
    }

    /// Parameters for importing blocks with a bulk write
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for importing blocks with a bulk write",
    ///  "type": "object",
    ///  "required": [
    ///    "base64_encoded_data",
    ///    "offset"
    ///  ],
    ///  "properties": {
    ///    "base64_encoded_data": {
    ///      "type": "string"
    ///    },
    ///    "offset": {
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ImportBlocksBulkWrite {
        pub base64_encoded_data: ::std::string::String,
        pub offset: u64,
    }

    impl ::std::convert::From<&ImportBlocksBulkWrite> for ImportBlocksBulkWrite {
        fn from(value: &ImportBlocksBulkWrite) -> Self {
            value.clone()
        }
    }

    impl ImportBlocksBulkWrite {
        pub fn builder() -> builder::ImportBlocksBulkWrite {
            Default::default()
        }
    }

    /// Define policy relating to the import and export of prefixes from a BGP
    /// peer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Define policy relating to the import and export of
    /// prefixes from a BGP peer.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Do not perform any filtering.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "no_filtering"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "allow"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/IpNet"
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum ImportExportPolicy {
        #[serde(rename = "no_filtering")]
        NoFiltering,
        #[serde(rename = "allow")]
        Allow(::std::vec::Vec<IpNet>),
    }

    impl ::std::convert::From<&Self> for ImportExportPolicy {
        fn from(value: &ImportExportPolicy) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<IpNet>> for ImportExportPolicy {
        fn from(value: ::std::vec::Vec<IpNet>) -> Self {
            Self::Allow(value)
        }
    }

    /// View of an Instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an Instance",
    ///  "type": "object",
    ///  "required": [
    ///    "auto_restart_enabled",
    ///    "description",
    ///    "hostname",
    ///    "id",
    ///    "memory",
    ///    "name",
    ///    "ncpus",
    ///    "project_id",
    ///    "run_state",
    ///    "time_created",
    ///    "time_modified",
    ///    "time_run_state_updated"
    ///  ],
    ///  "properties": {
    ///    "auto_restart_cooldown_expiration": {
    ///      "description": "The time at which the auto-restart cooldown period
    /// for this instance completes, permitting it to be automatically restarted
    /// again. If the instance enters the `Failed` state, it will not be
    /// restarted until after this time.\n\nIf this is not present, then either
    /// the instance has never been automatically restarted, or the cooldown
    /// period has already expired, allowing the instance to be restarted
    /// immediately if it fails.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date-time"
    ///    },
    ///    "auto_restart_enabled": {
    ///      "description": "`true` if this instance's auto-restart policy will
    /// permit the control plane to automatically restart it if it enters the
    /// `Failed` state.",
    ///      "type": "boolean"
    ///    },
    ///    "auto_restart_policy": {
    ///      "description": "The auto-restart policy configured for this
    /// instance, or `null` if no explicit policy has been configured.\n\nThis
    /// policy determines whether the instance should be automatically restarted
    /// by the control plane on failure. If this is `null`, the control plane
    /// will use the default policy when determining whether or not to
    /// automatically restart this instance, which may or may not allow it to be
    /// restarted. The value of the `auto_restart_enabled` field indicates
    /// whether the instance will be auto-restarted, based on its current policy
    /// or the default if it has no configured policy.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/InstanceAutoRestartPolicy"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "boot_disk_id": {
    ///      "description": "the ID of the disk used to boot this Instance, if a
    /// specific one is assigned.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "hostname": {
    ///      "description": "RFC1035-compliant hostname for the Instance.",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "memory": {
    ///      "description": "memory allocated for this Instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "ncpus": {
    ///      "description": "number of CPUs allocated for this Instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/InstanceCpuCount"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "id for the project containing this Instance",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "run_state": {
    ///      "$ref": "#/components/schemas/InstanceState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_last_auto_restarted": {
    ///      "description": "The timestamp of the most recent time this instance
    /// was automatically restarted by the control plane.\n\nIf this is not
    /// present, then this instance has not been automatically restarted.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_run_state_updated": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Instance {
        /// The time at which the auto-restart cooldown period for this instance
        /// completes, permitting it to be automatically restarted again. If the
        /// instance enters the `Failed` state, it will not be restarted until
        /// after this time.
        ///
        /// If this is not present, then either the instance has never been
        /// automatically restarted, or the cooldown period has already expired,
        /// allowing the instance to be restarted immediately if it fails.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_restart_cooldown_expiration:
            ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        /// `true` if this instance's auto-restart policy will permit the
        /// control plane to automatically restart it if it enters the `Failed`
        /// state.
        pub auto_restart_enabled: bool,
        /// The auto-restart policy configured for this instance, or `null` if
        /// no explicit policy has been configured.
        ///
        /// This policy determines whether the instance should be automatically
        /// restarted by the control plane on failure. If this is `null`, the
        /// control plane will use the default policy when determining whether
        /// or not to automatically restart this instance, which may or may not
        /// allow it to be restarted. The value of the `auto_restart_enabled`
        /// field indicates whether the instance will be auto-restarted, based
        /// on its current policy or the default if it has no configured policy.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_restart_policy: ::std::option::Option<InstanceAutoRestartPolicy>,
        /// the ID of the disk used to boot this Instance, if a specific one is
        /// assigned.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub boot_disk_id: ::std::option::Option<::uuid::Uuid>,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// RFC1035-compliant hostname for the Instance.
        pub hostname: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// memory allocated for this Instance
        pub memory: ByteCount,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// number of CPUs allocated for this Instance
        pub ncpus: InstanceCpuCount,
        /// id for the project containing this Instance
        pub project_id: ::uuid::Uuid,
        pub run_state: InstanceState,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The timestamp of the most recent time this instance was
        /// automatically restarted by the control plane.
        ///
        /// If this is not present, then this instance has not been
        /// automatically restarted.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub time_last_auto_restarted:
            ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub time_run_state_updated: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Instance> for Instance {
        fn from(value: &Instance) -> Self {
            value.clone()
        }
    }

    impl Instance {
        pub fn builder() -> builder::Instance {
            Default::default()
        }
    }

    /// A policy determining when an instance should be automatically restarted
    /// by the control plane.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A policy determining when an instance should be
    /// automatically restarted by the control plane.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The instance should not be automatically restarted
    /// by the control plane if it fails.",
    ///      "type": "string",
    ///      "enum": [
    ///        "never"
    ///      ]
    ///    },
    ///    {
    ///      "description": "If this instance is running and unexpectedly fails
    /// (e.g. due to a host software crash or unexpected host reboot), the
    /// control plane will make a best-effort attempt to restart it. The control
    /// plane may choose not to restart the instance to preserve the overall
    /// availability of the system.",
    ///      "type": "string",
    ///      "enum": [
    ///        "best_effort"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum InstanceAutoRestartPolicy {
        /// The instance should not be automatically restarted by the control
        /// plane if it fails.
        #[serde(rename = "never")]
        Never,
        /// If this instance is running and unexpectedly fails (e.g. due to a
        /// host software crash or unexpected host reboot), the control plane
        /// will make a best-effort attempt to restart it. The control plane may
        /// choose not to restart the instance to preserve the overall
        /// availability of the system.
        #[serde(rename = "best_effort")]
        BestEffort,
    }

    impl ::std::convert::From<&Self> for InstanceAutoRestartPolicy {
        fn from(value: &InstanceAutoRestartPolicy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InstanceAutoRestartPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Never => write!(f, "never"),
                Self::BestEffort => write!(f, "best_effort"),
            }
        }
    }

    impl ::std::str::FromStr for InstanceAutoRestartPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "never" => Ok(Self::Never),
                "best_effort" => Ok(Self::BestEffort),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InstanceAutoRestartPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InstanceAutoRestartPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InstanceAutoRestartPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The number of CPUs in an Instance
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The number of CPUs in an Instance",
    ///  "type": "integer",
    ///  "format": "uint16",
    ///  "minimum": 0.0
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct InstanceCpuCount(pub u16);
    impl ::std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &u16 {
            &self.0
        }
    }

    impl ::std::convert::From<InstanceCpuCount> for u16 {
        fn from(value: InstanceCpuCount) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&InstanceCpuCount> for InstanceCpuCount {
        fn from(value: &InstanceCpuCount) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<u16> for InstanceCpuCount {
        fn from(value: u16) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for InstanceCpuCount {
        type Err = <u16 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for InstanceCpuCount {
        type Error = <u16 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for InstanceCpuCount {
        type Error = <u16 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for InstanceCpuCount {
        type Error = <u16 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for InstanceCpuCount {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// Create-time parameters for an `Instance`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `Instance`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "hostname",
    ///    "memory",
    ///    "name",
    ///    "ncpus"
    ///  ],
    ///  "properties": {
    ///    "anti_affinity_groups": {
    ///      "description": "Anti-Affinity groups which this instance should be
    /// added.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NameOrId"
    ///      }
    ///    },
    ///    "auto_restart_policy": {
    ///      "description": "The auto-restart policy for this instance.\n\nThis
    /// policy determines whether the instance should be automatically restarted
    /// by the control plane on failure. If this is `null`, no auto-restart
    /// policy will be explicitly configured for this instance, and the control
    /// plane will select the default policy when determining whether the
    /// instance can be automatically restarted.\n\nCurrently, the global
    /// default auto-restart policy is \"best-effort\", so instances with `null`
    /// auto-restart policies will be automatically restarted. However, in the
    /// future, the default policy may be configurable through other mechanisms,
    /// such as on a per-project basis. In that case, any configured default
    /// policy will be used if this is `null`.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/InstanceAutoRestartPolicy"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "boot_disk": {
    ///      "description": "The disk this instance should boot into. This disk
    /// can either be attached if it already exists, or created, if it should be
    /// a new disk.\n\nIt is strongly recommended to either provide a boot disk
    /// at instance creation, or update the instance after creation to set a
    /// boot disk.\n\nAn instance without an explicit boot disk can be booted:
    /// the options are as managed by UEFI, and as controlled by the guest OS,
    /// but with some risk.  If this instance later has a disk attached or
    /// detached, it is possible that boot options can end up reordered, with
    /// the intended boot disk moved after the EFI shell in boot priority. This
    /// may result in an instance that only boots to the EFI shell until the
    /// desired disk is set as an explicit boot disk and the instance
    /// rebooted.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/InstanceDiskAttachment"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disks": {
    ///      "description": "The disks to be created or attached for this
    /// instance.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InstanceDiskAttachment"
    ///      }
    ///    },
    ///    "external_ips": {
    ///      "description": "The external IP addresses provided to this
    /// instance.\n\nBy default, all instances have outbound connectivity, but
    /// no inbound connectivity. These external addresses can be used to provide
    /// a fixed, known IP address for making inbound connections to the
    /// instance.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ExternalIpCreate"
    ///      }
    ///    },
    ///    "hostname": {
    ///      "description": "The hostname to be assigned to the instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Hostname"
    ///        }
    ///      ]
    ///    },
    ///    "memory": {
    ///      "description": "The amount of RAM (in bytes) to be allocated to the
    /// instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ncpus": {
    ///      "description": "The number of vCPUs to be allocated to the
    /// instance",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/InstanceCpuCount"
    ///        }
    ///      ]
    ///    },
    ///    "network_interfaces": {
    ///      "description": "The network interfaces to be created for this
    /// instance.",
    ///      "default": {
    ///        "type": "default"
    ///      },
    ///      "allOf": [
    ///        {
    ///          "$ref":
    /// "#/components/schemas/InstanceNetworkInterfaceAttachment"
    ///        }
    ///      ]
    ///    },
    ///    "ssh_public_keys": {
    ///      "description": "An allowlist of SSH public keys to be transferred
    /// to the instance via cloud-init during instance creation.\n\nIf not
    /// provided, all SSH public keys from the user's profile will be sent. If
    /// an empty list is provided, no public keys will be transmitted to the
    /// instance.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/NameOrId"
    ///      }
    ///    },
    ///    "start": {
    ///      "description": "Should this instance be started upon creation; true
    /// by default.",
    ///      "default": true,
    ///      "type": "boolean"
    ///    },
    ///    "user_data": {
    ///      "description": "User data for instance initialization systems (such
    /// as cloud-init). Must be a Base64-encoded string, as specified in RFC
    /// 4648  4 (+ and / characters with padding). Maximum 32 KiB unencoded
    /// data.",
    ///      "default": "",
    ///      "type": "string",
    ///      "format": "byte"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceCreate {
        /// Anti-Affinity groups which this instance should be added.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub anti_affinity_groups: ::std::vec::Vec<NameOrId>,
        /// The auto-restart policy for this instance.
        ///
        /// This policy determines whether the instance should be automatically
        /// restarted by the control plane on failure. If this is `null`, no
        /// auto-restart policy will be explicitly configured for this instance,
        /// and the control plane will select the default policy when
        /// determining whether the instance can be automatically restarted.
        ///
        /// Currently, the global default auto-restart policy is "best-effort",
        /// so instances with `null` auto-restart policies will be automatically
        /// restarted. However, in the future, the default policy may be
        /// configurable through other mechanisms, such as on a per-project
        /// basis. In that case, any configured default policy will be used if
        /// this is `null`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_restart_policy: ::std::option::Option<InstanceAutoRestartPolicy>,
        /// The disk this instance should boot into. This disk can either be
        /// attached if it already exists, or created, if it should be a new
        /// disk.
        ///
        /// It is strongly recommended to either provide a boot disk at instance
        /// creation, or update the instance after creation to set a boot disk.
        ///
        /// An instance without an explicit boot disk can be booted: the options
        /// are as managed by UEFI, and as controlled by the guest OS, but with
        /// some risk.  If this instance later has a disk attached or detached,
        /// it is possible that boot options can end up reordered, with the
        /// intended boot disk moved after the EFI shell in boot priority. This
        /// may result in an instance that only boots to the EFI shell until the
        /// desired disk is set as an explicit boot disk and the instance
        /// rebooted.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub boot_disk: ::std::option::Option<InstanceDiskAttachment>,
        pub description: ::std::string::String,
        /// The disks to be created or attached for this instance.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub disks: ::std::vec::Vec<InstanceDiskAttachment>,
        /// The external IP addresses provided to this instance.
        ///
        /// By default, all instances have outbound connectivity, but no inbound
        /// connectivity. These external addresses can be used to provide a
        /// fixed, known IP address for making inbound connections to the
        /// instance.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub external_ips: ::std::vec::Vec<ExternalIpCreate>,
        /// The hostname to be assigned to the instance
        pub hostname: Hostname,
        /// The amount of RAM (in bytes) to be allocated to the instance
        pub memory: ByteCount,
        pub name: Name,
        /// The number of vCPUs to be allocated to the instance
        pub ncpus: InstanceCpuCount,
        /// The network interfaces to be created for this instance.
        #[serde(default = "defaults::instance_create_network_interfaces")]
        pub network_interfaces: InstanceNetworkInterfaceAttachment,
        /// An allowlist of SSH public keys to be transferred to the instance
        /// via cloud-init during instance creation.
        ///
        /// If not provided, all SSH public keys from the user's profile will be
        /// sent. If an empty list is provided, no public keys will be
        /// transmitted to the instance.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ssh_public_keys: ::std::option::Option<::std::vec::Vec<NameOrId>>,
        /// Should this instance be started upon creation; true by default.
        #[serde(default = "defaults::default_bool::<true>")]
        pub start: bool,
        /// User data for instance initialization systems (such as cloud-init).
        /// Must be a Base64-encoded string, as specified in RFC 4648  4 (+ and
        /// / characters with padding). Maximum 32 KiB unencoded data.
        #[serde(default)]
        pub user_data: ::std::string::String,
    }

    impl ::std::convert::From<&InstanceCreate> for InstanceCreate {
        fn from(value: &InstanceCreate) -> Self {
            value.clone()
        }
    }

    impl InstanceCreate {
        pub fn builder() -> builder::InstanceCreate {
            Default::default()
        }
    }

    /// Describe the instance's disks at creation time
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describe the instance's disks at creation time",
    ///  "oneOf": [
    ///    {
    ///      "description": "During instance creation, create and attach disks",
    ///      "type": "object",
    ///      "required": [
    ///        "description",
    ///        "disk_source",
    ///        "name",
    ///        "size",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "description": {
    ///          "type": "string"
    ///        },
    ///        "disk_source": {
    ///          "description": "The initial source for this disk",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DiskSource"
    ///            }
    ///          ]
    ///        },
    ///        "name": {
    ///          "$ref": "#/components/schemas/Name"
    ///        },
    ///        "size": {
    ///          "description": "The total size of the Disk (in bytes)",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/ByteCount"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "create"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "During instance creation, attach this disk",
    ///      "type": "object",
    ///      "required": [
    ///        "name",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "name": {
    ///          "description": "A disk name to attach",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "attach"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type")]
    pub enum InstanceDiskAttachment {
        /// During instance creation, create and attach disks
        #[serde(rename = "create")]
        Create {
            description: ::std::string::String,
            /// The initial source for this disk
            disk_source: DiskSource,
            name: Name,
            /// The total size of the Disk (in bytes)
            size: ByteCount,
        },
        /// During instance creation, attach this disk
        #[serde(rename = "attach")]
        Attach {
            /// A disk name to attach
            name: Name,
        },
    }

    impl ::std::convert::From<&Self> for InstanceDiskAttachment {
        fn from(value: &InstanceDiskAttachment) -> Self {
            value.clone()
        }
    }

    /// An `InstanceNetworkInterface` represents a virtual network interface
    /// device attached to an instance.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An `InstanceNetworkInterface` represents a virtual
    /// network interface device attached to an instance.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "instance_id",
    ///    "ip",
    ///    "mac",
    ///    "name",
    ///    "primary",
    ///    "subnet_id",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "instance_id": {
    ///      "description": "The Instance to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address assigned to this interface.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "mac": {
    ///      "description": "The MAC address assigned to this interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/MacAddr"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "primary": {
    ///      "description": "True if this interface is the primary for the
    /// instance to which it's attached.",
    ///      "type": "boolean"
    ///    },
    ///    "subnet_id": {
    ///      "description": "The subnet to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "transit_ips": {
    ///      "description": "A set of additional networks that this interface
    /// may send and receive traffic on.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpNet"
    ///      }
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the interface belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceNetworkInterface {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The Instance to which the interface belongs.
        pub instance_id: ::uuid::Uuid,
        /// The IP address assigned to this interface.
        pub ip: ::std::net::IpAddr,
        /// The MAC address assigned to this interface.
        pub mac: MacAddr,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// True if this interface is the primary for the instance to which it's
        /// attached.
        pub primary: bool,
        /// The subnet to which the interface belongs.
        pub subnet_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// A set of additional networks that this interface may send and
        /// receive traffic on.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transit_ips: ::std::vec::Vec<IpNet>,
        /// The VPC to which the interface belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&InstanceNetworkInterface> for InstanceNetworkInterface {
        fn from(value: &InstanceNetworkInterface) -> Self {
            value.clone()
        }
    }

    impl InstanceNetworkInterface {
        pub fn builder() -> builder::InstanceNetworkInterface {
            Default::default()
        }
    }

    /// Describes an attachment of an `InstanceNetworkInterface` to an
    /// `Instance`, at the time the instance is created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes an attachment of an
    /// `InstanceNetworkInterface` to an `Instance`, at the time the instance is
    /// created.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Create one or more `InstanceNetworkInterface`s for
    /// the `Instance`.\n\nIf more than one interface is provided, then the
    /// first will be designated the primary interface for the instance.",
    ///      "type": "object",
    ///      "required": [
    ///        "params",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "params": {
    ///          "type": "array",
    ///          "items": {
    ///            "$ref": "#/components/schemas/InstanceNetworkInterfaceCreate"
    ///          }
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "create"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The default networking configuration for an
    /// instance is to create a single primary interface with an
    /// automatically-assigned IP address. The IP will be pulled from the
    /// Project's default VPC / VPC Subnet.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "default"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "No network interfaces at all will be created for
    /// the instance.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "none"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "params")]
    pub enum InstanceNetworkInterfaceAttachment {
        /// Create one or more `InstanceNetworkInterface`s for the `Instance`.
        ///
        /// If more than one interface is provided, then the first will be
        /// designated the primary interface for the instance.
        #[serde(rename = "create")]
        Create(::std::vec::Vec<InstanceNetworkInterfaceCreate>),
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "none")]
        None,
    }

    impl ::std::convert::From<&Self> for InstanceNetworkInterfaceAttachment {
        fn from(value: &InstanceNetworkInterfaceAttachment) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<InstanceNetworkInterfaceCreate>>
        for InstanceNetworkInterfaceAttachment
    {
        fn from(value: ::std::vec::Vec<InstanceNetworkInterfaceCreate>) -> Self {
            Self::Create(value)
        }
    }

    /// Create-time parameters for an `InstanceNetworkInterface`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an
    /// `InstanceNetworkInterface`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "subnet_name",
    ///    "vpc_name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ip": {
    ///      "description": "The IP address for the interface. One will be
    /// auto-assigned if not provided.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "subnet_name": {
    ///      "description": "The VPC Subnet in which to create the interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "vpc_name": {
    ///      "description": "The VPC in which to create the interface.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceNetworkInterfaceCreate {
        pub description: ::std::string::String,
        /// The IP address for the interface. One will be auto-assigned if not
        /// provided.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ip: ::std::option::Option<::std::net::IpAddr>,
        pub name: Name,
        /// The VPC Subnet in which to create the interface.
        pub subnet_name: Name,
        /// The VPC in which to create the interface.
        pub vpc_name: Name,
    }

    impl ::std::convert::From<&InstanceNetworkInterfaceCreate> for InstanceNetworkInterfaceCreate {
        fn from(value: &InstanceNetworkInterfaceCreate) -> Self {
            value.clone()
        }
    }

    impl InstanceNetworkInterfaceCreate {
        pub fn builder() -> builder::InstanceNetworkInterfaceCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InstanceNetworkInterface"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceNetworkInterfaceResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<InstanceNetworkInterface>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InstanceNetworkInterfaceResultsPage>
        for InstanceNetworkInterfaceResultsPage
    {
        fn from(value: &InstanceNetworkInterfaceResultsPage) -> Self {
            value.clone()
        }
    }

    impl InstanceNetworkInterfaceResultsPage {
        pub fn builder() -> builder::InstanceNetworkInterfaceResultsPage {
            Default::default()
        }
    }

    /// Parameters for updating an `InstanceNetworkInterface`
    ///
    /// Note that modifying IP addresses for an interface is not yet supported,
    /// a new interface must be created instead.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for updating an
    /// `InstanceNetworkInterface`\n\nNote that modifying IP addresses for an
    /// interface is not yet supported, a new interface must be created
    /// instead.",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "primary": {
    ///      "description": "Make a secondary interface the instance's primary
    /// interface.\n\nIf applied to a secondary interface, that interface will
    /// become the primary on the next reboot of the instance. Note that this
    /// may have implications for routing between instances, as the new primary
    /// interface will be on a distinct subnet from the previous primary
    /// interface.\n\nNote that this can only be used to select a new primary
    /// interface for an instance. Requests to change the primary interface into
    /// a secondary will return an error.",
    ///      "default": false,
    ///      "type": "boolean"
    ///    },
    ///    "transit_ips": {
    ///      "description": "A set of additional networks that this interface
    /// may send and receive traffic on.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpNet"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceNetworkInterfaceUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
        /// Make a secondary interface the instance's primary interface.
        ///
        /// If applied to a secondary interface, that interface will become the
        /// primary on the next reboot of the instance. Note that this may have
        /// implications for routing between instances, as the new primary
        /// interface will be on a distinct subnet from the previous primary
        /// interface.
        ///
        /// Note that this can only be used to select a new primary interface
        /// for an instance. Requests to change the primary interface into a
        /// secondary will return an error.
        #[serde(default)]
        pub primary: bool,
        /// A set of additional networks that this interface may send and
        /// receive traffic on.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transit_ips: ::std::vec::Vec<IpNet>,
    }

    impl ::std::convert::From<&InstanceNetworkInterfaceUpdate> for InstanceNetworkInterfaceUpdate {
        fn from(value: &InstanceNetworkInterfaceUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for InstanceNetworkInterfaceUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
                primary: Default::default(),
                transit_ips: Default::default(),
            }
        }
    }

    impl InstanceNetworkInterfaceUpdate {
        pub fn builder() -> builder::InstanceNetworkInterfaceUpdate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Instance"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Instance>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InstanceResultsPage> for InstanceResultsPage {
        fn from(value: &InstanceResultsPage) -> Self {
            value.clone()
        }
    }

    impl InstanceResultsPage {
        pub fn builder() -> builder::InstanceResultsPage {
            Default::default()
        }
    }

    /// Contents of an Instance's serial console buffer.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Contents of an Instance's serial console buffer.",
    ///  "type": "object",
    ///  "required": [
    ///    "data",
    ///    "last_byte_offset"
    ///  ],
    ///  "properties": {
    ///    "data": {
    ///      "description": "The bytes starting from the requested offset up to
    /// either the end of the buffer or the request's `max_bytes`. Provided as a
    /// u8 array rather than a string, as it may not be UTF-8.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    },
    ///    "last_byte_offset": {
    ///      "description": "The absolute offset since boot (suitable for use as
    /// `byte_offset` in a subsequent request) of the last byte returned in
    /// `data`.",
    ///      "type": "integer",
    ///      "format": "uint64",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceSerialConsoleData {
        /// The bytes starting from the requested offset up to either the end of
        /// the buffer or the request's `max_bytes`. Provided as a u8 array
        /// rather than a string, as it may not be UTF-8.
        pub data: ::std::vec::Vec<u8>,
        /// The absolute offset since boot (suitable for use as `byte_offset` in
        /// a subsequent request) of the last byte returned in `data`.
        pub last_byte_offset: u64,
    }

    impl ::std::convert::From<&InstanceSerialConsoleData> for InstanceSerialConsoleData {
        fn from(value: &InstanceSerialConsoleData) -> Self {
            value.clone()
        }
    }

    impl InstanceSerialConsoleData {
        pub fn builder() -> builder::InstanceSerialConsoleData {
            Default::default()
        }
    }

    /// Running state of an Instance (primarily: booted or stopped)
    ///
    /// This typically reflects whether it's starting, running, stopping, or
    /// stopped, but also includes states related to the Instance's lifecycle
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Running state of an Instance (primarily: booted or
    /// stopped)\n\nThis typically reflects whether it's starting, running,
    /// stopping, or stopped, but also includes states related to the Instance's
    /// lifecycle",
    ///  "oneOf": [
    ///    {
    ///      "description": "The instance is being created.",
    ///      "type": "string",
    ///      "enum": [
    ///        "creating"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently starting up.",
    ///      "type": "string",
    ///      "enum": [
    ///        "starting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently running.",
    ///      "type": "string",
    ///      "enum": [
    ///        "running"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has been requested to stop and a
    /// transition to \"Stopped\" is imminent.",
    ///      "type": "string",
    ///      "enum": [
    ///        "stopping"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is currently stopped.",
    ///      "type": "string",
    ///      "enum": [
    ///        "stopped"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is in the process of rebooting - it
    /// will remain in the \"rebooting\" state until the VM is starting once
    /// more.",
    ///      "type": "string",
    ///      "enum": [
    ///        "rebooting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is in the process of migrating - it will remain in the \"migrating\" state until the migration process is complete and the destination propolis is ready to continue execution.",
    ///      "type": "string",
    ///      "enum": [
    ///        "migrating"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance is attempting to recover from a
    /// failure.",
    ///      "type": "string",
    ///      "enum": [
    ///        "repairing"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has encountered a failure.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The instance has been deleted.",
    ///      "type": "string",
    ///      "enum": [
    ///        "destroyed"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum InstanceState {
        /// The instance is being created.
        #[serde(rename = "creating")]
        Creating,
        /// The instance is currently starting up.
        #[serde(rename = "starting")]
        Starting,
        /// The instance is currently running.
        #[serde(rename = "running")]
        Running,
        /// The instance has been requested to stop and a transition to
        /// "Stopped" is imminent.
        #[serde(rename = "stopping")]
        Stopping,
        /// The instance is currently stopped.
        #[serde(rename = "stopped")]
        Stopped,
        /// The instance is in the process of rebooting - it will remain in the
        /// "rebooting" state until the VM is starting once more.
        #[serde(rename = "rebooting")]
        Rebooting,
        /// The instance is in the process of migrating - it will remain in the
        /// "migrating" state until the migration process is complete and the
        /// destination propolis is ready to continue execution.
        #[serde(rename = "migrating")]
        Migrating,
        /// The instance is attempting to recover from a failure.
        #[serde(rename = "repairing")]
        Repairing,
        /// The instance has encountered a failure.
        #[serde(rename = "failed")]
        Failed,
        /// The instance has been deleted.
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ::std::convert::From<&Self> for InstanceState {
        fn from(value: &InstanceState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for InstanceState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creating => write!(f, "creating"),
                Self::Starting => write!(f, "starting"),
                Self::Running => write!(f, "running"),
                Self::Stopping => write!(f, "stopping"),
                Self::Stopped => write!(f, "stopped"),
                Self::Rebooting => write!(f, "rebooting"),
                Self::Migrating => write!(f, "migrating"),
                Self::Repairing => write!(f, "repairing"),
                Self::Failed => write!(f, "failed"),
                Self::Destroyed => write!(f, "destroyed"),
            }
        }
    }

    impl ::std::str::FromStr for InstanceState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creating" => Ok(Self::Creating),
                "starting" => Ok(Self::Starting),
                "running" => Ok(Self::Running),
                "stopping" => Ok(Self::Stopping),
                "stopped" => Ok(Self::Stopped),
                "rebooting" => Ok(Self::Rebooting),
                "migrating" => Ok(Self::Migrating),
                "repairing" => Ok(Self::Repairing),
                "failed" => Ok(Self::Failed),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for InstanceState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Parameters of an `Instance` that can be reconfigured after creation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters of an `Instance` that can be reconfigured
    /// after creation.",
    ///  "type": "object",
    ///  "required": [
    ///    "memory",
    ///    "ncpus"
    ///  ],
    ///  "properties": {
    ///    "auto_restart_policy": {
    ///      "description": "Sets the auto-restart policy for this
    /// instance.\n\nThis policy determines whether the instance should be
    /// automatically restarted by the control plane on failure. If this is
    /// `null`, any explicitly configured auto-restart policy will be unset, and
    /// the control plane will select the default policy when determining
    /// whether the instance can be automatically restarted.\n\nCurrently, the
    /// global default auto-restart policy is \"best-effort\", so instances with
    /// `null` auto-restart policies will be automatically restarted. However,
    /// in the future, the default policy may be configurable through other
    /// mechanisms, such as on a per-project basis. In that case, any configured
    /// default policy will be used if this is `null`.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/InstanceAutoRestartPolicy"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "boot_disk": {
    ///      "description": "Name or ID of the disk the instance should be
    /// instructed to boot from.\n\nIf not provided, unset the instance's boot
    /// disk.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/NameOrId"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "memory": {
    ///      "description": "The amount of memory to assign to this instance.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "ncpus": {
    ///      "description": "The number of CPUs to assign to this instance.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/InstanceCpuCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InstanceUpdate {
        /// Sets the auto-restart policy for this instance.
        ///
        /// This policy determines whether the instance should be automatically
        /// restarted by the control plane on failure. If this is `null`, any
        /// explicitly configured auto-restart policy will be unset, and the
        /// control plane will select the default policy when determining
        /// whether the instance can be automatically restarted.
        ///
        /// Currently, the global default auto-restart policy is "best-effort",
        /// so instances with `null` auto-restart policies will be automatically
        /// restarted. However, in the future, the default policy may be
        /// configurable through other mechanisms, such as on a per-project
        /// basis. In that case, any configured default policy will be used if
        /// this is `null`.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub auto_restart_policy: ::std::option::Option<InstanceAutoRestartPolicy>,
        /// Name or ID of the disk the instance should be instructed to boot
        /// from.
        ///
        /// If not provided, unset the instance's boot disk.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub boot_disk: ::std::option::Option<NameOrId>,
        /// The amount of memory to assign to this instance.
        pub memory: ByteCount,
        /// The number of CPUs to assign to this instance.
        pub ncpus: InstanceCpuCount,
    }

    impl ::std::convert::From<&InstanceUpdate> for InstanceUpdate {
        fn from(value: &InstanceUpdate) -> Self {
            value.clone()
        }
    }

    impl InstanceUpdate {
        pub fn builder() -> builder::InstanceUpdate {
            Default::default()
        }
    }

    /// `InterfaceNum`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "unknown"
    ///      ],
    ///      "properties": {
    ///        "unknown": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "if_index"
    ///      ],
    ///      "properties": {
    ///        "if_index": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "port_number"
    ///      ],
    ///      "properties": {
    ///        "port_number": {
    ///          "type": "integer",
    ///          "format": "uint32",
    ///          "minimum": 0.0
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub enum InterfaceNum {
        #[serde(rename = "unknown")]
        Unknown(u32),
        #[serde(rename = "if_index")]
        IfIndex(u32),
        #[serde(rename = "port_number")]
        PortNumber(u32),
    }

    impl ::std::convert::From<&Self> for InterfaceNum {
        fn from(value: &InterfaceNum) -> Self {
            value.clone()
        }
    }

    /// An internet gateway provides a path between VPC networks and external
    /// networks.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An internet gateway provides a path between VPC
    /// networks and external networks.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the gateway belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGateway {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The VPC to which the gateway belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&InternetGateway> for InternetGateway {
        fn from(value: &InternetGateway) -> Self {
            value.clone()
        }
    }

    impl InternetGateway {
        pub fn builder() -> builder::InternetGateway {
            Default::default()
        }
    }

    /// Create-time parameters for an `InternetGateway`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `InternetGateway`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&InternetGatewayCreate> for InternetGatewayCreate {
        fn from(value: &InternetGatewayCreate) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayCreate {
        pub fn builder() -> builder::InternetGatewayCreate {
            Default::default()
        }
    }

    /// An IP address that is attached to an internet gateway
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An IP address that is attached to an internet gateway",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "description",
    ///    "id",
    ///    "internet_gateway_id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The associated IP address,",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "internet_gateway_id": {
    ///      "description": "The associated internet gateway.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayIpAddress {
        /// The associated IP address,
        pub address: ::std::net::IpAddr,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The associated internet gateway.
        pub internet_gateway_id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&InternetGatewayIpAddress> for InternetGatewayIpAddress {
        fn from(value: &InternetGatewayIpAddress) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayIpAddress {
        pub fn builder() -> builder::InternetGatewayIpAddress {
            Default::default()
        }
    }

    /// Create-time identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time identity-related parameters",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayIpAddressCreate {
        pub address: ::std::net::IpAddr,
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&InternetGatewayIpAddressCreate> for InternetGatewayIpAddressCreate {
        fn from(value: &InternetGatewayIpAddressCreate) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayIpAddressCreate {
        pub fn builder() -> builder::InternetGatewayIpAddressCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InternetGatewayIpAddress"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayIpAddressResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<InternetGatewayIpAddress>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InternetGatewayIpAddressResultsPage>
        for InternetGatewayIpAddressResultsPage
    {
        fn from(value: &InternetGatewayIpAddressResultsPage) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayIpAddressResultsPage {
        pub fn builder() -> builder::InternetGatewayIpAddressResultsPage {
            Default::default()
        }
    }

    /// An IP pool that is attached to an internet gateway
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An IP pool that is attached to an internet gateway",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "internet_gateway_id",
    ///    "ip_pool_id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "internet_gateway_id": {
    ///      "description": "The associated internet gateway.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ip_pool_id": {
    ///      "description": "The associated IP pool.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayIpPool {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The associated internet gateway.
        pub internet_gateway_id: ::uuid::Uuid,
        /// The associated IP pool.
        pub ip_pool_id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&InternetGatewayIpPool> for InternetGatewayIpPool {
        fn from(value: &InternetGatewayIpPool) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayIpPool {
        pub fn builder() -> builder::InternetGatewayIpPool {
            Default::default()
        }
    }

    /// Create-time identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time identity-related parameters",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "ip_pool",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ip_pool": {
    ///      "$ref": "#/components/schemas/NameOrId"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayIpPoolCreate {
        pub description: ::std::string::String,
        pub ip_pool: NameOrId,
        pub name: Name,
    }

    impl ::std::convert::From<&InternetGatewayIpPoolCreate> for InternetGatewayIpPoolCreate {
        fn from(value: &InternetGatewayIpPoolCreate) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayIpPoolCreate {
        pub fn builder() -> builder::InternetGatewayIpPoolCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InternetGatewayIpPool"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayIpPoolResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<InternetGatewayIpPool>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InternetGatewayIpPoolResultsPage> for InternetGatewayIpPoolResultsPage {
        fn from(value: &InternetGatewayIpPoolResultsPage) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayIpPoolResultsPage {
        pub fn builder() -> builder::InternetGatewayIpPoolResultsPage {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/InternetGateway"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct InternetGatewayResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<InternetGateway>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&InternetGatewayResultsPage> for InternetGatewayResultsPage {
        fn from(value: &InternetGatewayResultsPage) -> Self {
            value.clone()
        }
    }

    impl InternetGatewayResultsPage {
        pub fn builder() -> builder::InternetGatewayResultsPage {
            Default::default()
        }
    }

    /// `IpNet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "title": "v4",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "v6",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    }
    ///  ],
    ///  "x-rust-type": {
    ///    "crate": "oxnet",
    ///    "path": "oxnet::IpNet",
    ///    "version": "0.1.0"
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(untagged)]
    pub enum IpNet {
        V4(Ipv4Net),
        V6(Ipv6Net),
    }

    impl ::std::convert::From<&Self> for IpNet {
        fn from(value: &IpNet) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for IpNet {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::V4(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::V6(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for IpNet {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for IpNet {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::V4(x) => x.fmt(f),
                Self::V6(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<Ipv4Net> for IpNet {
        fn from(value: Ipv4Net) -> Self {
            Self::V4(value)
        }
    }

    impl ::std::convert::From<Ipv6Net> for IpNet {
        fn from(value: Ipv6Net) -> Self {
            Self::V6(value)
        }
    }

    /// A collection of IP ranges. If a pool is linked to a silo, IP addresses
    /// from the pool can be allocated within that silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A collection of IP ranges. If a pool is linked to a
    /// silo, IP addresses from the pool can be allocated within that silo",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPool {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&IpPool> for IpPool {
        fn from(value: &IpPool) -> Self {
            value.clone()
        }
    }

    impl IpPool {
        pub fn builder() -> builder::IpPool {
            Default::default()
        }
    }

    /// Create-time parameters for an `IpPool`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `IpPool`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&IpPoolCreate> for IpPoolCreate {
        fn from(value: &IpPoolCreate) -> Self {
            value.clone()
        }
    }

    impl IpPoolCreate {
        pub fn builder() -> builder::IpPoolCreate {
            Default::default()
        }
    }

    /// `IpPoolLinkSilo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "is_default",
    ///    "silo"
    ///  ],
    ///  "properties": {
    ///    "is_default": {
    ///      "description": "When a pool is the default for a silo, floating IPs
    /// and instance ephemeral IPs will come from that pool when no other pool
    /// is specified. There can be at most one default for a given silo.",
    ///      "type": "boolean"
    ///    },
    ///    "silo": {
    ///      "$ref": "#/components/schemas/NameOrId"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolLinkSilo {
        /// When a pool is the default for a silo, floating IPs and instance
        /// ephemeral IPs will come from that pool when no other pool is
        /// specified. There can be at most one default for a given silo.
        pub is_default: bool,
        pub silo: NameOrId,
    }

    impl ::std::convert::From<&IpPoolLinkSilo> for IpPoolLinkSilo {
        fn from(value: &IpPoolLinkSilo) -> Self {
            value.clone()
        }
    }

    impl IpPoolLinkSilo {
        pub fn builder() -> builder::IpPoolLinkSilo {
            Default::default()
        }
    }

    /// `IpPoolRange`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "ip_pool_id",
    ///    "range",
    ///    "time_created"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ip_pool_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "range": {
    ///      "$ref": "#/components/schemas/IpRange"
    ///    },
    ///    "time_created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolRange {
        pub id: ::uuid::Uuid,
        pub ip_pool_id: ::uuid::Uuid,
        pub range: IpRange,
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&IpPoolRange> for IpPoolRange {
        fn from(value: &IpPoolRange) -> Self {
            value.clone()
        }
    }

    impl IpPoolRange {
        pub fn builder() -> builder::IpPoolRange {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPoolRange"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolRangeResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<IpPoolRange>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IpPoolRangeResultsPage> for IpPoolRangeResultsPage {
        fn from(value: &IpPoolRangeResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolRangeResultsPage {
        pub fn builder() -> builder::IpPoolRangeResultsPage {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPool"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<IpPool>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IpPoolResultsPage> for IpPoolResultsPage {
        fn from(value: &IpPoolResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolResultsPage {
        pub fn builder() -> builder::IpPoolResultsPage {
            Default::default()
        }
    }

    /// A link between an IP pool and a silo that allows one to allocate IPs
    /// from the pool within the silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A link between an IP pool and a silo that allows one to
    /// allocate IPs from the pool within the silo",
    ///  "type": "object",
    ///  "required": [
    ///    "ip_pool_id",
    ///    "is_default",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "ip_pool_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "is_default": {
    ///      "description": "When a pool is the default for a silo, floating IPs
    /// and instance ephemeral IPs will come from that pool when no other pool
    /// is specified. There can be at most one default for a given silo.",
    ///      "type": "boolean"
    ///    },
    ///    "silo_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolSiloLink {
        pub ip_pool_id: ::uuid::Uuid,
        /// When a pool is the default for a silo, floating IPs and instance
        /// ephemeral IPs will come from that pool when no other pool is
        /// specified. There can be at most one default for a given silo.
        pub is_default: bool,
        pub silo_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&IpPoolSiloLink> for IpPoolSiloLink {
        fn from(value: &IpPoolSiloLink) -> Self {
            value.clone()
        }
    }

    impl IpPoolSiloLink {
        pub fn builder() -> builder::IpPoolSiloLink {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpPoolSiloLink"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolSiloLinkResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<IpPoolSiloLink>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&IpPoolSiloLinkResultsPage> for IpPoolSiloLinkResultsPage {
        fn from(value: &IpPoolSiloLinkResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolSiloLinkResultsPage {
        pub fn builder() -> builder::IpPoolSiloLinkResultsPage {
            Default::default()
        }
    }

    /// `IpPoolSiloUpdate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "is_default"
    ///  ],
    ///  "properties": {
    ///    "is_default": {
    ///      "description": "When a pool is the default for a silo, floating IPs
    /// and instance ephemeral IPs will come from that pool when no other pool
    /// is specified. There can be at most one default for a given silo, so when
    /// a pool is made default, an existing default will remain linked but will
    /// no longer be the default.",
    ///      "type": "boolean"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolSiloUpdate {
        /// When a pool is the default for a silo, floating IPs and instance
        /// ephemeral IPs will come from that pool when no other pool is
        /// specified. There can be at most one default for a given silo, so
        /// when a pool is made default, an existing default will remain linked
        /// but will no longer be the default.
        pub is_default: bool,
    }

    impl ::std::convert::From<&IpPoolSiloUpdate> for IpPoolSiloUpdate {
        fn from(value: &IpPoolSiloUpdate) -> Self {
            value.clone()
        }
    }

    impl IpPoolSiloUpdate {
        pub fn builder() -> builder::IpPoolSiloUpdate {
            Default::default()
        }
    }

    /// Parameters for updating an IP Pool
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for updating an IP Pool",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&IpPoolUpdate> for IpPoolUpdate {
        fn from(value: &IpPoolUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for IpPoolUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl IpPoolUpdate {
        pub fn builder() -> builder::IpPoolUpdate {
            Default::default()
        }
    }

    /// `IpPoolUtilization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "ipv4",
    ///    "ipv6"
    ///  ],
    ///  "properties": {
    ///    "ipv4": {
    ///      "description": "Number of allocated and total available IPv4
    /// addresses in pool",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Utilization"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6": {
    ///      "description": "Number of allocated and total available IPv6
    /// addresses in pool",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Utilization"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct IpPoolUtilization {
        /// Number of allocated and total available IPv4 addresses in pool
        pub ipv4: Ipv4Utilization,
        /// Number of allocated and total available IPv6 addresses in pool
        pub ipv6: Ipv6Utilization,
    }

    impl ::std::convert::From<&IpPoolUtilization> for IpPoolUtilization {
        fn from(value: &IpPoolUtilization) -> Self {
            value.clone()
        }
    }

    impl IpPoolUtilization {
        pub fn builder() -> builder::IpPoolUtilization {
            Default::default()
        }
    }

    /// `IpRange`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "title": "v4",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Range"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "v6",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Range"
    ///        }
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(untagged)]
    pub enum IpRange {
        V4(Ipv4Range),
        V6(Ipv6Range),
    }

    impl ::std::convert::From<&Self> for IpRange {
        fn from(value: &IpRange) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<Ipv4Range> for IpRange {
        fn from(value: Ipv4Range) -> Self {
            Self::V4(value)
        }
    }

    impl ::std::convert::From<Ipv6Range> for IpRange {
        fn from(value: Ipv6Range) -> Self {
            Self::V6(value)
        }
    }

    /// An IPv4 subnet, including prefix and prefix length
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "An IPv4 subnet",
    ///  "description": "An IPv4 subnet, including prefix and prefix length",
    ///  "examples": [
    ///    "192.168.1.0/24"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.
    /// ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/
    /// ([0-9]|1[0-9]|2[0-9]|3[0-2])$",
    ///  "x-rust-type": {
    ///    "crate": "oxnet",
    ///    "path": "oxnet::Ipv4Net",
    ///    "version": "0.1.0"
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct Ipv4Net(::std::string::String);
    impl ::std::ops::Deref for Ipv4Net {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Ipv4Net> for ::std::string::String {
        fn from(value: Ipv4Net) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Ipv4Net> for Ipv4Net {
        fn from(value: &Ipv4Net) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv4Net {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
                 ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/\
                 ([0-9]|1[0-9]|2[0-9]|3[0-2])$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.\
                            ){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/\
                            ([0-9]|1[0-9]|2[0-9]|3[0-2])$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Ipv4Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv4Net {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// A non-decreasing IPv4 address range, inclusive of both ends.
    ///
    /// The first address must be less than or equal to the last address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A non-decreasing IPv4 address range, inclusive of both
    /// ends.\n\nThe first address must be less than or equal to the last
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "first",
    ///    "last"
    ///  ],
    ///  "properties": {
    ///    "first": {
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    },
    ///    "last": {
    ///      "type": "string",
    ///      "format": "ipv4"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Ipv4Range {
        pub first: ::std::net::Ipv4Addr,
        pub last: ::std::net::Ipv4Addr,
    }

    impl ::std::convert::From<&Ipv4Range> for Ipv4Range {
        fn from(value: &Ipv4Range) -> Self {
            value.clone()
        }
    }

    impl Ipv4Range {
        pub fn builder() -> builder::Ipv4Range {
            Default::default()
        }
    }

    /// `Ipv4Utilization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "allocated",
    ///    "capacity"
    ///  ],
    ///  "properties": {
    ///    "allocated": {
    ///      "description": "The number of IPv4 addresses allocated from this
    /// pool",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "capacity": {
    ///      "description": "The total number of IPv4 addresses in the pool, i.e., the sum of the lengths of the IPv4 ranges. Unlike IPv6 capacity, can be a 32-bit integer because there are only 2^32 IPv4 addresses.",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Ipv4Utilization {
        /// The number of IPv4 addresses allocated from this pool
        pub allocated: u32,
        /// The total number of IPv4 addresses in the pool, i.e., the sum of the
        /// lengths of the IPv4 ranges. Unlike IPv6 capacity, can be a 32-bit
        /// integer because there are only 2^32 IPv4 addresses.
        pub capacity: u32,
    }

    impl ::std::convert::From<&Ipv4Utilization> for Ipv4Utilization {
        fn from(value: &Ipv4Utilization) -> Self {
            value.clone()
        }
    }

    impl Ipv4Utilization {
        pub fn builder() -> builder::Ipv4Utilization {
            Default::default()
        }
    }

    /// An IPv6 subnet, including prefix and subnet mask
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "An IPv6 subnet",
    ///  "description": "An IPv6 subnet, including prefix and subnet mask",
    ///  "examples": [
    ///    "fd12:3456::/64"
    ///  ],
    ///  "type": "string",
    ///  "pattern":
    /// "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:
    /// |([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:
    /// [0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,
    /// 3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:
    /// ){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,
    /// 6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%
    /// [0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,
    /// 1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,
    /// 1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,
    /// 1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/
    /// ([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$",
    ///  "x-rust-type": {
    ///    "crate": "oxnet",
    ///    "path": "oxnet::Ipv6Net",
    ///    "version": "0.1.0"
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct Ipv6Net(::std::string::String);
    impl ::std::ops::Deref for Ipv6Net {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Ipv6Net> for ::std::string::String {
        fn from(value: Ipv6Net) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Ipv6Net> for Ipv6Net {
        fn from(value: &Ipv6Net) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Ipv6Net {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:\
                 |([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:\
                 [0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,\
                 3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:\
                 [0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:\
                 [0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:\
                 0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,\
                 3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:\
                 ((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,\
                 1}[0-9]){0,1}[0-9]))\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,\
                            7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,\
                            5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,\
                            4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,\
                            4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,\
                            4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:\
                            [0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,\
                            1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,\
                            3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:\
                            ((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,\
                            3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/\
                            ([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Ipv6Net {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Ipv6Net {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// A non-decreasing IPv6 address range, inclusive of both ends.
    ///
    /// The first address must be less than or equal to the last address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A non-decreasing IPv6 address range, inclusive of both
    /// ends.\n\nThe first address must be less than or equal to the last
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "first",
    ///    "last"
    ///  ],
    ///  "properties": {
    ///    "first": {
    ///      "type": "string",
    ///      "format": "ipv6"
    ///    },
    ///    "last": {
    ///      "type": "string",
    ///      "format": "ipv6"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Ipv6Range {
        pub first: ::std::net::Ipv6Addr,
        pub last: ::std::net::Ipv6Addr,
    }

    impl ::std::convert::From<&Ipv6Range> for Ipv6Range {
        fn from(value: &Ipv6Range) -> Self {
            value.clone()
        }
    }

    impl Ipv6Range {
        pub fn builder() -> builder::Ipv6Range {
            Default::default()
        }
    }

    /// `Ipv6Utilization`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "allocated",
    ///    "capacity"
    ///  ],
    ///  "properties": {
    ///    "allocated": {
    ///      "description": "The number of IPv6 addresses allocated from this
    /// pool. A 128-bit integer string to match the capacity field.",
    ///      "type": "string",
    ///      "format": "uint128"
    ///    },
    ///    "capacity": {
    ///      "description": "The total number of IPv6 addresses in the pool,
    /// i.e., the sum of the lengths of the IPv6 ranges. An IPv6 range can
    /// contain up to 2^128 addresses, so we represent this value in JSON as a
    /// numeric string with a custom \"uint128\" format.",
    ///      "type": "string",
    ///      "format": "uint128"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Ipv6Utilization {
        /// The number of IPv6 addresses allocated from this pool. A 128-bit
        /// integer string to match the capacity field.
        pub allocated: ::std::string::String,
        /// The total number of IPv6 addresses in the pool, i.e., the sum of the
        /// lengths of the IPv6 ranges. An IPv6 range can contain up to 2^128
        /// addresses, so we represent this value in JSON as a numeric string
        /// with a custom "uint128" format.
        pub capacity: ::std::string::String,
    }

    impl ::std::convert::From<&Ipv6Utilization> for Ipv6Utilization {
        fn from(value: &Ipv6Utilization) -> Self {
            value.clone()
        }
    }

    impl Ipv6Utilization {
        pub fn builder() -> builder::Ipv6Utilization {
            Default::default()
        }
    }

    /// An inclusive-inclusive range of IP ports. The second port may be omitted
    /// to represent a single port.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A range of IP ports",
    ///  "description": "An inclusive-inclusive range of IP ports. The second
    /// port may be omitted to represent a single port.",
    ///  "examples": [
    ///    "22"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 11,
    ///  "minLength": 1,
    ///  "pattern": "^[0-9]{1,5}(-[0-9]{1,5})?$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct L4PortRange(::std::string::String);
    impl ::std::ops::Deref for L4PortRange {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<L4PortRange> for ::std::string::String {
        fn from(value: L4PortRange) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&L4PortRange> for L4PortRange {
        fn from(value: &L4PortRange) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for L4PortRange {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 11usize {
                return Err("longer than 11 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            if regress::Regex::new("^[0-9]{1,5}(-[0-9]{1,5})?$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9]{1,5}(-[0-9]{1,5})?$\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for L4PortRange {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for L4PortRange {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// Switch link configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Switch link configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "autoneg",
    ///    "lldp",
    ///    "mtu",
    ///    "speed"
    ///  ],
    ///  "properties": {
    ///    "autoneg": {
    ///      "description": "Whether or not to set autonegotiation",
    ///      "type": "boolean"
    ///    },
    ///    "fec": {
    ///      "description": "The requested forward-error correction method.  If
    /// this is not specified, the standard FEC for the underlying media will be
    /// applied if it can be determined.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/LinkFec"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "lldp": {
    ///      "description": "The link-layer discovery protocol (LLDP)
    /// configuration for the link.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/LldpLinkConfigCreate"
    ///        }
    ///      ]
    ///    },
    ///    "mtu": {
    ///      "description": "Maximum transmission unit for the link.",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "speed": {
    ///      "description": "The speed of the link.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/LinkSpeed"
    ///        }
    ///      ]
    ///    },
    ///    "tx_eq": {
    ///      "description": "Optional tx_eq settings",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/TxEqConfig"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LinkConfigCreate {
        /// Whether or not to set autonegotiation
        pub autoneg: bool,
        /// The requested forward-error correction method.  If this is not
        /// specified, the standard FEC for the underlying media will be applied
        /// if it can be determined.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub fec: ::std::option::Option<LinkFec>,
        /// The link-layer discovery protocol (LLDP) configuration for the link.
        pub lldp: LldpLinkConfigCreate,
        /// Maximum transmission unit for the link.
        pub mtu: u16,
        /// The speed of the link.
        pub speed: LinkSpeed,
        /// Optional tx_eq settings
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tx_eq: ::std::option::Option<TxEqConfig>,
    }

    impl ::std::convert::From<&LinkConfigCreate> for LinkConfigCreate {
        fn from(value: &LinkConfigCreate) -> Self {
            value.clone()
        }
    }

    impl LinkConfigCreate {
        pub fn builder() -> builder::LinkConfigCreate {
            Default::default()
        }
    }

    /// The forward error correction mode of a link.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The forward error correction mode of a link.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Firecode forward error correction.",
    ///      "type": "string",
    ///      "enum": [
    ///        "firecode"
    ///      ]
    ///    },
    ///    {
    ///      "description": "No forward error correction.",
    ///      "type": "string",
    ///      "enum": [
    ///        "none"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Reed-Solomon forward error correction.",
    ///      "type": "string",
    ///      "enum": [
    ///        "rs"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum LinkFec {
        /// Firecode forward error correction.
        #[serde(rename = "firecode")]
        Firecode,
        /// No forward error correction.
        #[serde(rename = "none")]
        None,
        /// Reed-Solomon forward error correction.
        #[serde(rename = "rs")]
        Rs,
    }

    impl ::std::convert::From<&Self> for LinkFec {
        fn from(value: &LinkFec) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkFec {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Firecode => write!(f, "firecode"),
                Self::None => write!(f, "none"),
                Self::Rs => write!(f, "rs"),
            }
        }
    }

    impl ::std::str::FromStr for LinkFec {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "firecode" => Ok(Self::Firecode),
                "none" => Ok(Self::None),
                "rs" => Ok(Self::Rs),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkFec {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkFec {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkFec {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The speed of a link.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The speed of a link.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Zero gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed0_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "1 gigabit per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed1_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "10 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed10_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "25 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed25_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "40 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed40_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "50 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed50_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "100 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed100_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "200 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed200_g"
    ///      ]
    ///    },
    ///    {
    ///      "description": "400 gigabits per second.",
    ///      "type": "string",
    ///      "enum": [
    ///        "speed400_g"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum LinkSpeed {
        /// Zero gigabits per second.
        #[serde(rename = "speed0_g")]
        Speed0G,
        /// 1 gigabit per second.
        #[serde(rename = "speed1_g")]
        Speed1G,
        /// 10 gigabits per second.
        #[serde(rename = "speed10_g")]
        Speed10G,
        /// 25 gigabits per second.
        #[serde(rename = "speed25_g")]
        Speed25G,
        /// 40 gigabits per second.
        #[serde(rename = "speed40_g")]
        Speed40G,
        /// 50 gigabits per second.
        #[serde(rename = "speed50_g")]
        Speed50G,
        /// 100 gigabits per second.
        #[serde(rename = "speed100_g")]
        Speed100G,
        /// 200 gigabits per second.
        #[serde(rename = "speed200_g")]
        Speed200G,
        /// 400 gigabits per second.
        #[serde(rename = "speed400_g")]
        Speed400G,
    }

    impl ::std::convert::From<&Self> for LinkSpeed {
        fn from(value: &LinkSpeed) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for LinkSpeed {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Speed0G => write!(f, "speed0_g"),
                Self::Speed1G => write!(f, "speed1_g"),
                Self::Speed10G => write!(f, "speed10_g"),
                Self::Speed25G => write!(f, "speed25_g"),
                Self::Speed40G => write!(f, "speed40_g"),
                Self::Speed50G => write!(f, "speed50_g"),
                Self::Speed100G => write!(f, "speed100_g"),
                Self::Speed200G => write!(f, "speed200_g"),
                Self::Speed400G => write!(f, "speed400_g"),
            }
        }
    }

    impl ::std::str::FromStr for LinkSpeed {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "speed0_g" => Ok(Self::Speed0G),
                "speed1_g" => Ok(Self::Speed1G),
                "speed10_g" => Ok(Self::Speed10G),
                "speed25_g" => Ok(Self::Speed25G),
                "speed40_g" => Ok(Self::Speed40G),
                "speed50_g" => Ok(Self::Speed50G),
                "speed100_g" => Ok(Self::Speed100G),
                "speed200_g" => Ok(Self::Speed200G),
                "speed400_g" => Ok(Self::Speed400G),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for LinkSpeed {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for LinkSpeed {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for LinkSpeed {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A link layer discovery protocol (LLDP) service configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A link layer discovery protocol (LLDP) service
    /// configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "enabled",
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "chassis_id": {
    ///      "description": "The LLDP chassis identifier TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "enabled": {
    ///      "description": "Whether or not the LLDP service is enabled.",
    ///      "type": "boolean"
    ///    },
    ///    "id": {
    ///      "description": "The id of this LLDP service instance.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "link_description": {
    ///      "description": "The LLDP link description TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "link_name": {
    ///      "description": "The LLDP link name TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "management_ip": {
    ///      "description": "The LLDP management IP TLV.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/IpNet"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "system_description": {
    ///      "description": "The LLDP system description TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "system_name": {
    ///      "description": "The LLDP system name TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LldpLinkConfig {
        /// The LLDP chassis identifier TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chassis_id: ::std::option::Option<::std::string::String>,
        /// Whether or not the LLDP service is enabled.
        pub enabled: bool,
        /// The id of this LLDP service instance.
        pub id: ::uuid::Uuid,
        /// The LLDP link description TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub link_description: ::std::option::Option<::std::string::String>,
        /// The LLDP link name TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub link_name: ::std::option::Option<::std::string::String>,
        /// The LLDP management IP TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub management_ip: ::std::option::Option<IpNet>,
        /// The LLDP system description TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub system_description: ::std::option::Option<::std::string::String>,
        /// The LLDP system name TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub system_name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LldpLinkConfig> for LldpLinkConfig {
        fn from(value: &LldpLinkConfig) -> Self {
            value.clone()
        }
    }

    impl LldpLinkConfig {
        pub fn builder() -> builder::LldpLinkConfig {
            Default::default()
        }
    }

    /// The LLDP configuration associated with a port.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The LLDP configuration associated with a port.",
    ///  "type": "object",
    ///  "required": [
    ///    "enabled"
    ///  ],
    ///  "properties": {
    ///    "chassis_id": {
    ///      "description": "The LLDP chassis identifier TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "enabled": {
    ///      "description": "Whether or not LLDP is enabled.",
    ///      "type": "boolean"
    ///    },
    ///    "link_description": {
    ///      "description": "The LLDP link description TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "link_name": {
    ///      "description": "The LLDP link name TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "management_ip": {
    ///      "description": "The LLDP management IP TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "ip"
    ///    },
    ///    "system_description": {
    ///      "description": "The LLDP system description TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "system_name": {
    ///      "description": "The LLDP system name TLV.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LldpLinkConfigCreate {
        /// The LLDP chassis identifier TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub chassis_id: ::std::option::Option<::std::string::String>,
        /// Whether or not LLDP is enabled.
        pub enabled: bool,
        /// The LLDP link description TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub link_description: ::std::option::Option<::std::string::String>,
        /// The LLDP link name TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub link_name: ::std::option::Option<::std::string::String>,
        /// The LLDP management IP TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub management_ip: ::std::option::Option<::std::net::IpAddr>,
        /// The LLDP system description TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub system_description: ::std::option::Option<::std::string::String>,
        /// The LLDP system name TLV.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub system_name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LldpLinkConfigCreate> for LldpLinkConfigCreate {
        fn from(value: &LldpLinkConfigCreate) -> Self {
            value.clone()
        }
    }

    impl LldpLinkConfigCreate {
        pub fn builder() -> builder::LldpLinkConfigCreate {
            Default::default()
        }
    }

    /// Information about LLDP advertisements from other network entities
    /// directly connected to a switch port.  This structure contains both
    /// metadata about when and where the neighbor was seen, as well as the
    /// specific information the neighbor was advertising.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Information about LLDP advertisements from other
    /// network entities directly connected to a switch port.  This structure
    /// contains both metadata about when and where the neighbor was seen, as
    /// well as the specific information the neighbor was advertising.",
    ///  "type": "object",
    ///  "required": [
    ///    "chassis_id",
    ///    "first_seen",
    ///    "last_seen",
    ///    "link_name",
    ///    "local_port",
    ///    "management_ip"
    ///  ],
    ///  "properties": {
    ///    "chassis_id": {
    ///      "description": "The LLDP chassis identifier advertised by the
    /// neighbor",
    ///      "type": "string"
    ///    },
    ///    "first_seen": {
    ///      "description": "Initial sighting of this LldpNeighbor",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "last_seen": {
    ///      "description": "Most recent sighting of this LldpNeighbor",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "link_description": {
    ///      "description": "The LLDP link description advertised by the
    /// neighbor",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "link_name": {
    ///      "description": "The LLDP link name advertised by the neighbor",
    ///      "type": "string"
    ///    },
    ///    "local_port": {
    ///      "description": "The port on which the neighbor was seen",
    ///      "type": "string"
    ///    },
    ///    "management_ip": {
    ///      "description": "The LLDP management IP(s) advertised by the
    /// neighbor",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ManagementAddress"
    ///      }
    ///    },
    ///    "system_description": {
    ///      "description": "The LLDP system description advertised by the
    /// neighbor",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "system_name": {
    ///      "description": "The LLDP system name advertised by the neighbor",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LldpNeighbor {
        /// The LLDP chassis identifier advertised by the neighbor
        pub chassis_id: ::std::string::String,
        /// Initial sighting of this LldpNeighbor
        pub first_seen: ::chrono::DateTime<::chrono::offset::Utc>,
        /// Most recent sighting of this LldpNeighbor
        pub last_seen: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The LLDP link description advertised by the neighbor
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub link_description: ::std::option::Option<::std::string::String>,
        /// The LLDP link name advertised by the neighbor
        pub link_name: ::std::string::String,
        /// The port on which the neighbor was seen
        pub local_port: ::std::string::String,
        /// The LLDP management IP(s) advertised by the neighbor
        pub management_ip: ::std::vec::Vec<ManagementAddress>,
        /// The LLDP system description advertised by the neighbor
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub system_description: ::std::option::Option<::std::string::String>,
        /// The LLDP system name advertised by the neighbor
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub system_name: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LldpNeighbor> for LldpNeighbor {
        fn from(value: &LldpNeighbor) -> Self {
            value.clone()
        }
    }

    impl LldpNeighbor {
        pub fn builder() -> builder::LldpNeighbor {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LldpNeighbor"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LldpNeighborResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<LldpNeighbor>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LldpNeighborResultsPage> for LldpNeighborResultsPage {
        fn from(value: &LldpNeighborResultsPage) -> Self {
            value.clone()
        }
    }

    impl LldpNeighborResultsPage {
        pub fn builder() -> builder::LldpNeighborResultsPage {
            Default::default()
        }
    }

    /// A loopback address is an address that is assigned to a rack switch but
    /// is not associated with any particular port.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A loopback address is an address that is assigned to a
    /// rack switch but is not associated with any particular port.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "address_lot_block_id",
    ///    "id",
    ///    "rack_id",
    ///    "switch_location"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The loopback IP address and prefix length.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    },
    ///    "address_lot_block_id": {
    ///      "description": "The address lot block this address came from.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "id": {
    ///      "description": "The id of the loopback address.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "rack_id": {
    ///      "description": "The id of the rack where this loopback address is
    /// assigned.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "switch_location": {
    ///      "description": "Switch location where this loopback address is
    /// assigned.",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LoopbackAddress {
        /// The loopback IP address and prefix length.
        pub address: IpNet,
        /// The address lot block this address came from.
        pub address_lot_block_id: ::uuid::Uuid,
        /// The id of the loopback address.
        pub id: ::uuid::Uuid,
        /// The id of the rack where this loopback address is assigned.
        pub rack_id: ::uuid::Uuid,
        /// Switch location where this loopback address is assigned.
        pub switch_location: ::std::string::String,
    }

    impl ::std::convert::From<&LoopbackAddress> for LoopbackAddress {
        fn from(value: &LoopbackAddress) -> Self {
            value.clone()
        }
    }

    impl LoopbackAddress {
        pub fn builder() -> builder::LoopbackAddress {
            Default::default()
        }
    }

    /// Parameters for creating a loopback address on a particular rack switch.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating a loopback address on a
    /// particular rack switch.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "address_lot",
    ///    "anycast",
    ///    "mask",
    ///    "rack_id",
    ///    "switch_location"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The address to create.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "address_lot": {
    ///      "description": "The name or id of the address lot this loopback
    /// address will pull an address from.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    },
    ///    "anycast": {
    ///      "description": "Address is an anycast address. This allows the
    /// address to be assigned to multiple locations simultaneously.",
    ///      "type": "boolean"
    ///    },
    ///    "mask": {
    ///      "description": "The subnet mask to use for the address.",
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "rack_id": {
    ///      "description": "The containing the switch this loopback address
    /// will be configured on.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "switch_location": {
    ///      "description": "The location of the switch within the rack this
    /// loopback address will be configured on.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LoopbackAddressCreate {
        /// The address to create.
        pub address: ::std::net::IpAddr,
        /// The name or id of the address lot this loopback address will pull an
        /// address from.
        pub address_lot: NameOrId,
        /// Address is an anycast address. This allows the address to be
        /// assigned to multiple locations simultaneously.
        pub anycast: bool,
        /// The subnet mask to use for the address.
        pub mask: u8,
        /// The containing the switch this loopback address will be configured
        /// on.
        pub rack_id: ::uuid::Uuid,
        /// The location of the switch within the rack this loopback address
        /// will be configured on.
        pub switch_location: Name,
    }

    impl ::std::convert::From<&LoopbackAddressCreate> for LoopbackAddressCreate {
        fn from(value: &LoopbackAddressCreate) -> Self {
            value.clone()
        }
    }

    impl LoopbackAddressCreate {
        pub fn builder() -> builder::LoopbackAddressCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LoopbackAddress"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct LoopbackAddressResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<LoopbackAddress>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&LoopbackAddressResultsPage> for LoopbackAddressResultsPage {
        fn from(value: &LoopbackAddressResultsPage) -> Self {
            value.clone()
        }
    }

    impl LoopbackAddressResultsPage {
        pub fn builder() -> builder::LoopbackAddressResultsPage {
            Default::default()
        }
    }

    /// A Media Access Control address, in EUI-48 format
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A MAC address",
    ///  "description": "A Media Access Control address, in EUI-48 format",
    ///  "examples": [
    ///    "ff:ff:ff:ff:ff:ff"
    ///  ],
    ///  "type": "string",
    ///  "maxLength": 17,
    ///  "minLength": 5,
    ///  "pattern": "^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct MacAddr(::std::string::String);
    impl ::std::ops::Deref for MacAddr {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<MacAddr> for ::std::string::String {
        fn from(value: MacAddr) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&MacAddr> for MacAddr {
        fn from(value: &MacAddr) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for MacAddr {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 17usize {
                return Err("longer than 17 characters".into());
            }
            if value.chars().count() < 5usize {
                return Err("shorter than 5 characters".into());
            }
            if regress::Regex::new("^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err(
                    "doesn't match pattern \"^([0-9a-fA-F]{0,2}:){5}[0-9a-fA-F]{0,2}$\"".into(),
                );
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MacAddr {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for MacAddr {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// `ManagementAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "addr",
    ///    "interface_num"
    ///  ],
    ///  "properties": {
    ///    "addr": {
    ///      "$ref": "#/components/schemas/NetworkAddress"
    ///    },
    ///    "interface_num": {
    ///      "$ref": "#/components/schemas/InterfaceNum"
    ///    },
    ///    "oid": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint8",
    ///        "minimum": 0.0
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ManagementAddress {
        pub addr: NetworkAddress,
        pub interface_num: InterfaceNum,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub oid: ::std::option::Option<::std::vec::Vec<u8>>,
    }

    impl ::std::convert::From<&ManagementAddress> for ManagementAddress {
        fn from(value: &ManagementAddress) -> Self {
            value.clone()
        }
    }

    impl ManagementAddress {
        pub fn builder() -> builder::ManagementAddress {
            Default::default()
        }
    }

    /// A `Measurement` is a timestamped datum from a single metric
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A `Measurement` is a timestamped datum from a single
    /// metric",
    ///  "type": "object",
    ///  "required": [
    ///    "datum",
    ///    "timestamp"
    ///  ],
    ///  "properties": {
    ///    "datum": {
    ///      "$ref": "#/components/schemas/Datum"
    ///    },
    ///    "timestamp": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Measurement {
        pub datum: Datum,
        pub timestamp: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Measurement> for Measurement {
        fn from(value: &Measurement) -> Self {
            value.clone()
        }
    }

    impl Measurement {
        pub fn builder() -> builder::Measurement {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Measurement"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct MeasurementResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Measurement>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&MeasurementResultsPage> for MeasurementResultsPage {
        fn from(value: &MeasurementResultsPage) -> Self {
            value.clone()
        }
    }

    impl MeasurementResultsPage {
        pub fn builder() -> builder::MeasurementResultsPage {
            Default::default()
        }
    }

    /// The type of the metric itself, indicating what its values represent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The type of the metric itself, indicating what its
    /// values represent.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The value represents an instantaneous measurement
    /// in time.",
    ///      "type": "string",
    ///      "enum": [
    ///        "gauge"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The value represents a difference between two
    /// points in time.",
    ///      "type": "string",
    ///      "enum": [
    ///        "delta"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The value represents an accumulation between two
    /// points in time.",
    ///      "type": "string",
    ///      "enum": [
    ///        "cumulative"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum MetricType {
        /// The value represents an instantaneous measurement in time.
        #[serde(rename = "gauge")]
        Gauge,
        /// The value represents a difference between two points in time.
        #[serde(rename = "delta")]
        Delta,
        /// The value represents an accumulation between two points in time.
        #[serde(rename = "cumulative")]
        Cumulative,
    }

    impl ::std::convert::From<&Self> for MetricType {
        fn from(value: &MetricType) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for MetricType {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Gauge => write!(f, "gauge"),
                Self::Delta => write!(f, "delta"),
                Self::Cumulative => write!(f, "cumulative"),
            }
        }
    }

    impl ::std::str::FromStr for MetricType {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "gauge" => Ok(Self::Gauge),
                "delta" => Ok(Self::Delta),
                "cumulative" => Ok(Self::Cumulative),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for MetricType {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for MetricType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for MetricType {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `MissingDatum`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "datum_type"
    ///  ],
    ///  "properties": {
    ///    "datum_type": {
    ///      "$ref": "#/components/schemas/DatumType"
    ///    },
    ///    "start_time": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct MissingDatum {
        pub datum_type: DatumType,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub start_time: ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
    }

    impl ::std::convert::From<&MissingDatum> for MissingDatum {
        fn from(value: &MissingDatum) -> Self {
            value.clone()
        }
    }

    impl MissingDatum {
        pub fn builder() -> builder::MissingDatum {
            Default::default()
        }
    }

    /// Names must begin with a lower case ASCII letter, be composed exclusively
    /// of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end
    /// with a '-'. Names cannot be a UUID, but they may contain a UUID. They
    /// can be at most 63 characters long.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A name unique within the parent collection",
    ///  "description": "Names must begin with a lower case ASCII letter, be
    /// composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and
    /// '-', and may not end with a '-'. Names cannot be a UUID, but they may
    /// contain a UUID. They can be at most 63 characters long.",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "minLength": 1,
    ///  "pattern":
    /// "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*
    /// [a-zA-Z0-9]+)?$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct Name(::std::string::String);
    impl ::std::ops::Deref for Name {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Name> for ::std::string::String {
        fn from(value: Name) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Name> for Name {
        fn from(value: &Name) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Name {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 63usize {
                return Err("longer than 63 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            if regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Name {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Name {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Name {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Name {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// `NameOrId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "title": "id",
    ///      "allOf": [
    ///        {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        }
    ///      ]
    ///    },
    ///    {
    ///      "title": "name",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(untagged)]
    pub enum NameOrId {
        Id(::uuid::Uuid),
        Name(Name),
    }

    impl ::std::convert::From<&Self> for NameOrId {
        fn from(value: &NameOrId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for NameOrId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if let Ok(v) = value.parse() {
                Ok(Self::Id(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Name(v))
            } else {
                Err("string conversion failed for all variants".into())
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for NameOrId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for NameOrId {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match self {
                Self::Id(x) => x.fmt(f),
                Self::Name(x) => x.fmt(f),
            }
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for NameOrId {
        fn from(value: ::uuid::Uuid) -> Self {
            Self::Id(value)
        }
    }

    impl ::std::convert::From<Name> for NameOrId {
        fn from(value: Name) -> Self {
            Self::Name(value)
        }
    }

    /// Supported set of sort modes for scanning by name or id
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Supported set of sort modes for scanning by name or
    /// id",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_ascending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in decreasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_descending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in increasing order of \"id\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "id_ascending"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum NameOrIdSortMode {
        /// sort in increasing order of "name"
        #[serde(rename = "name_ascending")]
        NameAscending,
        /// sort in decreasing order of "name"
        #[serde(rename = "name_descending")]
        NameDescending,
        /// sort in increasing order of "id"
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl ::std::convert::From<&Self> for NameOrIdSortMode {
        fn from(value: &NameOrIdSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for NameOrIdSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NameAscending => write!(f, "name_ascending"),
                Self::NameDescending => write!(f, "name_descending"),
                Self::IdAscending => write!(f, "id_ascending"),
            }
        }
    }

    impl ::std::str::FromStr for NameOrIdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                "name_descending" => Ok(Self::NameDescending),
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for NameOrIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Supported set of sort modes for scanning by name only
    ///
    /// Currently, we only support scanning in ascending order.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Supported set of sort modes for scanning by name
    /// only\n\nCurrently, we only support scanning in ascending order.",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of \"name\"",
    ///      "type": "string",
    ///      "enum": [
    ///        "name_ascending"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum NameSortMode {
        /// sort in increasing order of "name"
        #[serde(rename = "name_ascending")]
        NameAscending,
    }

    impl ::std::convert::From<&Self> for NameSortMode {
        fn from(value: &NameSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for NameSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::NameAscending => write!(f, "name_ascending"),
            }
        }
    }

    impl ::std::str::FromStr for NameSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for NameSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `NetworkAddress`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "ip_addr"
    ///      ],
    ///      "properties": {
    ///        "ip_addr": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "i_e_e_e802"
    ///      ],
    ///      "properties": {
    ///        "i_e_e_e802": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": "integer",
    ///            "format": "uint8",
    ///            "minimum": 0.0
    ///          }
    ///        }
    ///      },
    ///      "additionalProperties": false
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub enum NetworkAddress {
        #[serde(rename = "ip_addr")]
        IpAddr(::std::net::IpAddr),
        #[serde(rename = "i_e_e_e802")]
        IEEE802(::std::vec::Vec<u8>),
    }

    impl ::std::convert::From<&Self> for NetworkAddress {
        fn from(value: &NetworkAddress) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for NetworkAddress {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::IpAddr(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<u8>> for NetworkAddress {
        fn from(value: ::std::vec::Vec<u8>) -> Self {
            Self::IEEE802(value)
        }
    }

    /// Information required to construct a virtual network interface
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Information required to construct a virtual network
    /// interface",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "ip",
    ///    "kind",
    ///    "mac",
    ///    "name",
    ///    "primary",
    ///    "slot",
    ///    "subnet",
    ///    "vni"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ip": {
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/NetworkInterfaceKind"
    ///    },
    ///    "mac": {
    ///      "$ref": "#/components/schemas/MacAddr"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "primary": {
    ///      "type": "boolean"
    ///    },
    ///    "slot": {
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "subnet": {
    ///      "$ref": "#/components/schemas/IpNet"
    ///    },
    ///    "transit_ips": {
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/IpNet"
    ///      }
    ///    },
    ///    "vni": {
    ///      "$ref": "#/components/schemas/Vni"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct NetworkInterface {
        pub id: ::uuid::Uuid,
        pub ip: ::std::net::IpAddr,
        pub kind: NetworkInterfaceKind,
        pub mac: MacAddr,
        pub name: Name,
        pub primary: bool,
        pub slot: u8,
        pub subnet: IpNet,
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub transit_ips: ::std::vec::Vec<IpNet>,
        pub vni: Vni,
    }

    impl ::std::convert::From<&NetworkInterface> for NetworkInterface {
        fn from(value: &NetworkInterface) -> Self {
            value.clone()
        }
    }

    impl NetworkInterface {
        pub fn builder() -> builder::NetworkInterface {
            Default::default()
        }
    }

    /// The type of network interface
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The type of network interface",
    ///  "oneOf": [
    ///    {
    ///      "description": "A vNIC attached to a guest instance",
    ///      "type": "object",
    ///      "required": [
    ///        "id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A vNIC associated with an internal service",
    ///      "type": "object",
    ///      "required": [
    ///        "id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "service"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "A vNIC associated with a probe",
    ///      "type": "object",
    ///      "required": [
    ///        "id",
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "id": {
    ///          "type": "string",
    ///          "format": "uuid"
    ///        },
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "probe"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "id")]
    pub enum NetworkInterfaceKind {
        /// A vNIC attached to a guest instance
        #[serde(rename = "instance")]
        Instance(::uuid::Uuid),
        /// A vNIC associated with an internal service
        #[serde(rename = "service")]
        Service(::uuid::Uuid),
        /// A vNIC associated with a probe
        #[serde(rename = "probe")]
        Probe(::uuid::Uuid),
    }

    impl ::std::convert::From<&Self> for NetworkInterfaceKind {
        fn from(value: &NetworkInterfaceKind) -> Self {
            value.clone()
        }
    }

    /// The result of a successful OxQL query.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The result of a successful OxQL query.",
    ///  "type": "object",
    ///  "required": [
    ///    "tables"
    ///  ],
    ///  "properties": {
    ///    "tables": {
    ///      "description": "Tables resulting from the query, each containing
    /// timeseries.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Table"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct OxqlQueryResult {
        /// Tables resulting from the query, each containing timeseries.
        pub tables: ::std::vec::Vec<Table>,
    }

    impl ::std::convert::From<&OxqlQueryResult> for OxqlQueryResult {
        fn from(value: &OxqlQueryResult) -> Self {
            value.clone()
        }
    }

    impl OxqlQueryResult {
        pub fn builder() -> builder::OxqlQueryResult {
            Default::default()
        }
    }

    /// The order in which the client wants to page through the requested
    /// collection
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The order in which the client wants to page through the
    /// requested collection",
    ///  "type": "string",
    ///  "enum": [
    ///    "ascending",
    ///    "descending"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum PaginationOrder {
        #[serde(rename = "ascending")]
        Ascending,
        #[serde(rename = "descending")]
        Descending,
    }

    impl ::std::convert::From<&Self> for PaginationOrder {
        fn from(value: &PaginationOrder) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PaginationOrder {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ascending => write!(f, "ascending"),
                Self::Descending => write!(f, "descending"),
            }
        }
    }

    impl ::std::str::FromStr for PaginationOrder {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ascending" => Ok(Self::Ascending),
                "descending" => Ok(Self::Descending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PaginationOrder {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PaginationOrder {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PaginationOrder {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Passwords may be subject to additional constraints.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A password used to authenticate a user",
    ///  "description": "Passwords may be subject to additional constraints.",
    ///  "type": "string",
    ///  "maxLength": 512
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct Password(::std::string::String);
    impl ::std::ops::Deref for Password {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<Password> for ::std::string::String {
        fn from(value: Password) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Password> for Password {
        fn from(value: &Password) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for Password {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 512usize {
                return Err("longer than 512 characters".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for Password {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Password {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Password {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for Password {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// View of a Physical Disk
    ///
    /// Physical disks reside in a particular sled and are used to store both
    /// Instance Disk data as well as internal metadata.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Physical Disk\n\nPhysical disks reside in a
    /// particular sled and are used to store both Instance Disk data as well as
    /// internal metadata.",
    ///  "type": "object",
    ///  "required": [
    ///    "form_factor",
    ///    "id",
    ///    "model",
    ///    "policy",
    ///    "serial",
    ///    "state",
    ///    "time_created",
    ///    "time_modified",
    ///    "vendor"
    ///  ],
    ///  "properties": {
    ///    "form_factor": {
    ///      "$ref": "#/components/schemas/PhysicalDiskKind"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "model": {
    ///      "type": "string"
    ///    },
    ///    "policy": {
    ///      "description": "The operator-defined policy for a physical disk.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/PhysicalDiskPolicy"
    ///        }
    ///      ]
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    },
    ///    "sled_id": {
    ///      "description": "The sled to which this disk is attached, if any.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "description": "The current state Nexus believes the disk to be
    /// in.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/PhysicalDiskState"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vendor": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct PhysicalDisk {
        pub form_factor: PhysicalDiskKind,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub model: ::std::string::String,
        /// The operator-defined policy for a physical disk.
        pub policy: PhysicalDiskPolicy,
        pub serial: ::std::string::String,
        /// The sled to which this disk is attached, if any.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub sled_id: ::std::option::Option<::uuid::Uuid>,
        /// The current state Nexus believes the disk to be in.
        pub state: PhysicalDiskState,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        pub vendor: ::std::string::String,
    }

    impl ::std::convert::From<&PhysicalDisk> for PhysicalDisk {
        fn from(value: &PhysicalDisk) -> Self {
            value.clone()
        }
    }

    impl PhysicalDisk {
        pub fn builder() -> builder::PhysicalDisk {
            Default::default()
        }
    }

    /// Describes the form factor of physical disks.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes the form factor of physical disks.",
    ///  "type": "string",
    ///  "enum": [
    ///    "m2",
    ///    "u2"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum PhysicalDiskKind {
        #[serde(rename = "m2")]
        M2,
        #[serde(rename = "u2")]
        U2,
    }

    impl ::std::convert::From<&Self> for PhysicalDiskKind {
        fn from(value: &PhysicalDiskKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PhysicalDiskKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::M2 => write!(f, "m2"),
                Self::U2 => write!(f, "u2"),
            }
        }
    }

    impl ::std::str::FromStr for PhysicalDiskKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "m2" => Ok(Self::M2),
                "u2" => Ok(Self::U2),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PhysicalDiskKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PhysicalDiskKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PhysicalDiskKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The operator-defined policy of a physical disk.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The operator-defined policy of a physical disk.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The operator has indicated that the disk is
    /// in-service.",
    ///      "type": "object",
    ///      "required": [
    ///        "kind"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "in_service"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The operator has indicated that the disk has been
    /// permanently removed from service.\n\nThis is a terminal state: once a
    /// particular disk ID is expunged, it will never return to service. (The
    /// actual hardware may be reused, but it will be treated as a brand-new
    /// disk.)\n\nAn expunged disk is always non-provisionable.",
    ///      "type": "object",
    ///      "required": [
    ///        "kind"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "expunged"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(tag = "kind")]
    pub enum PhysicalDiskPolicy {
        #[serde(rename = "in_service")]
        InService,
        #[serde(rename = "expunged")]
        Expunged,
    }

    impl ::std::convert::From<&Self> for PhysicalDiskPolicy {
        fn from(value: &PhysicalDiskPolicy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PhysicalDiskPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::InService => write!(f, "in_service"),
                Self::Expunged => write!(f, "expunged"),
            }
        }
    }

    impl ::std::str::FromStr for PhysicalDiskPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "in_service" => Ok(Self::InService),
                "expunged" => Ok(Self::Expunged),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PhysicalDiskPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PhysicalDiskPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PhysicalDiskPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/PhysicalDisk"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct PhysicalDiskResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<PhysicalDisk>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&PhysicalDiskResultsPage> for PhysicalDiskResultsPage {
        fn from(value: &PhysicalDiskResultsPage) -> Self {
            value.clone()
        }
    }

    impl PhysicalDiskResultsPage {
        pub fn builder() -> builder::PhysicalDiskResultsPage {
            Default::default()
        }
    }

    /// The current state of the disk, as determined by Nexus.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The current state of the disk, as determined by
    /// Nexus.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The disk is currently active, and has resources
    /// allocated on it.",
    ///      "type": "string",
    ///      "enum": [
    ///        "active"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The disk has been permanently removed from
    /// service.\n\nThis is a terminal state: once a particular disk ID is
    /// decommissioned, it will never return to service. (The actual hardware
    /// may be reused, but it will be treated as a brand-new disk.)",
    ///      "type": "string",
    ///      "enum": [
    ///        "decommissioned"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum PhysicalDiskState {
        /// The disk is currently active, and has resources allocated on it.
        #[serde(rename = "active")]
        Active,
        /// The disk has been permanently removed from service.
        ///
        /// This is a terminal state: once a particular disk ID is
        /// decommissioned, it will never return to service. (The actual
        /// hardware may be reused, but it will be treated as a brand-new disk.)
        #[serde(rename = "decommissioned")]
        Decommissioned,
    }

    impl ::std::convert::From<&Self> for PhysicalDiskState {
        fn from(value: &PhysicalDiskState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PhysicalDiskState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "active"),
                Self::Decommissioned => write!(f, "decommissioned"),
            }
        }
    }

    impl ::std::str::FromStr for PhysicalDiskState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "active" => Ok(Self::Active),
                "decommissioned" => Ok(Self::Decommissioned),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PhysicalDiskState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PhysicalDiskState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PhysicalDiskState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `Ping`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "status": {
    ///      "description": "Whether the external API is reachable. Will always
    /// be Ok if the endpoint returns anything at all.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/PingStatus"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Ping {
        /// Whether the external API is reachable. Will always be Ok if the
        /// endpoint returns anything at all.
        pub status: PingStatus,
    }

    impl ::std::convert::From<&Ping> for Ping {
        fn from(value: &Ping) -> Self {
            value.clone()
        }
    }

    impl Ping {
        pub fn builder() -> builder::Ping {
            Default::default()
        }
    }

    /// `PingStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "ok"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum PingStatus {
        #[serde(rename = "ok")]
        Ok,
    }

    impl ::std::convert::From<&Self> for PingStatus {
        fn from(value: &PingStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for PingStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ok => write!(f, "ok"),
            }
        }
    }

    impl ::std::str::FromStr for PingStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ok" => Ok(Self::Ok),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for PingStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for PingStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for PingStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Timepoints and values for one timeseries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Timepoints and values for one timeseries.",
    ///  "type": "object",
    ///  "required": [
    ///    "timestamps",
    ///    "values"
    ///  ],
    ///  "properties": {
    ///    "start_times": {
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "type": "string",
    ///        "format": "date-time"
    ///      }
    ///    },
    ///    "timestamps": {
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string",
    ///        "format": "date-time"
    ///      }
    ///    },
    ///    "values": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Values"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Points {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub start_times:
            ::std::option::Option<::std::vec::Vec<::chrono::DateTime<::chrono::offset::Utc>>>,
        pub timestamps: ::std::vec::Vec<::chrono::DateTime<::chrono::offset::Utc>>,
        pub values: ::std::vec::Vec<Values>,
    }

    impl ::std::convert::From<&Points> for Points {
        fn from(value: &Points) -> Self {
            value.clone()
        }
    }

    impl Points {
        pub fn builder() -> builder::Points {
            Default::default()
        }
    }

    /// Identity-related metadata that's included in nearly all public API
    /// objects
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Identity-related metadata that's included in nearly all
    /// public API objects",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "sled",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "sled": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Probe {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub sled: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Probe> for Probe {
        fn from(value: &Probe) -> Self {
            value.clone()
        }
    }

    impl Probe {
        pub fn builder() -> builder::Probe {
            Default::default()
        }
    }

    /// Create time parameters for probes.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create time parameters for probes.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "sled"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ip_pool": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/NameOrId"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "sled": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProbeCreate {
        pub description: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ip_pool: ::std::option::Option<NameOrId>,
        pub name: Name,
        pub sled: ::uuid::Uuid,
    }

    impl ::std::convert::From<&ProbeCreate> for ProbeCreate {
        fn from(value: &ProbeCreate) -> Self {
            value.clone()
        }
    }

    impl ProbeCreate {
        pub fn builder() -> builder::ProbeCreate {
            Default::default()
        }
    }

    /// `ProbeExternalIp`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "first_port",
    ///    "ip",
    ///    "kind",
    ///    "last_port"
    ///  ],
    ///  "properties": {
    ///    "first_port": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "ip": {
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/ProbeExternalIpKind"
    ///    },
    ///    "last_port": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProbeExternalIp {
        pub first_port: u16,
        pub ip: ::std::net::IpAddr,
        pub kind: ProbeExternalIpKind,
        pub last_port: u16,
    }

    impl ::std::convert::From<&ProbeExternalIp> for ProbeExternalIp {
        fn from(value: &ProbeExternalIp) -> Self {
            value.clone()
        }
    }

    impl ProbeExternalIp {
        pub fn builder() -> builder::ProbeExternalIp {
            Default::default()
        }
    }

    /// `ProbeExternalIpKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "snat",
    ///    "floating",
    ///    "ephemeral"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum ProbeExternalIpKind {
        #[serde(rename = "snat")]
        Snat,
        #[serde(rename = "floating")]
        Floating,
        #[serde(rename = "ephemeral")]
        Ephemeral,
    }

    impl ::std::convert::From<&Self> for ProbeExternalIpKind {
        fn from(value: &ProbeExternalIpKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ProbeExternalIpKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Snat => write!(f, "snat"),
                Self::Floating => write!(f, "floating"),
                Self::Ephemeral => write!(f, "ephemeral"),
            }
        }
    }

    impl ::std::str::FromStr for ProbeExternalIpKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "snat" => Ok(Self::Snat),
                "floating" => Ok(Self::Floating),
                "ephemeral" => Ok(Self::Ephemeral),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ProbeExternalIpKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ProbeExternalIpKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ProbeExternalIpKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `ProbeInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "external_ips",
    ///    "id",
    ///    "interface",
    ///    "name",
    ///    "sled"
    ///  ],
    ///  "properties": {
    ///    "external_ips": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ProbeExternalIp"
    ///      }
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "interface": {
    ///      "$ref": "#/components/schemas/NetworkInterface"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "sled": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProbeInfo {
        pub external_ips: ::std::vec::Vec<ProbeExternalIp>,
        pub id: ::uuid::Uuid,
        pub interface: NetworkInterface,
        pub name: Name,
        pub sled: ::uuid::Uuid,
    }

    impl ::std::convert::From<&ProbeInfo> for ProbeInfo {
        fn from(value: &ProbeInfo) -> Self {
            value.clone()
        }
    }

    impl ProbeInfo {
        pub fn builder() -> builder::ProbeInfo {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ProbeInfo"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProbeInfoResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<ProbeInfo>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ProbeInfoResultsPage> for ProbeInfoResultsPage {
        fn from(value: &ProbeInfoResultsPage) -> Self {
            value.clone()
        }
    }

    impl ProbeInfoResultsPage {
        pub fn builder() -> builder::ProbeInfoResultsPage {
            Default::default()
        }
    }

    /// View of a Project
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Project",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Project {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Project> for Project {
        fn from(value: &Project) -> Self {
            value.clone()
        }
    }

    impl Project {
        pub fn builder() -> builder::Project {
            Default::default()
        }
    }

    /// Create-time parameters for a `Project`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `Project`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProjectCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&ProjectCreate> for ProjectCreate {
        fn from(value: &ProjectCreate) -> Self {
            value.clone()
        }
    }

    impl ProjectCreate {
        pub fn builder() -> builder::ProjectCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Project"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProjectResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Project>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&ProjectResultsPage> for ProjectResultsPage {
        fn from(value: &ProjectResultsPage) -> Self {
            value.clone()
        }
    }

    impl ProjectResultsPage {
        pub fn builder() -> builder::ProjectResultsPage {
            Default::default()
        }
    }

    /// `ProjectRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum ProjectRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for ProjectRole {
        fn from(value: &ProjectRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ProjectRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for ProjectRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ProjectRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Policy for a particular resource
    ///
    /// Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Policy for a particular resource\n\nNote that the
    /// Policy only describes access granted explicitly for this resource.  The
    /// policies of parent resources can also cause a user to have access to
    /// this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ProjectRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProjectRolePolicy {
        /// Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<ProjectRoleRoleAssignment>,
    }

    impl ::std::convert::From<&ProjectRolePolicy> for ProjectRolePolicy {
        fn from(value: &ProjectRolePolicy) -> Self {
            value.clone()
        }
    }

    impl ProjectRolePolicy {
        pub fn builder() -> builder::ProjectRolePolicy {
            Default::default()
        }
    }

    /// Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    /// The resource is not part of this structure.  Rather, `RoleAssignment`s
    /// are put into a `Policy` and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, `RoleAssignment`s are
    /// put into a `Policy` and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/ProjectRole"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProjectRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: ProjectRole,
    }

    impl ::std::convert::From<&ProjectRoleRoleAssignment> for ProjectRoleRoleAssignment {
        fn from(value: &ProjectRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl ProjectRoleRoleAssignment {
        pub fn builder() -> builder::ProjectRoleRoleAssignment {
            Default::default()
        }
    }

    /// Updateable properties of a `Project`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of a `Project`",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&ProjectUpdate> for ProjectUpdate {
        fn from(value: &ProjectUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for ProjectUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl ProjectUpdate {
        pub fn builder() -> builder::ProjectUpdate {
            Default::default()
        }
    }

    /// Structure for estimating the p-quantile of a population.
    ///
    /// This is based on the P algorithm for estimating quantiles using
    /// constant space.
    ///
    /// The algorithm consists of maintaining five markers: the minimum, the
    /// p/2-, p-, and (1 + p)/2 quantiles, and the maximum.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Structure for estimating the p-quantile of a
    /// population.\n\nThis is based on the P algorithm for estimating
    /// quantiles using constant space.\n\nThe algorithm consists of maintaining
    /// five markers: the minimum, the p/2-, p-, and (1 + p)/2 quantiles, and
    /// the maximum.",
    ///  "type": "object",
    ///  "required": [
    ///    "desired_marker_positions",
    ///    "marker_heights",
    ///    "marker_positions",
    ///    "p"
    ///  ],
    ///  "properties": {
    ///    "desired_marker_positions": {
    ///      "description": "The desired marker positions.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "number",
    ///        "format": "double"
    ///      },
    ///      "maxItems": 5,
    ///      "minItems": 5
    ///    },
    ///    "marker_heights": {
    ///      "description": "The heights of the markers.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "number",
    ///        "format": "double"
    ///      },
    ///      "maxItems": 5,
    ///      "minItems": 5
    ///    },
    ///    "marker_positions": {
    ///      "description": "The positions of the markers.\n\nWe track sample
    /// size in the 5th position, as useful observations won't start until we've
    /// filled the heights at the 6th sample anyway This does deviate from the
    /// paper, but it's a more useful representation that works according to the
    /// paper's algorithm.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "integer",
    ///        "format": "uint64",
    ///        "minimum": 0.0
    ///      },
    ///      "maxItems": 5,
    ///      "minItems": 5
    ///    },
    ///    "p": {
    ///      "description": "The p value for the quantile.",
    ///      "type": "number",
    ///      "format": "double"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Quantile {
        /// The desired marker positions.
        pub desired_marker_positions: [f64; 5usize],
        /// The heights of the markers.
        pub marker_heights: [f64; 5usize],
        /// The positions of the markers.
        ///
        /// We track sample size in the 5th position, as useful observations
        /// won't start until we've filled the heights at the 6th sample anyway
        /// This does deviate from the paper, but it's a more useful
        /// representation that works according to the paper's algorithm.
        pub marker_positions: [u64; 5usize],
        pub p: f64,
    }

    impl ::std::convert::From<&Quantile> for Quantile {
        fn from(value: &Quantile) -> Self {
            value.clone()
        }
    }

    impl Quantile {
        pub fn builder() -> builder::Quantile {
            Default::default()
        }
    }

    /// View of an Rack
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an Rack",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Rack {
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Rack> for Rack {
        fn from(value: &Rack) -> Self {
            value.clone()
        }
    }

    impl Rack {
        pub fn builder() -> builder::Rack {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Rack"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RackResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Rack>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RackResultsPage> for RackResultsPage {
        fn from(value: &RackResultsPage) -> Self {
            value.clone()
        }
    }

    impl RackResultsPage {
        pub fn builder() -> builder::RackResultsPage {
            Default::default()
        }
    }

    /// View of a Role
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Role",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/RoleName"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Role {
        pub description: ::std::string::String,
        pub name: RoleName,
    }

    impl ::std::convert::From<&Role> for Role {
        fn from(value: &Role) -> Self {
            value.clone()
        }
    }

    impl Role {
        pub fn builder() -> builder::Role {
            Default::default()
        }
    }

    /// Role names consist of two string components separated by dot (".").
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A name for a built-in role",
    ///  "description": "Role names consist of two string components separated
    /// by dot (\".\").",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "pattern": "[a-z-]+\\.[a-z-]+"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct RoleName(::std::string::String);
    impl ::std::ops::Deref for RoleName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<RoleName> for ::std::string::String {
        fn from(value: RoleName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&RoleName> for RoleName {
        fn from(value: &RoleName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for RoleName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 63usize {
                return Err("longer than 63 characters".into());
            }
            if regress::Regex::new("[a-z-]+\\.[a-z-]+")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"[a-z-]+\\.[a-z-]+\"".into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RoleName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for RoleName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Role"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RoleResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Role>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RoleResultsPage> for RoleResultsPage {
        fn from(value: &RoleResultsPage) -> Self {
            value.clone()
        }
    }

    impl RoleResultsPage {
        pub fn builder() -> builder::RoleResultsPage {
            Default::default()
        }
    }

    /// A route to a destination network through a gateway address.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A route to a destination network through a gateway
    /// address.",
    ///  "type": "object",
    ///  "required": [
    ///    "dst",
    ///    "gw"
    ///  ],
    ///  "properties": {
    ///    "dst": {
    ///      "description": "The route destination.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    },
    ///    "gw": {
    ///      "description": "The route gateway.",
    ///      "type": "string",
    ///      "format": "ip"
    ///    },
    ///    "rib_priority": {
    ///      "description": "Local preference for route. Higher preference
    /// indictes precedence within and across protocols.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "vid": {
    ///      "description": "VLAN id the gateway is reachable over.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Route {
        /// The route destination.
        pub dst: IpNet,
        /// The route gateway.
        pub gw: ::std::net::IpAddr,
        /// Local preference for route. Higher preference indictes precedence
        /// within and across protocols.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rib_priority: ::std::option::Option<u8>,
        /// VLAN id the gateway is reachable over.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vid: ::std::option::Option<u16>,
    }

    impl ::std::convert::From<&Route> for Route {
        fn from(value: &Route) -> Self {
            value.clone()
        }
    }

    impl Route {
        pub fn builder() -> builder::Route {
            Default::default()
        }
    }

    /// Route configuration data associated with a switch port configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Route configuration data associated with a switch port
    /// configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "routes"
    ///  ],
    ///  "properties": {
    ///    "routes": {
    ///      "description": "The set of routes assigned to a switch port.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Route"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RouteConfig {
        /// The set of routes assigned to a switch port.
        pub routes: ::std::vec::Vec<Route>,
    }

    impl ::std::convert::From<&RouteConfig> for RouteConfig {
        fn from(value: &RouteConfig) -> Self {
            value.clone()
        }
    }

    impl RouteConfig {
        pub fn builder() -> builder::RouteConfig {
            Default::default()
        }
    }

    /// A `RouteDestination` is used to match traffic with a routing rule based
    /// on the destination of that traffic.
    ///
    /// When traffic is to be sent to a destination that is within a given
    /// `RouteDestination`, the corresponding `RouterRoute` applies, and traffic
    /// will be forward to the `RouteTarget` for that rule.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A `RouteDestination` is used to match traffic with a
    /// routing rule based on the destination of that traffic.\n\nWhen traffic
    /// is to be sent to a destination that is within a given
    /// `RouteDestination`, the corresponding `RouterRoute` applies, and traffic
    /// will be forward to the `RouteTarget` for that rule.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Route applies to traffic destined for the specified
    /// IP address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for the specified
    /// IP subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for the specified
    /// VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Route applies to traffic destined for the specified
    /// VPC subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        /// Route applies to traffic destined for the specified IP address
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        /// Route applies to traffic destined for the specified IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
        /// Route applies to traffic destined for the specified VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        /// Route applies to traffic destined for the specified VPC subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    impl ::std::convert::From<&Self> for RouteDestination {
        fn from(value: &RouteDestination) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for RouteDestination {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl ::std::convert::From<IpNet> for RouteDestination {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    /// A `RouteTarget` describes the possible locations that traffic matching a
    /// route destination can be sent.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A `RouteTarget` describes the possible locations that
    /// traffic matching a route destination can be sent.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Forward traffic to a particular IP address.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a VPC Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to a specific instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Forward traffic to an internet gateway",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "internet_gateway"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Drop matching traffic",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "drop"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        /// Forward traffic to a particular IP address.
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        /// Forward traffic to a VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        /// Forward traffic to a VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        /// Forward traffic to a specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        /// Forward traffic to an internet gateway
        #[serde(rename = "internet_gateway")]
        InternetGateway(Name),
        #[serde(rename = "drop")]
        Drop,
    }

    impl ::std::convert::From<&Self> for RouteTarget {
        fn from(value: &RouteTarget) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for RouteTarget {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    /// A route defines a rule that governs where traffic should be sent based
    /// on its destination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A route defines a rule that governs where traffic
    /// should be sent based on its destination.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "destination",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "target",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_router_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "description": "Selects which traffic this routing rule will apply
    /// to",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouteDestination"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "description": "Describes the kind of router. Set at creation.
    /// `read-only`",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouterRouteKind"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "target": {
    ///      "description": "The location that matched packets should be
    /// forwarded to",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouteTarget"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_router_id": {
    ///      "description": "The ID of the VPC Router to which the route
    /// belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RouterRoute {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// Selects which traffic this routing rule will apply to
        pub destination: RouteDestination,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// Describes the kind of router. Set at creation. `read-only`
        pub kind: RouterRouteKind,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// The location that matched packets should be forwarded to
        pub target: RouteTarget,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The ID of the VPC Router to which the route belongs
        pub vpc_router_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&RouterRoute> for RouterRoute {
        fn from(value: &RouterRoute) -> Self {
            value.clone()
        }
    }

    impl RouterRoute {
        pub fn builder() -> builder::RouterRoute {
            Default::default()
        }
    }

    /// Create-time parameters for a `RouterRoute`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `RouterRoute`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "destination",
    ///    "name",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "destination": {
    ///      "description": "Selects which traffic this routing rule will apply
    /// to.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouteDestination"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "target": {
    ///      "description": "The location that matched packets should be
    /// forwarded to.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouteTarget"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RouterRouteCreate {
        pub description: ::std::string::String,
        /// Selects which traffic this routing rule will apply to.
        pub destination: RouteDestination,
        pub name: Name,
        /// The location that matched packets should be forwarded to.
        pub target: RouteTarget,
    }

    impl ::std::convert::From<&RouterRouteCreate> for RouterRouteCreate {
        fn from(value: &RouterRouteCreate) -> Self {
            value.clone()
        }
    }

    impl RouterRouteCreate {
        pub fn builder() -> builder::RouterRouteCreate {
            Default::default()
        }
    }

    /// The kind of a `RouterRoute`
    ///
    /// The kind determines certain attributes such as if the route is
    /// modifiable and describes how or where the route was created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The kind of a `RouterRoute`\n\nThe kind determines
    /// certain attributes such as if the route is modifiable and describes how
    /// or where the route was created.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Determines the default destination of traffic, such
    /// as whether it goes to the internet or not.\n\n`Destination: An Internet
    /// Gateway` `Modifiable: true`",
    ///      "type": "string",
    ///      "enum": [
    ///        "default"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Automatically added for each VPC Subnet in the
    /// VPC\n\n`Destination: A VPC Subnet` `Modifiable: false`",
    ///      "type": "string",
    ///      "enum": [
    ///        "vpc_subnet"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Automatically added when VPC peering is
    /// established\n\n`Destination: A different VPC` `Modifiable: false`",
    ///      "type": "string",
    ///      "enum": [
    ///        "vpc_peering"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Created by a user; see
    /// `RouteTarget`\n\n`Destination: User defined` `Modifiable: true`",
    ///      "type": "string",
    ///      "enum": [
    ///        "custom"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum RouterRouteKind {
        /// Determines the default destination of traffic, such as whether it
        /// goes to the internet or not.
        ///
        /// `Destination: An Internet Gateway` `Modifiable: true`
        #[serde(rename = "default")]
        Default,
        /// Automatically added for each VPC Subnet in the VPC
        ///
        /// `Destination: A VPC Subnet` `Modifiable: false`
        #[serde(rename = "vpc_subnet")]
        VpcSubnet,
        /// Automatically added when VPC peering is established
        ///
        /// `Destination: A different VPC` `Modifiable: false`
        #[serde(rename = "vpc_peering")]
        VpcPeering,
        /// Created by a user; see `RouteTarget`
        ///
        /// `Destination: User defined` `Modifiable: true`
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for RouterRouteKind {
        fn from(value: &RouterRouteKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for RouterRouteKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Default => write!(f, "default"),
                Self::VpcSubnet => write!(f, "vpc_subnet"),
                Self::VpcPeering => write!(f, "vpc_peering"),
                Self::Custom => write!(f, "custom"),
            }
        }
    }

    impl ::std::str::FromStr for RouterRouteKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "default" => Ok(Self::Default),
                "vpc_subnet" => Ok(Self::VpcSubnet),
                "vpc_peering" => Ok(Self::VpcPeering),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for RouterRouteKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/RouterRoute"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RouterRouteResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<RouterRoute>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&RouterRouteResultsPage> for RouterRouteResultsPage {
        fn from(value: &RouterRouteResultsPage) -> Self {
            value.clone()
        }
    }

    impl RouterRouteResultsPage {
        pub fn builder() -> builder::RouterRouteResultsPage {
            Default::default()
        }
    }

    /// Updateable properties of a `RouterRoute`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of a `RouterRoute`",
    ///  "type": "object",
    ///  "required": [
    ///    "destination",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "destination": {
    ///      "description": "Selects which traffic this routing rule will apply
    /// to.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouteDestination"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "target": {
    ///      "description": "The location that matched packets should be
    /// forwarded to.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/RouteTarget"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct RouterRouteUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        /// Selects which traffic this routing rule will apply to.
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
        /// The location that matched packets should be forwarded to.
        pub target: RouteTarget,
    }

    impl ::std::convert::From<&RouterRouteUpdate> for RouterRouteUpdate {
        fn from(value: &RouterRouteUpdate) -> Self {
            value.clone()
        }
    }

    impl RouterRouteUpdate {
        pub fn builder() -> builder::RouterRouteUpdate {
            Default::default()
        }
    }

    /// Identity-related metadata that's included in nearly all public API
    /// objects
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Identity-related metadata that's included in nearly all
    /// public API objects",
    ///  "type": "object",
    ///  "required": [
    ///    "acs_url",
    ///    "description",
    ///    "id",
    ///    "idp_entity_id",
    ///    "name",
    ///    "slo_url",
    ///    "sp_client_id",
    ///    "technical_contact_email",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "acs_url": {
    ///      "description": "Service provider endpoint where the response will
    /// be sent",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "group_attribute_name": {
    ///      "description": "If set, attributes with this name will be
    /// considered to denote a user's group membership, where the values will be
    /// the group names.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "idp_entity_id": {
    ///      "description": "IdP's entity id",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "public_cert": {
    ///      "description": "Optional request signing public certificate (base64
    /// encoded der file)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "slo_url": {
    ///      "description": "Service provider endpoint where the idp should send
    /// log out requests",
    ///      "type": "string"
    ///    },
    ///    "sp_client_id": {
    ///      "description": "SP's client id",
    ///      "type": "string"
    ///    },
    ///    "technical_contact_email": {
    ///      "description": "Customer's technical contact for saml
    /// configuration",
    ///      "type": "string"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SamlIdentityProvider {
        /// Service provider endpoint where the response will be sent
        pub acs_url: ::std::string::String,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// If set, attributes with this name will be considered to denote a
        /// user's group membership, where the values will be the group names.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_attribute_name: ::std::option::Option<::std::string::String>,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// IdP's entity id
        pub idp_entity_id: ::std::string::String,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// Optional request signing public certificate (base64 encoded der
        /// file)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub public_cert: ::std::option::Option<::std::string::String>,
        /// Service provider endpoint where the idp should send log out requests
        pub slo_url: ::std::string::String,
        /// SP's client id
        pub sp_client_id: ::std::string::String,
        /// Customer's technical contact for saml configuration
        pub technical_contact_email: ::std::string::String,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SamlIdentityProvider> for SamlIdentityProvider {
        fn from(value: &SamlIdentityProvider) -> Self {
            value.clone()
        }
    }

    impl SamlIdentityProvider {
        pub fn builder() -> builder::SamlIdentityProvider {
            Default::default()
        }
    }

    /// Create-time identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time identity-related parameters",
    ///  "type": "object",
    ///  "required": [
    ///    "acs_url",
    ///    "description",
    ///    "idp_entity_id",
    ///    "idp_metadata_source",
    ///    "name",
    ///    "slo_url",
    ///    "sp_client_id",
    ///    "technical_contact_email"
    ///  ],
    ///  "properties": {
    ///    "acs_url": {
    ///      "description": "service provider endpoint where the response will
    /// be sent",
    ///      "type": "string"
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "group_attribute_name": {
    ///      "description": "If set, SAML attributes with this name will be
    /// considered to denote a user's group membership, where the attribute
    /// value(s) should be a comma-separated list of group names.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "idp_entity_id": {
    ///      "description": "idp's entity id",
    ///      "type": "string"
    ///    },
    ///    "idp_metadata_source": {
    ///      "description": "the source of an identity provider metadata
    /// descriptor",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IdpMetadataSource"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "signing_keypair": {
    ///      "description": "request signing key pair",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/DerEncodedKeyPair"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "slo_url": {
    ///      "description": "service provider endpoint where the idp should send
    /// log out requests",
    ///      "type": "string"
    ///    },
    ///    "sp_client_id": {
    ///      "description": "sp's client id",
    ///      "type": "string"
    ///    },
    ///    "technical_contact_email": {
    ///      "description": "customer's technical contact for saml
    /// configuration",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SamlIdentityProviderCreate {
        /// service provider endpoint where the response will be sent
        pub acs_url: ::std::string::String,
        pub description: ::std::string::String,
        /// If set, SAML attributes with this name will be considered to denote
        /// a user's group membership, where the attribute value(s) should be a
        /// comma-separated list of group names.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub group_attribute_name: ::std::option::Option<::std::string::String>,
        /// idp's entity id
        pub idp_entity_id: ::std::string::String,
        /// the source of an identity provider metadata descriptor
        pub idp_metadata_source: IdpMetadataSource,
        pub name: Name,
        /// request signing key pair
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub signing_keypair: ::std::option::Option<DerEncodedKeyPair>,
        /// service provider endpoint where the idp should send log out requests
        pub slo_url: ::std::string::String,
        /// sp's client id
        pub sp_client_id: ::std::string::String,
        /// customer's technical contact for saml configuration
        pub technical_contact_email: ::std::string::String,
    }

    impl ::std::convert::From<&SamlIdentityProviderCreate> for SamlIdentityProviderCreate {
        fn from(value: &SamlIdentityProviderCreate) -> Self {
            value.clone()
        }
    }

    impl SamlIdentityProviderCreate {
        pub fn builder() -> builder::SamlIdentityProviderCreate {
            Default::default()
        }
    }

    /// The service intended to use this certificate.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The service intended to use this certificate.",
    ///  "oneOf": [
    ///    {
    ///      "description": "This certificate is intended for access to the
    /// external API.",
    ///      "type": "string",
    ///      "enum": [
    ///        "external_api"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum ServiceUsingCertificate {
        /// This certificate is intended for access to the external API.
        #[serde(rename = "external_api")]
        ExternalApi,
    }

    impl ::std::convert::From<&Self> for ServiceUsingCertificate {
        fn from(value: &ServiceUsingCertificate) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for ServiceUsingCertificate {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::ExternalApi => write!(f, "external_api"),
            }
        }
    }

    impl ::std::str::FromStr for ServiceUsingCertificate {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "external_api" => Ok(Self::ExternalApi),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for ServiceUsingCertificate {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Parameters for PUT requests to `/v1/system/update/target-release`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for PUT requests to
    /// `/v1/system/update/target-release`.",
    ///  "type": "object",
    ///  "required": [
    ///    "system_version"
    ///  ],
    ///  "properties": {
    ///    "system_version": {
    ///      "description": "Version of the system software to make the target
    /// release.",
    ///      "type": "string",
    ///      "pattern":
    /// "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*
    /// [a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*
    /// ))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SetTargetReleaseParams {
        /// Version of the system software to make the target release.
        pub system_version: SetTargetReleaseParamsSystemVersion,
    }

    impl ::std::convert::From<&SetTargetReleaseParams> for SetTargetReleaseParams {
        fn from(value: &SetTargetReleaseParams) -> Self {
            value.clone()
        }
    }

    impl SetTargetReleaseParams {
        pub fn builder() -> builder::SetTargetReleaseParams {
            Default::default()
        }
    }

    /// Version of the system software to make the target release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Version of the system software to make the target
    /// release.",
    ///  "type": "string",
    ///  "pattern":
    /// "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*
    /// [a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*
    /// ))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct SetTargetReleaseParamsSystemVersion(::std::string::String);
    impl ::std::ops::Deref for SetTargetReleaseParamsSystemVersion {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<SetTargetReleaseParamsSystemVersion> for ::std::string::String {
        fn from(value: SetTargetReleaseParamsSystemVersion) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SetTargetReleaseParamsSystemVersion>
        for SetTargetReleaseParamsSystemVersion
    {
        fn from(value: &SetTargetReleaseParamsSystemVersion) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for SetTargetReleaseParamsSystemVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*\
                 [a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\
                 +([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*\
                            |\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*\
                            [a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.\
                            [0-9a-zA-Z-]+)*))?$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for SetTargetReleaseParamsSystemVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SetTargetReleaseParamsSystemVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SetTargetReleaseParamsSystemVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for SetTargetReleaseParamsSystemVersion {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// View of a Silo
    ///
    /// A Silo is the highest level unit of isolation.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Silo\n\nA Silo is the highest level unit of
    /// isolation.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "discoverable",
    ///    "id",
    ///    "identity_mode",
    ///    "mapped_fleet_roles",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "description": "A silo where discoverable is false can be retrieved only by its id - it will not be part of the \"list all silos\" output.",
    ///      "type": "boolean"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_mode": {
    ///      "description": "How users and groups are managed in this Silo",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SiloIdentityMode"
    ///        }
    ///      ]
    ///    },
    ///    "mapped_fleet_roles": {
    ///      "description": "Mapping of which Fleet roles are conferred by each
    /// Silo role\n\nThe default is that no Fleet roles are conferred by any
    /// Silo roles unless there's a corresponding entry in this map.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "array",
    ///        "items": {
    ///          "$ref": "#/components/schemas/FleetRole"
    ///        },
    ///        "uniqueItems": true
    ///      }
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Silo {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// A silo where discoverable is false can be retrieved only by its id -
        /// it will not be part of the "list all silos" output.
        pub discoverable: bool,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// How users and groups are managed in this Silo
        pub identity_mode: SiloIdentityMode,
        /// Mapping of which Fleet roles are conferred by each Silo role
        ///
        /// The default is that no Fleet roles are conferred by any Silo roles
        /// unless there's a corresponding entry in this map.
        pub mapped_fleet_roles: ::std::collections::HashMap<::std::string::String, Vec<FleetRole>>,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Silo> for Silo {
        fn from(value: &Silo) -> Self {
            value.clone()
        }
    }

    impl Silo {
        pub fn builder() -> builder::Silo {
            Default::default()
        }
    }

    /// Create-time parameters for a `Silo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `Silo`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "discoverable",
    ///    "identity_mode",
    ///    "name",
    ///    "quotas",
    ///    "tls_certificates"
    ///  ],
    ///  "properties": {
    ///    "admin_group_name": {
    ///      "description": "If set, this group will be created during Silo
    /// creation and granted the \"Silo Admin\" role. Identity providers can
    /// assert that users belong to this group and those users can log in and
    /// further initialize the Silo.\n\nNote that if configuring a SAML based
    /// identity provider, group_attribute_name must be set for users to be
    /// considered part of a group. See `SamlIdentityProviderCreate` for more
    /// information.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "discoverable": {
    ///      "type": "boolean"
    ///    },
    ///    "identity_mode": {
    ///      "$ref": "#/components/schemas/SiloIdentityMode"
    ///    },
    ///    "mapped_fleet_roles": {
    ///      "description": "Mapping of which Fleet roles are conferred by each
    /// Silo role\n\nThe default is that no Fleet roles are conferred by any
    /// Silo roles unless there's a corresponding entry in this map.",
    ///      "default": {},
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "type": "array",
    ///        "items": {
    ///          "$ref": "#/components/schemas/FleetRole"
    ///        },
    ///        "uniqueItems": true
    ///      }
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "quotas": {
    ///      "description": "Limits the amount of provisionable CPU, memory, and
    /// storage in the Silo. CPU and memory are only consumed by running
    /// instances, while storage is consumed by any disk or snapshot. A value of
    /// 0 means that resource is *not* provisionable.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SiloQuotasCreate"
    ///        }
    ///      ]
    ///    },
    ///    "tls_certificates": {
    ///      "description": "Initial TLS certificates to be used for the new
    /// Silo's console and API endpoints.  These should be valid for the Silo's
    /// DNS name(s).",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/CertificateCreate"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloCreate {
        /// If set, this group will be created during Silo creation and granted
        /// the "Silo Admin" role. Identity providers can assert that users
        /// belong to this group and those users can log in and further
        /// initialize the Silo.
        ///
        /// Note that if configuring a SAML based identity provider,
        /// group_attribute_name must be set for users to be considered part of
        /// a group. See `SamlIdentityProviderCreate` for more information.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub admin_group_name: ::std::option::Option<::std::string::String>,
        pub description: ::std::string::String,
        pub discoverable: bool,
        pub identity_mode: SiloIdentityMode,
        /// Mapping of which Fleet roles are conferred by each Silo role
        ///
        /// The default is that no Fleet roles are conferred by any Silo roles
        /// unless there's a corresponding entry in this map.
        #[serde(
            default,
            skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
        )]
        pub mapped_fleet_roles: ::std::collections::HashMap<::std::string::String, Vec<FleetRole>>,
        pub name: Name,
        /// Limits the amount of provisionable CPU, memory, and storage in the
        /// Silo. CPU and memory are only consumed by running instances, while
        /// storage is consumed by any disk or snapshot. A value of 0 means that
        /// resource is *not* provisionable.
        pub quotas: SiloQuotasCreate,
        /// Initial TLS certificates to be used for the new Silo's console and
        /// API endpoints.  These should be valid for the Silo's DNS name(s).
        pub tls_certificates: ::std::vec::Vec<CertificateCreate>,
    }

    impl ::std::convert::From<&SiloCreate> for SiloCreate {
        fn from(value: &SiloCreate) -> Self {
            value.clone()
        }
    }

    impl SiloCreate {
        pub fn builder() -> builder::SiloCreate {
            Default::default()
        }
    }

    /// Describes how identities are managed and users are authenticated in this
    /// Silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes how identities are managed and users are
    /// authenticated in this Silo",
    ///  "oneOf": [
    ///    {
    ///      "description": "Users are authenticated with SAML using an external
    /// authentication provider.  The system updates information about users and
    /// groups only during successful authentication (i.e,. \"JIT provisioning\"
    /// of users and groups).",
    ///      "type": "string",
    ///      "enum": [
    ///        "saml_jit"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The system is the source of truth about users.
    /// There is no linkage to an external authentication provider or identity
    /// provider.",
    ///      "type": "string",
    ///      "enum": [
    ///        "local_only"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SiloIdentityMode {
        /// Users are authenticated with SAML using an external authentication
        /// provider.  The system updates information about users and groups
        /// only during successful authentication (i.e,. "JIT provisioning" of
        /// users and groups).
        #[serde(rename = "saml_jit")]
        SamlJit,
        /// The system is the source of truth about users.  There is no linkage
        /// to an external authentication provider or identity provider.
        #[serde(rename = "local_only")]
        LocalOnly,
    }

    impl ::std::convert::From<&Self> for SiloIdentityMode {
        fn from(value: &SiloIdentityMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SiloIdentityMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::SamlJit => write!(f, "saml_jit"),
                Self::LocalOnly => write!(f, "local_only"),
            }
        }
    }

    impl ::std::str::FromStr for SiloIdentityMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "saml_jit" => Ok(Self::SamlJit),
                "local_only" => Ok(Self::LocalOnly),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SiloIdentityMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// An IP pool in the context of a silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An IP pool in the context of a silo",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "is_default",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "is_default": {
    ///      "description": "When a pool is the default for a silo, floating IPs
    /// and instance ephemeral IPs will come from that pool when no other pool
    /// is specified. There can be at most one default for a given silo.",
    ///      "type": "boolean"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloIpPool {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// When a pool is the default for a silo, floating IPs and instance
        /// ephemeral IPs will come from that pool when no other pool is
        /// specified. There can be at most one default for a given silo.
        pub is_default: bool,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SiloIpPool> for SiloIpPool {
        fn from(value: &SiloIpPool) -> Self {
            value.clone()
        }
    }

    impl SiloIpPool {
        pub fn builder() -> builder::SiloIpPool {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SiloIpPool"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloIpPoolResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SiloIpPool>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SiloIpPoolResultsPage> for SiloIpPoolResultsPage {
        fn from(value: &SiloIpPoolResultsPage) -> Self {
            value.clone()
        }
    }

    impl SiloIpPoolResultsPage {
        pub fn builder() -> builder::SiloIpPoolResultsPage {
            Default::default()
        }
    }

    /// A collection of resource counts used to set the virtual capacity of a
    /// silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A collection of resource counts used to set the virtual
    /// capacity of a silo",
    ///  "type": "object",
    ///  "required": [
    ///    "cpus",
    ///    "memory",
    ///    "silo_id",
    ///    "storage"
    ///  ],
    ///  "properties": {
    ///    "cpus": {
    ///      "description": "Number of virtual CPUs",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "memory": {
    ///      "description": "Amount of memory in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "silo_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "storage": {
    ///      "description": "Amount of disk storage in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloQuotas {
        /// Number of virtual CPUs
        pub cpus: i64,
        /// Amount of memory in bytes
        pub memory: ByteCount,
        pub silo_id: ::uuid::Uuid,
        /// Amount of disk storage in bytes
        pub storage: ByteCount,
    }

    impl ::std::convert::From<&SiloQuotas> for SiloQuotas {
        fn from(value: &SiloQuotas) -> Self {
            value.clone()
        }
    }

    impl SiloQuotas {
        pub fn builder() -> builder::SiloQuotas {
            Default::default()
        }
    }

    /// The amount of provisionable resources for a Silo
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The amount of provisionable resources for a Silo",
    ///  "type": "object",
    ///  "required": [
    ///    "cpus",
    ///    "memory",
    ///    "storage"
    ///  ],
    ///  "properties": {
    ///    "cpus": {
    ///      "description": "The amount of virtual CPUs available for running
    /// instances in the Silo",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "memory": {
    ///      "description": "The amount of RAM (in bytes) available for running
    /// instances in the Silo",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "storage": {
    ///      "description": "The amount of storage (in bytes) available for
    /// disks or snapshots",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloQuotasCreate {
        /// The amount of virtual CPUs available for running instances in the
        /// Silo
        pub cpus: i64,
        /// The amount of RAM (in bytes) available for running instances in the
        /// Silo
        pub memory: ByteCount,
        /// The amount of storage (in bytes) available for disks or snapshots
        pub storage: ByteCount,
    }

    impl ::std::convert::From<&SiloQuotasCreate> for SiloQuotasCreate {
        fn from(value: &SiloQuotasCreate) -> Self {
            value.clone()
        }
    }

    impl SiloQuotasCreate {
        pub fn builder() -> builder::SiloQuotasCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SiloQuotas"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloQuotasResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SiloQuotas>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SiloQuotasResultsPage> for SiloQuotasResultsPage {
        fn from(value: &SiloQuotasResultsPage) -> Self {
            value.clone()
        }
    }

    impl SiloQuotasResultsPage {
        pub fn builder() -> builder::SiloQuotasResultsPage {
            Default::default()
        }
    }

    /// Updateable properties of a Silo's resource limits. If a value is omitted
    /// it will not be updated.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of a Silo's resource limits. If a
    /// value is omitted it will not be updated.",
    ///  "type": "object",
    ///  "properties": {
    ///    "cpus": {
    ///      "description": "The amount of virtual CPUs available for running
    /// instances in the Silo",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int64"
    ///    },
    ///    "memory": {
    ///      "description": "The amount of RAM (in bytes) available for running
    /// instances in the Silo",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/ByteCount"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "storage": {
    ///      "description": "The amount of storage (in bytes) available for
    /// disks or snapshots",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/ByteCount"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloQuotasUpdate {
        /// The amount of virtual CPUs available for running instances in the
        /// Silo
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub cpus: ::std::option::Option<i64>,
        /// The amount of RAM (in bytes) available for running instances in the
        /// Silo
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub memory: ::std::option::Option<ByteCount>,
        /// The amount of storage (in bytes) available for disks or snapshots
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub storage: ::std::option::Option<ByteCount>,
    }

    impl ::std::convert::From<&SiloQuotasUpdate> for SiloQuotasUpdate {
        fn from(value: &SiloQuotasUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for SiloQuotasUpdate {
        fn default() -> Self {
            Self {
                cpus: Default::default(),
                memory: Default::default(),
                storage: Default::default(),
            }
        }
    }

    impl SiloQuotasUpdate {
        pub fn builder() -> builder::SiloQuotasUpdate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Silo"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Silo>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SiloResultsPage> for SiloResultsPage {
        fn from(value: &SiloResultsPage) -> Self {
            value.clone()
        }
    }

    impl SiloResultsPage {
        pub fn builder() -> builder::SiloResultsPage {
            Default::default()
        }
    }

    /// `SiloRole`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "admin",
    ///    "collaborator",
    ///    "viewer"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SiloRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl ::std::convert::From<&Self> for SiloRole {
        fn from(value: &SiloRole) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SiloRole {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Admin => write!(f, "admin"),
                Self::Collaborator => write!(f, "collaborator"),
                Self::Viewer => write!(f, "viewer"),
            }
        }
    }

    impl ::std::str::FromStr for SiloRole {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SiloRole {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Policy for a particular resource
    ///
    /// Note that the Policy only describes access granted explicitly for this
    /// resource.  The policies of parent resources can also cause a user to
    /// have access to this resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Policy for a particular resource\n\nNote that the
    /// Policy only describes access granted explicitly for this resource.  The
    /// policies of parent resources can also cause a user to have access to
    /// this resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "role_assignments"
    ///  ],
    ///  "properties": {
    ///    "role_assignments": {
    ///      "description": "Roles directly assigned on this resource",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SiloRoleRoleAssignment"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloRolePolicy {
        /// Roles directly assigned on this resource
        pub role_assignments: ::std::vec::Vec<SiloRoleRoleAssignment>,
    }

    impl ::std::convert::From<&SiloRolePolicy> for SiloRolePolicy {
        fn from(value: &SiloRolePolicy) -> Self {
            value.clone()
        }
    }

    impl SiloRolePolicy {
        pub fn builder() -> builder::SiloRolePolicy {
            Default::default()
        }
    }

    /// Describes the assignment of a particular role on a particular resource
    /// to a particular identity (user, group, etc.)
    ///
    /// The resource is not part of this structure.  Rather, `RoleAssignment`s
    /// are put into a `Policy` and that Policy is applied to a particular
    /// resource.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes the assignment of a particular role on a
    /// particular resource to a particular identity (user, group, etc.)\n\nThe
    /// resource is not part of this structure.  Rather, `RoleAssignment`s are
    /// put into a `Policy` and that Policy is applied to a particular
    /// resource.",
    ///  "type": "object",
    ///  "required": [
    ///    "identity_id",
    ///    "identity_type",
    ///    "role_name"
    ///  ],
    ///  "properties": {
    ///    "identity_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "identity_type": {
    ///      "$ref": "#/components/schemas/IdentityType"
    ///    },
    ///    "role_name": {
    ///      "$ref": "#/components/schemas/SiloRole"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloRoleRoleAssignment {
        pub identity_id: ::uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: SiloRole,
    }

    impl ::std::convert::From<&SiloRoleRoleAssignment> for SiloRoleRoleAssignment {
        fn from(value: &SiloRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl SiloRoleRoleAssignment {
        pub fn builder() -> builder::SiloRoleRoleAssignment {
            Default::default()
        }
    }

    /// View of a silo's resource utilization and capacity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a silo's resource utilization and capacity",
    ///  "type": "object",
    ///  "required": [
    ///    "allocated",
    ///    "provisioned",
    ///    "silo_id",
    ///    "silo_name"
    ///  ],
    ///  "properties": {
    ///    "allocated": {
    ///      "description": "Accounts for the total amount of resources reserved
    /// for silos via their quotas",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VirtualResourceCounts"
    ///        }
    ///      ]
    ///    },
    ///    "provisioned": {
    ///      "description": "Accounts for resources allocated by in silos like
    /// CPU or memory for running instances and storage for disks and snapshots
    /// Note that CPU and memory resources associated with a stopped instances
    /// are not counted here",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VirtualResourceCounts"
    ///        }
    ///      ]
    ///    },
    ///    "silo_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloUtilization {
        /// Accounts for the total amount of resources reserved for silos via
        /// their quotas
        pub allocated: VirtualResourceCounts,
        /// Accounts for resources allocated by in silos like CPU or memory for
        /// running instances and storage for disks and snapshots Note that CPU
        /// and memory resources associated with a stopped instances are not
        /// counted here
        pub provisioned: VirtualResourceCounts,
        pub silo_id: ::uuid::Uuid,
        pub silo_name: Name,
    }

    impl ::std::convert::From<&SiloUtilization> for SiloUtilization {
        fn from(value: &SiloUtilization) -> Self {
            value.clone()
        }
    }

    impl SiloUtilization {
        pub fn builder() -> builder::SiloUtilization {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SiloUtilization"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SiloUtilizationResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SiloUtilization>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SiloUtilizationResultsPage> for SiloUtilizationResultsPage {
        fn from(value: &SiloUtilizationResultsPage) -> Self {
            value.clone()
        }
    }

    impl SiloUtilizationResultsPage {
        pub fn builder() -> builder::SiloUtilizationResultsPage {
            Default::default()
        }
    }

    /// An operator's view of a Sled.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An operator's view of a Sled.",
    ///  "type": "object",
    ///  "required": [
    ///    "baseboard",
    ///    "id",
    ///    "policy",
    ///    "rack_id",
    ///    "state",
    ///    "time_created",
    ///    "time_modified",
    ///    "usable_hardware_threads",
    ///    "usable_physical_ram"
    ///  ],
    ///  "properties": {
    ///    "baseboard": {
    ///      "$ref": "#/components/schemas/Baseboard"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "policy": {
    ///      "description": "The operator-defined policy of a sled.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SledPolicy"
    ///        }
    ///      ]
    ///    },
    ///    "rack_id": {
    ///      "description": "The rack to which this Sled is currently attached",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "description": "The current state Nexus believes the sled to be
    /// in.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SledState"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "usable_hardware_threads": {
    ///      "description": "The number of hardware threads which can execute on
    /// this sled",
    ///      "type": "integer",
    ///      "format": "uint32",
    ///      "minimum": 0.0
    ///    },
    ///    "usable_physical_ram": {
    ///      "description": "Amount of RAM which may be used by the Sled's OS",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Sled {
        pub baseboard: Baseboard,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The operator-defined policy of a sled.
        pub policy: SledPolicy,
        /// The rack to which this Sled is currently attached
        pub rack_id: ::uuid::Uuid,
        /// The current state Nexus believes the sled to be in.
        pub state: SledState,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The number of hardware threads which can execute on this sled
        pub usable_hardware_threads: u32,
        /// Amount of RAM which may be used by the Sled's OS
        pub usable_physical_ram: ByteCount,
    }

    impl ::std::convert::From<&Sled> for Sled {
        fn from(value: &Sled) -> Self {
            value.clone()
        }
    }

    impl Sled {
        pub fn builder() -> builder::Sled {
            Default::default()
        }
    }

    /// The unique ID of a sled.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The unique ID of a sled.",
    ///  "type": "object",
    ///  "required": [
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SledId {
        pub id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&SledId> for SledId {
        fn from(value: &SledId) -> Self {
            value.clone()
        }
    }

    impl SledId {
        pub fn builder() -> builder::SledId {
            Default::default()
        }
    }

    /// An operator's view of an instance running on a given sled
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An operator's view of an instance running on a given
    /// sled",
    ///  "type": "object",
    ///  "required": [
    ///    "active_sled_id",
    ///    "id",
    ///    "memory",
    ///    "name",
    ///    "ncpus",
    ///    "project_name",
    ///    "silo_name",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "active_sled_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "memory": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "migration_id": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ncpus": {
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "project_name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "silo_name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/InstanceState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SledInstance {
        pub active_sled_id: ::uuid::Uuid,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub memory: i64,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub migration_id: ::std::option::Option<::uuid::Uuid>,
        pub name: Name,
        pub ncpus: i64,
        pub project_name: Name,
        pub silo_name: Name,
        pub state: InstanceState,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SledInstance> for SledInstance {
        fn from(value: &SledInstance) -> Self {
            value.clone()
        }
    }

    impl SledInstance {
        pub fn builder() -> builder::SledInstance {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SledInstance"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SledInstanceResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SledInstance>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SledInstanceResultsPage> for SledInstanceResultsPage {
        fn from(value: &SledInstanceResultsPage) -> Self {
            value.clone()
        }
    }

    impl SledInstanceResultsPage {
        pub fn builder() -> builder::SledInstanceResultsPage {
            Default::default()
        }
    }

    /// The operator-defined policy of a sled.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The operator-defined policy of a sled.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The operator has indicated that the sled is
    /// in-service.",
    ///      "type": "object",
    ///      "required": [
    ///        "kind",
    ///        "provision_policy"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "in_service"
    ///          ]
    ///        },
    ///        "provision_policy": {
    ///          "description": "Determines whether new resources can be
    /// provisioned onto the sled.",
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/SledProvisionPolicy"
    ///            }
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The operator has indicated that the sled has been
    /// permanently removed from service.\n\nThis is a terminal state: once a
    /// particular sled ID is expunged, it will never return to service. (The
    /// actual hardware may be reused, but it will be treated as a brand-new
    /// sled.)\n\nAn expunged sled is always non-provisionable.",
    ///      "type": "object",
    ///      "required": [
    ///        "kind"
    ///      ],
    ///      "properties": {
    ///        "kind": {
    ///          "type": "string",
    ///          "enum": [
    ///            "expunged"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "kind", content = "provision_policy")]
    pub enum SledPolicy {
        /// The operator has indicated that the sled is in-service.
        #[serde(rename = "in_service")]
        InService(SledProvisionPolicy),
        #[serde(rename = "expunged")]
        Expunged,
    }

    impl ::std::convert::From<&Self> for SledPolicy {
        fn from(value: &SledPolicy) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<SledProvisionPolicy> for SledPolicy {
        fn from(value: SledProvisionPolicy) -> Self {
            Self::InService(value)
        }
    }

    /// The operator-defined provision policy of a sled.
    ///
    /// This controls whether new resources are going to be provisioned on this
    /// sled.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The operator-defined provision policy of a
    /// sled.\n\nThis controls whether new resources are going to be provisioned
    /// on this sled.",
    ///  "oneOf": [
    ///    {
    ///      "description": "New resources will be provisioned on this sled.",
    ///      "type": "string",
    ///      "enum": [
    ///        "provisionable"
    ///      ]
    ///    },
    ///    {
    ///      "description": "New resources will not be provisioned on this sled.
    /// However, if the sled is currently in service, existing resources will
    /// continue to be on this sled unless manually migrated off.",
    ///      "type": "string",
    ///      "enum": [
    ///        "non_provisionable"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SledProvisionPolicy {
        /// New resources will be provisioned on this sled.
        #[serde(rename = "provisionable")]
        Provisionable,
        /// New resources will not be provisioned on this sled. However, if the
        /// sled is currently in service, existing resources will continue to be
        /// on this sled unless manually migrated off.
        #[serde(rename = "non_provisionable")]
        NonProvisionable,
    }

    impl ::std::convert::From<&Self> for SledProvisionPolicy {
        fn from(value: &SledProvisionPolicy) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SledProvisionPolicy {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Provisionable => write!(f, "provisionable"),
                Self::NonProvisionable => write!(f, "non_provisionable"),
            }
        }
    }

    impl ::std::str::FromStr for SledProvisionPolicy {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "provisionable" => Ok(Self::Provisionable),
                "non_provisionable" => Ok(Self::NonProvisionable),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SledProvisionPolicy {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SledProvisionPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SledProvisionPolicy {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Parameters for `sled_set_provision_policy`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for `sled_set_provision_policy`.",
    ///  "type": "object",
    ///  "required": [
    ///    "state"
    ///  ],
    ///  "properties": {
    ///    "state": {
    ///      "description": "The provision state.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SledProvisionPolicy"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SledProvisionPolicyParams {
        /// The provision state.
        pub state: SledProvisionPolicy,
    }

    impl ::std::convert::From<&SledProvisionPolicyParams> for SledProvisionPolicyParams {
        fn from(value: &SledProvisionPolicyParams) -> Self {
            value.clone()
        }
    }

    impl SledProvisionPolicyParams {
        pub fn builder() -> builder::SledProvisionPolicyParams {
            Default::default()
        }
    }

    /// Response to `sled_set_provision_policy`.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Response to `sled_set_provision_policy`.",
    ///  "type": "object",
    ///  "required": [
    ///    "new_state",
    ///    "old_state"
    ///  ],
    ///  "properties": {
    ///    "new_state": {
    ///      "description": "The new provision state.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SledProvisionPolicy"
    ///        }
    ///      ]
    ///    },
    ///    "old_state": {
    ///      "description": "The old provision state.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SledProvisionPolicy"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SledProvisionPolicyResponse {
        /// The new provision state.
        pub new_state: SledProvisionPolicy,
        /// The old provision state.
        pub old_state: SledProvisionPolicy,
    }

    impl ::std::convert::From<&SledProvisionPolicyResponse> for SledProvisionPolicyResponse {
        fn from(value: &SledProvisionPolicyResponse) -> Self {
            value.clone()
        }
    }

    impl SledProvisionPolicyResponse {
        pub fn builder() -> builder::SledProvisionPolicyResponse {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Sled"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SledResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Sled>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SledResultsPage> for SledResultsPage {
        fn from(value: &SledResultsPage) -> Self {
            value.clone()
        }
    }

    impl SledResultsPage {
        pub fn builder() -> builder::SledResultsPage {
            Default::default()
        }
    }

    /// The current state of the sled, as determined by Nexus.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The current state of the sled, as determined by
    /// Nexus.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The sled is currently active, and has resources
    /// allocated on it.",
    ///      "type": "string",
    ///      "enum": [
    ///        "active"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The sled has been permanently removed from
    /// service.\n\nThis is a terminal state: once a particular sled ID is
    /// decommissioned, it will never return to service. (The actual hardware
    /// may be reused, but it will be treated as a brand-new sled.)",
    ///      "type": "string",
    ///      "enum": [
    ///        "decommissioned"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SledState {
        /// The sled is currently active, and has resources allocated on it.
        #[serde(rename = "active")]
        Active,
        /// The sled has been permanently removed from service.
        ///
        /// This is a terminal state: once a particular sled ID is
        /// decommissioned, it will never return to service. (The actual
        /// hardware may be reused, but it will be treated as a brand-new sled.)
        #[serde(rename = "decommissioned")]
        Decommissioned,
    }

    impl ::std::convert::From<&Self> for SledState {
        fn from(value: &SledState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SledState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Active => write!(f, "active"),
                Self::Decommissioned => write!(f, "decommissioned"),
            }
        }
    }

    impl ::std::str::FromStr for SledState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "active" => Ok(Self::Active),
                "decommissioned" => Ok(Self::Decommissioned),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SledState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SledState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SledState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// View of a Snapshot
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Snapshot",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk_id",
    ///    "id",
    ///    "name",
    ///    "project_id",
    ///    "size",
    ///    "state",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "disk_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "size": {
    ///      "$ref": "#/components/schemas/ByteCount"
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/SnapshotState"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Snapshot {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        pub disk_id: ::uuid::Uuid,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub project_id: ::uuid::Uuid,
        pub size: ByteCount,
        pub state: SnapshotState,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Snapshot> for Snapshot {
        fn from(value: &Snapshot) -> Self {
            value.clone()
        }
    }

    impl Snapshot {
        pub fn builder() -> builder::Snapshot {
            Default::default()
        }
    }

    /// Create-time parameters for a `Snapshot`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `Snapshot`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "disk",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "disk": {
    ///      "description": "The disk to be snapshotted",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SnapshotCreate {
        pub description: ::std::string::String,
        /// The disk to be snapshotted
        pub disk: NameOrId,
        pub name: Name,
    }

    impl ::std::convert::From<&SnapshotCreate> for SnapshotCreate {
        fn from(value: &SnapshotCreate) -> Self {
            value.clone()
        }
    }

    impl SnapshotCreate {
        pub fn builder() -> builder::SnapshotCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Snapshot"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SnapshotResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Snapshot>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SnapshotResultsPage> for SnapshotResultsPage {
        fn from(value: &SnapshotResultsPage) -> Self {
            value.clone()
        }
    }

    impl SnapshotResultsPage {
        pub fn builder() -> builder::SnapshotResultsPage {
            Default::default()
        }
    }

    /// `SnapshotState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "creating",
    ///    "ready",
    ///    "faulted",
    ///    "destroyed"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SnapshotState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "ready")]
        Ready,
        #[serde(rename = "faulted")]
        Faulted,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl ::std::convert::From<&Self> for SnapshotState {
        fn from(value: &SnapshotState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SnapshotState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Creating => write!(f, "creating"),
                Self::Ready => write!(f, "ready"),
                Self::Faulted => write!(f, "faulted"),
                Self::Destroyed => write!(f, "destroyed"),
            }
        }
    }

    impl ::std::str::FromStr for SnapshotState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "creating" => Ok(Self::Creating),
                "ready" => Ok(Self::Ready),
                "faulted" => Ok(Self::Faulted),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SnapshotState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// View of an SSH Key
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of an SSH Key",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "public_key",
    ///    "silo_user_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "public_key": {
    ///      "description": "SSH public key, e.g., `\"ssh-ed25519
    /// AAAAC3NzaC...\"`",
    ///      "type": "string"
    ///    },
    ///    "silo_user_id": {
    ///      "description": "The user to whom this key belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SshKey {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: ::std::string::String,
        /// The user to whom this key belongs
        pub silo_user_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SshKey> for SshKey {
        fn from(value: &SshKey) -> Self {
            value.clone()
        }
    }

    impl SshKey {
        pub fn builder() -> builder::SshKey {
            Default::default()
        }
    }

    /// Create-time parameters for an `SshKey`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for an `SshKey`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name",
    ///    "public_key"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "public_key": {
    ///      "description": "SSH public key, e.g., `\"ssh-ed25519
    /// AAAAC3NzaC...\"`",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SshKeyCreate {
        pub description: ::std::string::String,
        pub name: Name,
        /// SSH public key, e.g., `"ssh-ed25519 AAAAC3NzaC..."`
        pub public_key: ::std::string::String,
    }

    impl ::std::convert::From<&SshKeyCreate> for SshKeyCreate {
        fn from(value: &SshKeyCreate) -> Self {
            value.clone()
        }
    }

    impl SshKeyCreate {
        pub fn builder() -> builder::SshKeyCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SshKey"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SshKeyResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SshKey>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SshKeyResultsPage> for SshKeyResultsPage {
        fn from(value: &SshKeyResultsPage) -> Self {
            value.clone()
        }
    }

    impl SshKeyResultsPage {
        pub fn builder() -> builder::SshKeyResultsPage {
            Default::default()
        }
    }

    /// `SupportBundleInfo`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "reason_for_creation",
    ///    "state",
    ///    "time_created"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "$ref": "#/components/schemas/TypedUuidForSupportBundleKind"
    ///    },
    ///    "reason_for_creation": {
    ///      "type": "string"
    ///    },
    ///    "reason_for_failure": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "state": {
    ///      "$ref": "#/components/schemas/SupportBundleState"
    ///    },
    ///    "time_created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SupportBundleInfo {
        pub id: TypedUuidForSupportBundleKind,
        pub reason_for_creation: ::std::string::String,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub reason_for_failure: ::std::option::Option<::std::string::String>,
        pub state: SupportBundleState,
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SupportBundleInfo> for SupportBundleInfo {
        fn from(value: &SupportBundleInfo) -> Self {
            value.clone()
        }
    }

    impl SupportBundleInfo {
        pub fn builder() -> builder::SupportBundleInfo {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SupportBundleInfo"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SupportBundleInfoResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SupportBundleInfo>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SupportBundleInfoResultsPage> for SupportBundleInfoResultsPage {
        fn from(value: &SupportBundleInfoResultsPage) -> Self {
            value.clone()
        }
    }

    impl SupportBundleInfoResultsPage {
        pub fn builder() -> builder::SupportBundleInfoResultsPage {
            Default::default()
        }
    }

    /// `SupportBundleState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "description": "Support Bundle still actively being
    /// collected.\n\nThis is the initial state for a Support Bundle, and it
    /// will automatically transition to either \"Failing\" or \"Active\".\n\nIf
    /// a user no longer wants to access a Support Bundle, they can request
    /// cancellation, which will transition to the \"Destroying\" state.",
    ///      "type": "string",
    ///      "enum": [
    ///        "collecting"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Support Bundle is being destroyed.\n\nOnce backing
    /// storage has been freed, this bundle is destroyed.",
    ///      "type": "string",
    ///      "enum": [
    ///        "destroying"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Support Bundle was not created successfully, or was
    /// created and has lost backing storage.\n\nThe record of the bundle still
    /// exists for readability, but the only valid operation on these bundles is
    /// to destroy them.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Support Bundle has been processed, and is ready for
    /// usage.",
    ///      "type": "string",
    ///      "enum": [
    ///        "active"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SupportBundleState {
        /// Support Bundle still actively being collected.
        ///
        /// This is the initial state for a Support Bundle, and it will
        /// automatically transition to either "Failing" or "Active".
        ///
        /// If a user no longer wants to access a Support Bundle, they can
        /// request cancellation, which will transition to the "Destroying"
        /// state.
        #[serde(rename = "collecting")]
        Collecting,
        /// Support Bundle is being destroyed.
        ///
        /// Once backing storage has been freed, this bundle is destroyed.
        #[serde(rename = "destroying")]
        Destroying,
        /// Support Bundle was not created successfully, or was created and has
        /// lost backing storage.
        ///
        /// The record of the bundle still exists for readability, but the only
        /// valid operation on these bundles is to destroy them.
        #[serde(rename = "failed")]
        Failed,
        /// Support Bundle has been processed, and is ready for usage.
        #[serde(rename = "active")]
        Active,
    }

    impl ::std::convert::From<&Self> for SupportBundleState {
        fn from(value: &SupportBundleState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SupportBundleState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Collecting => write!(f, "collecting"),
                Self::Destroying => write!(f, "destroying"),
                Self::Failed => write!(f, "failed"),
                Self::Active => write!(f, "active"),
            }
        }
    }

    impl ::std::str::FromStr for SupportBundleState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "collecting" => Ok(Self::Collecting),
                "destroying" => Ok(Self::Destroying),
                "failed" => Ok(Self::Failed),
                "active" => Ok(Self::Active),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SupportBundleState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SupportBundleState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SupportBundleState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// An operator's view of a Switch.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An operator's view of a Switch.",
    ///  "type": "object",
    ///  "required": [
    ///    "baseboard",
    ///    "id",
    ///    "rack_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "baseboard": {
    ///      "$ref": "#/components/schemas/Baseboard"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "rack_id": {
    ///      "description": "The rack to which this Switch is currently
    /// attached",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Switch {
        pub baseboard: Baseboard,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The rack to which this Switch is currently attached
        pub rack_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Switch> for Switch {
        fn from(value: &Switch) -> Self {
            value.clone()
        }
    }

    impl Switch {
        pub fn builder() -> builder::Switch {
            Default::default()
        }
    }

    /// BGP message history for a particular switch.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "BGP message history for a particular switch.",
    ///  "type": "object",
    ///  "required": [
    ///    "history",
    ///    "switch"
    ///  ],
    ///  "properties": {
    ///    "history": {
    ///      "description": "Message history indexed by peer address.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/BgpMessageHistory"
    ///      }
    ///    },
    ///    "switch": {
    ///      "description": "Switch this message history is associated with.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchLocation"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchBgpHistory {
        /// Message history indexed by peer address.
        pub history: ::std::collections::HashMap<::std::string::String, BgpMessageHistory>,
        /// Switch this message history is associated with.
        pub switch: SwitchLocation,
    }

    impl ::std::convert::From<&SwitchBgpHistory> for SwitchBgpHistory {
        fn from(value: &SwitchBgpHistory) -> Self {
            value.clone()
        }
    }

    impl SwitchBgpHistory {
        pub fn builder() -> builder::SwitchBgpHistory {
            Default::default()
        }
    }

    /// A switch port interface configuration for a port settings object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A switch port interface configuration for a port
    /// settings object.",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "interface_name",
    ///    "kind",
    ///    "port_settings_id",
    ///    "v6_enabled"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "A unique identifier for this switch interface.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "interface_name": {
    ///      "description": "The name of this switch interface.",
    ///      "type": "string"
    ///    },
    ///    "kind": {
    ///      "description": "The switch interface kind.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchInterfaceKind2"
    ///        }
    ///      ]
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The port settings object this switch interface
    /// configuration belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "v6_enabled": {
    ///      "description": "Whether or not IPv6 is enabled on this interface.",
    ///      "type": "boolean"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchInterfaceConfig {
        /// A unique identifier for this switch interface.
        pub id: ::uuid::Uuid,
        /// The name of this switch interface.
        pub interface_name: ::std::string::String,
        /// The switch interface kind.
        pub kind: SwitchInterfaceKind2,
        /// The port settings object this switch interface configuration belongs
        /// to.
        pub port_settings_id: ::uuid::Uuid,
        /// Whether or not IPv6 is enabled on this interface.
        pub v6_enabled: bool,
    }

    impl ::std::convert::From<&SwitchInterfaceConfig> for SwitchInterfaceConfig {
        fn from(value: &SwitchInterfaceConfig) -> Self {
            value.clone()
        }
    }

    impl SwitchInterfaceConfig {
        pub fn builder() -> builder::SwitchInterfaceConfig {
            Default::default()
        }
    }

    /// A layer-3 switch interface configuration. When IPv6 is enabled, a link
    /// local address will be created for the interface.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A layer-3 switch interface configuration. When IPv6 is
    /// enabled, a link local address will be created for the interface.",
    ///  "type": "object",
    ///  "required": [
    ///    "kind",
    ///    "v6_enabled"
    ///  ],
    ///  "properties": {
    ///    "kind": {
    ///      "description": "What kind of switch interface this configuration
    /// represents.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchInterfaceKind"
    ///        }
    ///      ]
    ///    },
    ///    "v6_enabled": {
    ///      "description": "Whether or not IPv6 is enabled.",
    ///      "type": "boolean"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchInterfaceConfigCreate {
        /// What kind of switch interface this configuration represents.
        pub kind: SwitchInterfaceKind,
        /// Whether or not IPv6 is enabled.
        pub v6_enabled: bool,
    }

    impl ::std::convert::From<&SwitchInterfaceConfigCreate> for SwitchInterfaceConfigCreate {
        fn from(value: &SwitchInterfaceConfigCreate) -> Self {
            value.clone()
        }
    }

    impl SwitchInterfaceConfigCreate {
        pub fn builder() -> builder::SwitchInterfaceConfigCreate {
            Default::default()
        }
    }

    /// Indicates the kind for a switch interface.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Indicates the kind for a switch interface.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Primary interfaces are associated with physical
    /// links. There is exactly one primary interface per physical link.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "primary"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "VLAN interfaces allow physical interfaces to be
    /// multiplexed onto multiple logical links, each distinguished by a 12-bit
    /// 802.1Q Ethernet tag.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "vid"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vlan"
    ///          ]
    ///        },
    ///        "vid": {
    ///          "description": "The virtual network id (VID) that distinguishes
    /// this interface and is used for producing and consuming 802.1Q Ethernet
    /// tags. This field has a maximum value of 4095 as 802.1Q tags are twelve
    /// bits.",
    ///          "type": "integer",
    ///          "format": "uint16",
    ///          "minimum": 0.0
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Loopback interfaces are anchors for IP addresses
    /// that are not specific to any particular port.",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "loopback"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "vid")]
    pub enum SwitchInterfaceKind {
        #[serde(rename = "primary")]
        Primary,
        /// VLAN interfaces allow physical interfaces to be multiplexed onto
        /// multiple logical links, each distinguished by a 12-bit 802.1Q
        /// Ethernet tag.
        #[serde(rename = "vlan")]
        Vlan(u16),
        #[serde(rename = "loopback")]
        Loopback,
    }

    impl ::std::convert::From<&Self> for SwitchInterfaceKind {
        fn from(value: &SwitchInterfaceKind) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<u16> for SwitchInterfaceKind {
        fn from(value: u16) -> Self {
            Self::Vlan(value)
        }
    }

    /// Describes the kind of an switch interface.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Describes the kind of an switch interface.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Primary interfaces are associated with physical
    /// links. There is exactly one primary interface per physical link.",
    ///      "type": "string",
    ///      "enum": [
    ///        "primary"
    ///      ]
    ///    },
    ///    {
    ///      "description": "VLAN interfaces allow physical interfaces to be
    /// multiplexed onto multiple logical links, each distinguished by a 12-bit
    /// 802.1Q Ethernet tag.",
    ///      "type": "string",
    ///      "enum": [
    ///        "vlan"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Loopback interfaces are anchors for IP addresses
    /// that are not specific to any particular port.",
    ///      "type": "string",
    ///      "enum": [
    ///        "loopback"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SwitchInterfaceKind2 {
        /// Primary interfaces are associated with physical links. There is
        /// exactly one primary interface per physical link.
        #[serde(rename = "primary")]
        Primary,
        /// VLAN interfaces allow physical interfaces to be multiplexed onto
        /// multiple logical links, each distinguished by a 12-bit 802.1Q
        /// Ethernet tag.
        #[serde(rename = "vlan")]
        Vlan,
        /// Loopback interfaces are anchors for IP addresses that are not
        /// specific to any particular port.
        #[serde(rename = "loopback")]
        Loopback,
    }

    impl ::std::convert::From<&Self> for SwitchInterfaceKind2 {
        fn from(value: &SwitchInterfaceKind2) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SwitchInterfaceKind2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Primary => write!(f, "primary"),
                Self::Vlan => write!(f, "vlan"),
                Self::Loopback => write!(f, "loopback"),
            }
        }
    }

    impl ::std::str::FromStr for SwitchInterfaceKind2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "primary" => Ok(Self::Primary),
                "vlan" => Ok(Self::Vlan),
                "loopback" => Ok(Self::Loopback),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SwitchInterfaceKind2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SwitchInterfaceKind2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SwitchInterfaceKind2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `SwitchLinkState`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {}
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct SwitchLinkState(pub ::serde_json::Value);
    impl ::std::ops::Deref for SwitchLinkState {
        type Target = ::serde_json::Value;
        fn deref(&self) -> &::serde_json::Value {
            &self.0
        }
    }

    impl ::std::convert::From<SwitchLinkState> for ::serde_json::Value {
        fn from(value: SwitchLinkState) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&SwitchLinkState> for SwitchLinkState {
        fn from(value: &SwitchLinkState) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::serde_json::Value> for SwitchLinkState {
        fn from(value: ::serde_json::Value) -> Self {
            Self(value)
        }
    }

    /// Identifies switch physical location
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Identifies switch physical location",
    ///  "oneOf": [
    ///    {
    ///      "description": "Switch in upper slot",
    ///      "type": "string",
    ///      "enum": [
    ///        "switch0"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Switch in lower slot",
    ///      "type": "string",
    ///      "enum": [
    ///        "switch1"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SwitchLocation {
        /// Switch in upper slot
        #[serde(rename = "switch0")]
        Switch0,
        /// Switch in lower slot
        #[serde(rename = "switch1")]
        Switch1,
    }

    impl ::std::convert::From<&Self> for SwitchLocation {
        fn from(value: &SwitchLocation) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SwitchLocation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Switch0 => write!(f, "switch0"),
                Self::Switch1 => write!(f, "switch1"),
            }
        }
    }

    impl ::std::str::FromStr for SwitchLocation {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "switch0" => Ok(Self::Switch0),
                "switch1" => Ok(Self::Switch1),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SwitchLocation {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SwitchLocation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SwitchLocation {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A switch port represents a physical external port on a rack switch.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A switch port represents a physical external port on a
    /// rack switch.",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "port_name",
    ///    "rack_id",
    ///    "switch_location"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "The id of the switch port.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "port_name": {
    ///      "description": "The name of this switch port.",
    ///      "type": "string"
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The primary settings group of this switch port.
    /// Will be `None` until this switch port is configured.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "rack_id": {
    ///      "description": "The rack this switch port belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "switch_location": {
    ///      "description": "The switch location of this switch port.",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPort {
        /// The id of the switch port.
        pub id: ::uuid::Uuid,
        /// The name of this switch port.
        pub port_name: ::std::string::String,
        /// The primary settings group of this switch port. Will be `None` until
        /// this switch port is configured.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub port_settings_id: ::std::option::Option<::uuid::Uuid>,
        /// The rack this switch port belongs to.
        pub rack_id: ::uuid::Uuid,
        /// The switch location of this switch port.
        pub switch_location: ::std::string::String,
    }

    impl ::std::convert::From<&SwitchPort> for SwitchPort {
        fn from(value: &SwitchPort) -> Self {
            value.clone()
        }
    }

    impl SwitchPort {
        pub fn builder() -> builder::SwitchPort {
            Default::default()
        }
    }

    /// An IP address configuration for a port settings object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An IP address configuration for a port settings
    /// object.",
    ///  "type": "object",
    ///  "required": [
    ///    "address",
    ///    "address_lot_block_id",
    ///    "interface_name",
    ///    "port_settings_id"
    ///  ],
    ///  "properties": {
    ///    "address": {
    ///      "description": "The IP address and prefix.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    },
    ///    "address_lot_block_id": {
    ///      "description": "The id of the address lot block this address is
    /// drawn from.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "interface_name": {
    ///      "description": "The interface name this address belongs to.",
    ///      "type": "string"
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The port settings object this address configuration
    /// belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "vlan_id": {
    ///      "description": "An optional VLAN ID",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortAddressConfig {
        /// The IP address and prefix.
        pub address: IpNet,
        /// The id of the address lot block this address is drawn from.
        pub address_lot_block_id: ::uuid::Uuid,
        /// The interface name this address belongs to.
        pub interface_name: ::std::string::String,
        /// The port settings object this address configuration belongs to.
        pub port_settings_id: ::uuid::Uuid,
        /// An optional VLAN ID
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vlan_id: ::std::option::Option<u16>,
    }

    impl ::std::convert::From<&SwitchPortAddressConfig> for SwitchPortAddressConfig {
        fn from(value: &SwitchPortAddressConfig) -> Self {
            value.clone()
        }
    }

    impl SwitchPortAddressConfig {
        pub fn builder() -> builder::SwitchPortAddressConfig {
            Default::default()
        }
    }

    /// Parameters for applying settings to switch ports.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for applying settings to switch ports.",
    ///  "type": "object",
    ///  "required": [
    ///    "port_settings"
    ///  ],
    ///  "properties": {
    ///    "port_settings": {
    ///      "description": "A name or id to use when applying switch port
    /// settings.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/NameOrId"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortApplySettings {
        /// A name or id to use when applying switch port settings.
        pub port_settings: NameOrId,
    }

    impl ::std::convert::From<&SwitchPortApplySettings> for SwitchPortApplySettings {
        fn from(value: &SwitchPortApplySettings) -> Self {
            value.clone()
        }
    }

    impl SwitchPortApplySettings {
        pub fn builder() -> builder::SwitchPortApplySettings {
            Default::default()
        }
    }

    /// A physical port configuration for a port settings object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A physical port configuration for a port settings
    /// object.",
    ///  "type": "object",
    ///  "required": [
    ///    "geometry",
    ///    "port_settings_id"
    ///  ],
    ///  "properties": {
    ///    "geometry": {
    ///      "description": "The physical link geometry of the port.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchPortGeometry2"
    ///        }
    ///      ]
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The id of the port settings object this
    /// configuration belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortConfig {
        /// The physical link geometry of the port.
        pub geometry: SwitchPortGeometry2,
        /// The id of the port settings object this configuration belongs to.
        pub port_settings_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&SwitchPortConfig> for SwitchPortConfig {
        fn from(value: &SwitchPortConfig) -> Self {
            value.clone()
        }
    }

    impl SwitchPortConfig {
        pub fn builder() -> builder::SwitchPortConfig {
            Default::default()
        }
    }

    /// Physical switch port configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Physical switch port configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "geometry"
    ///  ],
    ///  "properties": {
    ///    "geometry": {
    ///      "description": "Link geometry for the switch port.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchPortGeometry"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortConfigCreate {
        /// Link geometry for the switch port.
        pub geometry: SwitchPortGeometry,
    }

    impl ::std::convert::From<&SwitchPortConfigCreate> for SwitchPortConfigCreate {
        fn from(value: &SwitchPortConfigCreate) -> Self {
            value.clone()
        }
    }

    impl SwitchPortConfigCreate {
        pub fn builder() -> builder::SwitchPortConfigCreate {
            Default::default()
        }
    }

    /// The link geometry associated with a switch port.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The link geometry associated with a switch port.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The port contains a single QSFP28 link with four
    /// lanes.",
    ///      "type": "string",
    ///      "enum": [
    ///        "qsfp28x1"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The port contains two QSFP28 links each with two
    /// lanes.",
    ///      "type": "string",
    ///      "enum": [
    ///        "qsfp28x2"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The port contains four SFP28 links each with one
    /// lane.",
    ///      "type": "string",
    ///      "enum": [
    ///        "sfp28x4"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SwitchPortGeometry {
        /// The port contains a single QSFP28 link with four lanes.
        #[serde(rename = "qsfp28x1")]
        Qsfp28x1,
        /// The port contains two QSFP28 links each with two lanes.
        #[serde(rename = "qsfp28x2")]
        Qsfp28x2,
        /// The port contains four SFP28 links each with one lane.
        #[serde(rename = "sfp28x4")]
        Sfp28x4,
    }

    impl ::std::convert::From<&Self> for SwitchPortGeometry {
        fn from(value: &SwitchPortGeometry) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SwitchPortGeometry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Qsfp28x1 => write!(f, "qsfp28x1"),
                Self::Qsfp28x2 => write!(f, "qsfp28x2"),
                Self::Sfp28x4 => write!(f, "sfp28x4"),
            }
        }
    }

    impl ::std::str::FromStr for SwitchPortGeometry {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "qsfp28x1" => Ok(Self::Qsfp28x1),
                "qsfp28x2" => Ok(Self::Qsfp28x2),
                "sfp28x4" => Ok(Self::Sfp28x4),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SwitchPortGeometry {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SwitchPortGeometry {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SwitchPortGeometry {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The link geometry associated with a switch port.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The link geometry associated with a switch port.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The port contains a single QSFP28 link with four
    /// lanes.",
    ///      "type": "string",
    ///      "enum": [
    ///        "qsfp28x1"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The port contains two QSFP28 links each with two
    /// lanes.",
    ///      "type": "string",
    ///      "enum": [
    ///        "qsfp28x2"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The port contains four SFP28 links each with one
    /// lane.",
    ///      "type": "string",
    ///      "enum": [
    ///        "sfp28x4"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SwitchPortGeometry2 {
        /// The port contains a single QSFP28 link with four lanes.
        #[serde(rename = "qsfp28x1")]
        Qsfp28x1,
        /// The port contains two QSFP28 links each with two lanes.
        #[serde(rename = "qsfp28x2")]
        Qsfp28x2,
        /// The port contains four SFP28 links each with one lane.
        #[serde(rename = "sfp28x4")]
        Sfp28x4,
    }

    impl ::std::convert::From<&Self> for SwitchPortGeometry2 {
        fn from(value: &SwitchPortGeometry2) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SwitchPortGeometry2 {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Qsfp28x1 => write!(f, "qsfp28x1"),
                Self::Qsfp28x2 => write!(f, "qsfp28x2"),
                Self::Sfp28x4 => write!(f, "sfp28x4"),
            }
        }
    }

    impl ::std::str::FromStr for SwitchPortGeometry2 {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "qsfp28x1" => Ok(Self::Qsfp28x1),
                "qsfp28x2" => Ok(Self::Qsfp28x2),
                "sfp28x4" => Ok(Self::Sfp28x4),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SwitchPortGeometry2 {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SwitchPortGeometry2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SwitchPortGeometry2 {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A link configuration for a port settings object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A link configuration for a port settings object.",
    ///  "type": "object",
    ///  "required": [
    ///    "autoneg",
    ///    "link_name",
    ///    "mtu",
    ///    "port_settings_id",
    ///    "speed"
    ///  ],
    ///  "properties": {
    ///    "autoneg": {
    ///      "description": "Whether or not the link has autonegotiation
    /// enabled.",
    ///      "type": "boolean"
    ///    },
    ///    "fec": {
    ///      "description": "The requested forward-error correction method.  If
    /// this is not specified, the standard FEC for the underlying media will be
    /// applied if it can be determined.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/LinkFec"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "link_name": {
    ///      "description": "The name of this link.",
    ///      "type": "string"
    ///    },
    ///    "lldp_link_config_id": {
    ///      "description": "The link-layer discovery protocol service
    /// configuration id for this link.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "mtu": {
    ///      "description": "The maximum transmission unit for this link.",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The port settings this link configuration belongs
    /// to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "speed": {
    ///      "description": "The configured speed of the link.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/LinkSpeed"
    ///        }
    ///      ]
    ///    },
    ///    "tx_eq_config_id": {
    ///      "description": "The tx_eq configuration id for this link.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortLinkConfig {
        /// Whether or not the link has autonegotiation enabled.
        pub autoneg: bool,
        /// The requested forward-error correction method.  If this is not
        /// specified, the standard FEC for the underlying media will be applied
        /// if it can be determined.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub fec: ::std::option::Option<LinkFec>,
        /// The name of this link.
        pub link_name: ::std::string::String,
        /// The link-layer discovery protocol service configuration id for this
        /// link.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub lldp_link_config_id: ::std::option::Option<::uuid::Uuid>,
        /// The maximum transmission unit for this link.
        pub mtu: u16,
        /// The port settings this link configuration belongs to.
        pub port_settings_id: ::uuid::Uuid,
        /// The configured speed of the link.
        pub speed: LinkSpeed,
        /// The tx_eq configuration id for this link.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub tx_eq_config_id: ::std::option::Option<::uuid::Uuid>,
    }

    impl ::std::convert::From<&SwitchPortLinkConfig> for SwitchPortLinkConfig {
        fn from(value: &SwitchPortLinkConfig) -> Self {
            value.clone()
        }
    }

    impl SwitchPortLinkConfig {
        pub fn builder() -> builder::SwitchPortLinkConfig {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchPort"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SwitchPort>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SwitchPortResultsPage> for SwitchPortResultsPage {
        fn from(value: &SwitchPortResultsPage) -> Self {
            value.clone()
        }
    }

    impl SwitchPortResultsPage {
        pub fn builder() -> builder::SwitchPortResultsPage {
            Default::default()
        }
    }

    /// A route configuration for a port settings object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A route configuration for a port settings object.",
    ///  "type": "object",
    ///  "required": [
    ///    "dst",
    ///    "gw",
    ///    "interface_name",
    ///    "port_settings_id"
    ///  ],
    ///  "properties": {
    ///    "dst": {
    ///      "description": "The route's destination network.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    },
    ///    "gw": {
    ///      "description": "The route's gateway address.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      ]
    ///    },
    ///    "interface_name": {
    ///      "description": "The interface name this route configuration is
    /// assigned to.",
    ///      "type": "string"
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The port settings object this route configuration
    /// belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "rib_priority": {
    ///      "description": "RIB Priority indicating priority within and across
    /// protocols.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint8",
    ///      "minimum": 0.0
    ///    },
    ///    "vlan_id": {
    ///      "description": "The VLAN identifier for the route. Use this if the
    /// gateway is reachable over an 802.1Q tagged L2 segment.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortRouteConfig {
        /// The route's destination network.
        pub dst: IpNet,
        /// The route's gateway address.
        pub gw: IpNet,
        /// The interface name this route configuration is assigned to.
        pub interface_name: ::std::string::String,
        /// The port settings object this route configuration belongs to.
        pub port_settings_id: ::uuid::Uuid,
        /// RIB Priority indicating priority within and across protocols.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub rib_priority: ::std::option::Option<u8>,
        /// The VLAN identifier for the route. Use this if the gateway is
        /// reachable over an 802.1Q tagged L2 segment.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub vlan_id: ::std::option::Option<u16>,
    }

    impl ::std::convert::From<&SwitchPortRouteConfig> for SwitchPortRouteConfig {
        fn from(value: &SwitchPortRouteConfig) -> Self {
            value.clone()
        }
    }

    impl SwitchPortRouteConfig {
        pub fn builder() -> builder::SwitchPortRouteConfig {
            Default::default()
        }
    }

    /// A switch port settings identity whose id may be used to view additional
    /// details.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A switch port settings identity whose id may be used to
    /// view additional details.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortSettings {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&SwitchPortSettings> for SwitchPortSettings {
        fn from(value: &SwitchPortSettings) -> Self {
            value.clone()
        }
    }

    impl SwitchPortSettings {
        pub fn builder() -> builder::SwitchPortSettings {
            Default::default()
        }
    }

    /// Parameters for creating switch port settings. Switch port settings are
    /// the central data structure for setting up external networking. Switch
    /// port settings include link, interface, route, address and dynamic
    /// network protocol configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for creating switch port settings. Switch
    /// port settings are the central data structure for setting up external
    /// networking. Switch port settings include link, interface, route, address
    /// and dynamic network protocol configuration.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "bgp_peers",
    ///    "description",
    ///    "groups",
    ///    "interfaces",
    ///    "links",
    ///    "name",
    ///    "port_config",
    ///    "routes"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "Addresses indexed by interface name.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/AddressConfig"
    ///      }
    ///    },
    ///    "bgp_peers": {
    ///      "description": "BGP peers indexed by interface name.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/BgpPeerConfig"
    ///      }
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "groups": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/NameOrId"
    ///      }
    ///    },
    ///    "interfaces": {
    ///      "description": "Interfaces indexed by link name.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/SwitchInterfaceConfigCreate"
    ///      }
    ///    },
    ///    "links": {
    ///      "description": "Links indexed by phy name. On ports that are not
    /// broken out, this is always phy0. On a 2x breakout the options are phy0
    /// and phy1, on 4x phy0-phy3, etc.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/LinkConfigCreate"
    ///      }
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "port_config": {
    ///      "$ref": "#/components/schemas/SwitchPortConfigCreate"
    ///    },
    ///    "routes": {
    ///      "description": "Routes indexed by interface name.",
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/RouteConfig"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortSettingsCreate {
        /// Addresses indexed by interface name.
        pub addresses: ::std::collections::HashMap<::std::string::String, AddressConfig>,
        /// BGP peers indexed by interface name.
        pub bgp_peers: ::std::collections::HashMap<::std::string::String, BgpPeerConfig>,
        pub description: ::std::string::String,
        pub groups: ::std::vec::Vec<NameOrId>,
        /// Interfaces indexed by link name.
        pub interfaces:
            ::std::collections::HashMap<::std::string::String, SwitchInterfaceConfigCreate>,
        /// Links indexed by phy name. On ports that are not broken out, this is
        /// always phy0. On a 2x breakout the options are phy0 and phy1, on 4x
        /// phy0-phy3, etc.
        pub links: ::std::collections::HashMap<::std::string::String, LinkConfigCreate>,
        pub name: Name,
        pub port_config: SwitchPortConfigCreate,
        /// Routes indexed by interface name.
        pub routes: ::std::collections::HashMap<::std::string::String, RouteConfig>,
    }

    impl ::std::convert::From<&SwitchPortSettingsCreate> for SwitchPortSettingsCreate {
        fn from(value: &SwitchPortSettingsCreate) -> Self {
            value.clone()
        }
    }

    impl SwitchPortSettingsCreate {
        pub fn builder() -> builder::SwitchPortSettingsCreate {
            Default::default()
        }
    }

    /// This structure maps a port settings object to a port settings groups.
    /// Port settings objects may inherit settings from groups. This mapping
    /// defines the relationship between settings objects and the groups they
    /// reference.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "This structure maps a port settings object to a port
    /// settings groups. Port settings objects may inherit settings from groups.
    /// This mapping defines the relationship between settings objects and the
    /// groups they reference.",
    ///  "type": "object",
    ///  "required": [
    ///    "port_settings_group_id",
    ///    "port_settings_id"
    ///  ],
    ///  "properties": {
    ///    "port_settings_group_id": {
    ///      "description": "The id of a port settings group being referenced by
    /// a port settings object.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "port_settings_id": {
    ///      "description": "The id of a port settings object referencing a port
    /// settings group.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortSettingsGroups {
        /// The id of a port settings group being referenced by a port settings
        /// object.
        pub port_settings_group_id: ::uuid::Uuid,
        /// The id of a port settings object referencing a port settings group.
        pub port_settings_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&SwitchPortSettingsGroups> for SwitchPortSettingsGroups {
        fn from(value: &SwitchPortSettingsGroups) -> Self {
            value.clone()
        }
    }

    impl SwitchPortSettingsGroups {
        pub fn builder() -> builder::SwitchPortSettingsGroups {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchPortSettings"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortSettingsResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<SwitchPortSettings>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SwitchPortSettingsResultsPage> for SwitchPortSettingsResultsPage {
        fn from(value: &SwitchPortSettingsResultsPage) -> Self {
            value.clone()
        }
    }

    impl SwitchPortSettingsResultsPage {
        pub fn builder() -> builder::SwitchPortSettingsResultsPage {
            Default::default()
        }
    }

    /// This structure contains all port settings information in one place. It's
    /// a convenience data structure for getting a complete view of a particular
    /// port's settings.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "This structure contains all port settings information
    /// in one place. It's a convenience data structure for getting a complete
    /// view of a particular port's settings.",
    ///  "type": "object",
    ///  "required": [
    ///    "addresses",
    ///    "bgp_peers",
    ///    "groups",
    ///    "interfaces",
    ///    "link_lldp",
    ///    "links",
    ///    "port",
    ///    "routes",
    ///    "settings",
    ///    "tx_eq",
    ///    "vlan_interfaces"
    ///  ],
    ///  "properties": {
    ///    "addresses": {
    ///      "description": "Layer 3 IP address settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchPortAddressConfig"
    ///      }
    ///    },
    ///    "bgp_peers": {
    ///      "description": "BGP peer settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/BgpPeer"
    ///      }
    ///    },
    ///    "groups": {
    ///      "description": "Switch port settings included from other switch
    /// port settings groups.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchPortSettingsGroups"
    ///      }
    ///    },
    ///    "interfaces": {
    ///      "description": "Layer 3 interface settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchInterfaceConfig"
    ///      }
    ///    },
    ///    "link_lldp": {
    ///      "description": "Link-layer discovery protocol (LLDP) settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/LldpLinkConfig"
    ///      }
    ///    },
    ///    "links": {
    ///      "description": "Layer 2 link settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchPortLinkConfig"
    ///      }
    ///    },
    ///    "port": {
    ///      "description": "Layer 1 physical port settings.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchPortConfig"
    ///        }
    ///      ]
    ///    },
    ///    "routes": {
    ///      "description": "IP route settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchPortRouteConfig"
    ///      }
    ///    },
    ///    "settings": {
    ///      "description": "The primary switch port settings handle.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/SwitchPortSettings"
    ///        }
    ///      ]
    ///    },
    ///    "tx_eq": {
    ///      "description": "TX equalization settings.  These are optional, and
    /// most links will not need them.",
    ///      "type": "array",
    ///      "items": {
    ///        "oneOf": [
    ///          {
    ///            "type": "null"
    ///          },
    ///          {
    ///            "allOf": [
    ///              {
    ///                "$ref": "#/components/schemas/TxEqConfig"
    ///              }
    ///            ]
    ///          }
    ///        ]
    ///      }
    ///    },
    ///    "vlan_interfaces": {
    ///      "description": "Vlan interface settings.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/SwitchVlanInterfaceConfig"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchPortSettingsView {
        /// Layer 3 IP address settings.
        pub addresses: ::std::vec::Vec<SwitchPortAddressConfig>,
        /// BGP peer settings.
        pub bgp_peers: ::std::vec::Vec<BgpPeer>,
        /// Switch port settings included from other switch port settings
        /// groups.
        pub groups: ::std::vec::Vec<SwitchPortSettingsGroups>,
        /// Layer 3 interface settings.
        pub interfaces: ::std::vec::Vec<SwitchInterfaceConfig>,
        /// Link-layer discovery protocol (LLDP) settings.
        pub link_lldp: ::std::vec::Vec<LldpLinkConfig>,
        /// Layer 2 link settings.
        pub links: ::std::vec::Vec<SwitchPortLinkConfig>,
        /// Layer 1 physical port settings.
        pub port: SwitchPortConfig,
        /// IP route settings.
        pub routes: ::std::vec::Vec<SwitchPortRouteConfig>,
        /// The primary switch port settings handle.
        pub settings: SwitchPortSettings,
        /// TX equalization settings.  These are optional, and most links will
        /// not need them.
        pub tx_eq: ::std::vec::Vec<::std::option::Option<TxEqConfig>>,
        /// Vlan interface settings.
        pub vlan_interfaces: ::std::vec::Vec<SwitchVlanInterfaceConfig>,
    }

    impl ::std::convert::From<&SwitchPortSettingsView> for SwitchPortSettingsView {
        fn from(value: &SwitchPortSettingsView) -> Self {
            value.clone()
        }
    }

    impl SwitchPortSettingsView {
        pub fn builder() -> builder::SwitchPortSettingsView {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Switch"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Switch>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&SwitchResultsPage> for SwitchResultsPage {
        fn from(value: &SwitchResultsPage) -> Self {
            value.clone()
        }
    }

    impl SwitchResultsPage {
        pub fn builder() -> builder::SwitchResultsPage {
            Default::default()
        }
    }

    /// A switch port VLAN interface configuration for a port settings object.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A switch port VLAN interface configuration for a port
    /// settings object.",
    ///  "type": "object",
    ///  "required": [
    ///    "interface_config_id",
    ///    "vlan_id"
    ///  ],
    ///  "properties": {
    ///    "interface_config_id": {
    ///      "description": "The switch interface configuration this VLAN
    /// interface configuration belongs to.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "vlan_id": {
    ///      "description": "The virtual network id for this interface that is
    /// used for producing and consuming 802.1Q Ethernet tags. This field has a
    /// maximum value of 4095 as 802.1Q tags are twelve bits.",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct SwitchVlanInterfaceConfig {
        /// The switch interface configuration this VLAN interface configuration
        /// belongs to.
        pub interface_config_id: ::uuid::Uuid,
        /// The virtual network id for this interface that is used for producing
        /// and consuming 802.1Q Ethernet tags. This field has a maximum value
        /// of 4095 as 802.1Q tags are twelve bits.
        pub vlan_id: u16,
    }

    impl ::std::convert::From<&SwitchVlanInterfaceConfig> for SwitchVlanInterfaceConfig {
        fn from(value: &SwitchVlanInterfaceConfig) -> Self {
            value.clone()
        }
    }

    impl SwitchVlanInterfaceConfig {
        pub fn builder() -> builder::SwitchVlanInterfaceConfig {
            Default::default()
        }
    }

    /// `SystemMetricName`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "virtual_disk_space_provisioned",
    ///    "cpus_provisioned",
    ///    "ram_provisioned"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum SystemMetricName {
        #[serde(rename = "virtual_disk_space_provisioned")]
        VirtualDiskSpaceProvisioned,
        #[serde(rename = "cpus_provisioned")]
        CpusProvisioned,
        #[serde(rename = "ram_provisioned")]
        RamProvisioned,
    }

    impl ::std::convert::From<&Self> for SystemMetricName {
        fn from(value: &SystemMetricName) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for SystemMetricName {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::VirtualDiskSpaceProvisioned => write!(f, "virtual_disk_space_provisioned"),
                Self::CpusProvisioned => write!(f, "cpus_provisioned"),
                Self::RamProvisioned => write!(f, "ram_provisioned"),
            }
        }
    }

    impl ::std::str::FromStr for SystemMetricName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "virtual_disk_space_provisioned" => Ok(Self::VirtualDiskSpaceProvisioned),
                "cpus_provisioned" => Ok(Self::CpusProvisioned),
                "ram_provisioned" => Ok(Self::RamProvisioned),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for SystemMetricName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A table represents one or more timeseries with the same schema.
    ///
    /// A table is the result of an OxQL query. It contains a name, usually the
    /// name of the timeseries schema from which the data is derived, and any
    /// number of timeseries, which contain the actual data.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A table represents one or more timeseries with the same schema.\n\nA table is the result of an OxQL query. It contains a name, usually the name of the timeseries schema from which the data is derived, and any number of timeseries, which contain the actual data.",
    ///  "type": "object",
    ///  "required": [
    ///    "name",
    ///    "timeseries"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "type": "string"
    ///    },
    ///    "timeseries": {
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/Timeseries"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Table {
        pub name: ::std::string::String,
        pub timeseries: ::std::collections::HashMap<::std::string::String, Timeseries>,
    }

    impl ::std::convert::From<&Table> for Table {
        fn from(value: &Table) -> Self {
            value.clone()
        }
    }

    impl Table {
        pub fn builder() -> builder::Table {
            Default::default()
        }
    }

    /// View of a system software target release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a system software target release.",
    ///  "type": "object",
    ///  "required": [
    ///    "generation",
    ///    "release_source",
    ///    "time_requested"
    ///  ],
    ///  "properties": {
    ///    "generation": {
    ///      "description": "The target-release generation number.",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "release_source": {
    ///      "description": "The source of the target release.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TargetReleaseSource"
    ///        }
    ///      ]
    ///    },
    ///    "time_requested": {
    ///      "description": "The time it was set as the target release.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct TargetRelease {
        /// The target-release generation number.
        pub generation: i64,
        /// The source of the target release.
        pub release_source: TargetReleaseSource,
        /// The time it was set as the target release.
        pub time_requested: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&TargetRelease> for TargetRelease {
        fn from(value: &TargetRelease) -> Self {
            value.clone()
        }
    }

    impl TargetRelease {
        pub fn builder() -> builder::TargetRelease {
            Default::default()
        }
    }

    /// Source of a system software target release.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Source of a system software target release.",
    ///  "oneOf": [
    ///    {
    ///      "description": "Unspecified or unknown source (probably MUPdate).",
    ///      "type": "object",
    ///      "required": [
    ///        "type"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "unspecified"
    ///          ]
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The specified release of the rack's system
    /// software.",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "version"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "system_version"
    ///          ]
    ///        },
    ///        "version": {
    ///          "type": "string",
    ///          "pattern":
    /// "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*
    /// [a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*
    /// ))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "version")]
    pub enum TargetReleaseSource {
        #[serde(rename = "unspecified")]
        Unspecified,
        /// The specified release of the rack's system software.
        #[serde(rename = "system_version")]
        SystemVersion(TargetReleaseSourceVersion),
    }

    impl ::std::convert::From<&Self> for TargetReleaseSource {
        fn from(value: &TargetReleaseSource) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<TargetReleaseSourceVersion> for TargetReleaseSource {
        fn from(value: TargetReleaseSourceVersion) -> Self {
            Self::SystemVersion(value)
        }
    }

    /// `TargetReleaseSourceVersion`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "pattern":
    /// "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*
    /// [a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*
    /// ))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct TargetReleaseSourceVersion(::std::string::String);
    impl ::std::ops::Deref for TargetReleaseSourceVersion {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<TargetReleaseSourceVersion> for ::std::string::String {
        fn from(value: TargetReleaseSourceVersion) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TargetReleaseSourceVersion> for TargetReleaseSourceVersion {
        fn from(value: &TargetReleaseSourceVersion) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TargetReleaseSourceVersion {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*\
                 [a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\
                 +([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*\
                            |\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*\
                            [a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.\
                            [0-9a-zA-Z-]+)*))?$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TargetReleaseSourceVersion {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TargetReleaseSourceVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TargetReleaseSourceVersion {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TargetReleaseSourceVersion {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// Supported set of sort modes for scanning by timestamp and ID
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Supported set of sort modes for scanning by timestamp
    /// and ID",
    ///  "oneOf": [
    ///    {
    ///      "description": "sort in increasing order of timestamp and ID, i.e.,
    /// earliest first",
    ///      "type": "string",
    ///      "enum": [
    ///        "ascending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "sort in increasing order of timestamp and ID, i.e.,
    /// most recent first",
    ///      "type": "string",
    ///      "enum": [
    ///        "descending"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum TimeAndIdSortMode {
        /// sort in increasing order of timestamp and ID, i.e., earliest first
        #[serde(rename = "ascending")]
        Ascending,
        /// sort in increasing order of timestamp and ID, i.e., most recent
        /// first
        #[serde(rename = "descending")]
        Descending,
    }

    impl ::std::convert::From<&Self> for TimeAndIdSortMode {
        fn from(value: &TimeAndIdSortMode) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for TimeAndIdSortMode {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Ascending => write!(f, "ascending"),
                Self::Descending => write!(f, "descending"),
            }
        }
    }

    impl ::std::str::FromStr for TimeAndIdSortMode {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "ascending" => Ok(Self::Ascending),
                "descending" => Ok(Self::Descending),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for TimeAndIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TimeAndIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TimeAndIdSortMode {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A timeseries contains a timestamped set of values from one source.
    ///
    /// This includes the typed key-value pairs that uniquely identify it, and
    /// the set of timestamps and data values from it.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A timeseries contains a timestamped set of values from
    /// one source.\n\nThis includes the typed key-value pairs that uniquely
    /// identify it, and the set of timestamps and data values from it.",
    ///  "type": "object",
    ///  "required": [
    ///    "fields",
    ///    "points"
    ///  ],
    ///  "properties": {
    ///    "fields": {
    ///      "type": "object",
    ///      "additionalProperties": {
    ///        "$ref": "#/components/schemas/FieldValue"
    ///      }
    ///    },
    ///    "points": {
    ///      "$ref": "#/components/schemas/Points"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Timeseries {
        pub fields: ::std::collections::HashMap<::std::string::String, FieldValue>,
        pub points: Points,
    }

    impl ::std::convert::From<&Timeseries> for Timeseries {
        fn from(value: &Timeseries) -> Self {
            value.clone()
        }
    }

    impl Timeseries {
        pub fn builder() -> builder::Timeseries {
            Default::default()
        }
    }

    /// Text descriptions for the target and metric of a timeseries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Text descriptions for the target and metric of a
    /// timeseries.",
    ///  "type": "object",
    ///  "required": [
    ///    "metric",
    ///    "target"
    ///  ],
    ///  "properties": {
    ///    "metric": {
    ///      "type": "string"
    ///    },
    ///    "target": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct TimeseriesDescription {
        pub metric: ::std::string::String,
        pub target: ::std::string::String,
    }

    impl ::std::convert::From<&TimeseriesDescription> for TimeseriesDescription {
        fn from(value: &TimeseriesDescription) -> Self {
            value.clone()
        }
    }

    impl TimeseriesDescription {
        pub fn builder() -> builder::TimeseriesDescription {
            Default::default()
        }
    }

    /// Names are constructed by concatenating the target and metric names with
    /// ':'. Target and metric names must be lowercase alphanumeric characters
    /// with '_' separating words.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "The name of a timeseries",
    ///  "description": "Names are constructed by concatenating the target and
    /// metric names with ':'. Target and metric names must be lowercase
    /// alphanumeric characters with '_' separating words.",
    ///  "type": "string",
    ///  "pattern":
    /// "^(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*
    /// )$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct TimeseriesName(::std::string::String);
    impl ::std::ops::Deref for TimeseriesName {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<TimeseriesName> for ::std::string::String {
        fn from(value: TimeseriesName) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TimeseriesName> for TimeseriesName {
        fn from(value: &TimeseriesName) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for TimeseriesName {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if regress::Regex::new(
                "^(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)$",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err("doesn't match pattern \
                            \"^(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*\
                            )(_([a-z0-9]+))*)$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for TimeseriesName {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for TimeseriesName {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// A timeseries query string, written in the Oximeter query language.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A timeseries query string, written in the Oximeter
    /// query language.",
    ///  "type": "object",
    ///  "required": [
    ///    "query"
    ///  ],
    ///  "properties": {
    ///    "query": {
    ///      "description": "A timeseries query string, written in the Oximeter
    /// query language.",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct TimeseriesQuery {
        /// A timeseries query string, written in the Oximeter query language.
        pub query: ::std::string::String,
    }

    impl ::std::convert::From<&TimeseriesQuery> for TimeseriesQuery {
        fn from(value: &TimeseriesQuery) -> Self {
            value.clone()
        }
    }

    impl TimeseriesQuery {
        pub fn builder() -> builder::TimeseriesQuery {
            Default::default()
        }
    }

    /// The schema for a timeseries.
    ///
    /// This includes the name of the timeseries, as well as the datum type of
    /// its metric and the schema for each field.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The schema for a timeseries.\n\nThis includes the name
    /// of the timeseries, as well as the datum type of its metric and the
    /// schema for each field.",
    ///  "type": "object",
    ///  "required": [
    ///    "authz_scope",
    ///    "created",
    ///    "datum_type",
    ///    "description",
    ///    "field_schema",
    ///    "timeseries_name",
    ///    "units",
    ///    "version"
    ///  ],
    ///  "properties": {
    ///    "authz_scope": {
    ///      "$ref": "#/components/schemas/AuthzScope"
    ///    },
    ///    "created": {
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "datum_type": {
    ///      "$ref": "#/components/schemas/DatumType"
    ///    },
    ///    "description": {
    ///      "$ref": "#/components/schemas/TimeseriesDescription"
    ///    },
    ///    "field_schema": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/FieldSchema"
    ///      },
    ///      "uniqueItems": true
    ///    },
    ///    "timeseries_name": {
    ///      "$ref": "#/components/schemas/TimeseriesName"
    ///    },
    ///    "units": {
    ///      "$ref": "#/components/schemas/Units"
    ///    },
    ///    "version": {
    ///      "type": "integer",
    ///      "format": "uint8",
    ///      "minimum": 1.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct TimeseriesSchema {
        pub authz_scope: AuthzScope,
        pub created: ::chrono::DateTime<::chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub description: TimeseriesDescription,
        pub field_schema: Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
        pub units: Units,
        pub version: ::std::num::NonZeroU8,
    }

    impl ::std::convert::From<&TimeseriesSchema> for TimeseriesSchema {
        fn from(value: &TimeseriesSchema) -> Self {
            value.clone()
        }
    }

    impl TimeseriesSchema {
        pub fn builder() -> builder::TimeseriesSchema {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TimeseriesSchema"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct TimeseriesSchemaResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<TimeseriesSchema>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&TimeseriesSchemaResultsPage> for TimeseriesSchemaResultsPage {
        fn from(value: &TimeseriesSchemaResultsPage) -> Self {
            value.clone()
        }
    }

    impl TimeseriesSchemaResultsPage {
        pub fn builder() -> builder::TimeseriesSchemaResultsPage {
            Default::default()
        }
    }

    /// Per-port tx-eq overrides.  This can be used to fine-tune the transceiver
    /// equalization settings to improve signal integrity.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Per-port tx-eq overrides.  This can be used to
    /// fine-tune the transceiver equalization settings to improve signal
    /// integrity.",
    ///  "type": "object",
    ///  "properties": {
    ///    "main": {
    ///      "description": "Main tap",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int32"
    ///    },
    ///    "post1": {
    ///      "description": "Post-cursor tap1",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int32"
    ///    },
    ///    "post2": {
    ///      "description": "Post-cursor tap2",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int32"
    ///    },
    ///    "pre1": {
    ///      "description": "Pre-cursor tap1",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int32"
    ///    },
    ///    "pre2": {
    ///      "description": "Pre-cursor tap2",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "int32"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct TxEqConfig {
        /// Main tap
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub main: ::std::option::Option<i32>,
        /// Post-cursor tap1
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub post1: ::std::option::Option<i32>,
        /// Post-cursor tap2
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub post2: ::std::option::Option<i32>,
        /// Pre-cursor tap1
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pre1: ::std::option::Option<i32>,
        /// Pre-cursor tap2
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub pre2: ::std::option::Option<i32>,
    }

    impl ::std::convert::From<&TxEqConfig> for TxEqConfig {
        fn from(value: &TxEqConfig) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for TxEqConfig {
        fn default() -> Self {
            Self {
                main: Default::default(),
                post1: Default::default(),
                post2: Default::default(),
                pre1: Default::default(),
                pre2: Default::default(),
            }
        }
    }

    impl TxEqConfig {
        pub fn builder() -> builder::TxEqConfig {
            Default::default()
        }
    }

    /// `TypedUuidForInstanceKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "format": "uuid"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct TypedUuidForInstanceKind(pub ::uuid::Uuid);
    impl ::std::ops::Deref for TypedUuidForInstanceKind {
        type Target = ::uuid::Uuid;
        fn deref(&self) -> &::uuid::Uuid {
            &self.0
        }
    }

    impl ::std::convert::From<TypedUuidForInstanceKind> for ::uuid::Uuid {
        fn from(value: TypedUuidForInstanceKind) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TypedUuidForInstanceKind> for TypedUuidForInstanceKind {
        fn from(value: &TypedUuidForInstanceKind) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for TypedUuidForInstanceKind {
        fn from(value: ::uuid::Uuid) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for TypedUuidForInstanceKind {
        type Err = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for TypedUuidForInstanceKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TypedUuidForInstanceKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TypedUuidForInstanceKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for TypedUuidForInstanceKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// `TypedUuidForSupportBundleKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "format": "uuid"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct TypedUuidForSupportBundleKind(pub ::uuid::Uuid);
    impl ::std::ops::Deref for TypedUuidForSupportBundleKind {
        type Target = ::uuid::Uuid;
        fn deref(&self) -> &::uuid::Uuid {
            &self.0
        }
    }

    impl ::std::convert::From<TypedUuidForSupportBundleKind> for ::uuid::Uuid {
        fn from(value: TypedUuidForSupportBundleKind) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TypedUuidForSupportBundleKind> for TypedUuidForSupportBundleKind {
        fn from(value: &TypedUuidForSupportBundleKind) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for TypedUuidForSupportBundleKind {
        fn from(value: ::uuid::Uuid) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for TypedUuidForSupportBundleKind {
        type Err = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for TypedUuidForSupportBundleKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TypedUuidForSupportBundleKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TypedUuidForSupportBundleKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for TypedUuidForSupportBundleKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// `TypedUuidForWebhookEventKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "format": "uuid"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct TypedUuidForWebhookEventKind(pub ::uuid::Uuid);
    impl ::std::ops::Deref for TypedUuidForWebhookEventKind {
        type Target = ::uuid::Uuid;
        fn deref(&self) -> &::uuid::Uuid {
            &self.0
        }
    }

    impl ::std::convert::From<TypedUuidForWebhookEventKind> for ::uuid::Uuid {
        fn from(value: TypedUuidForWebhookEventKind) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TypedUuidForWebhookEventKind> for TypedUuidForWebhookEventKind {
        fn from(value: &TypedUuidForWebhookEventKind) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for TypedUuidForWebhookEventKind {
        fn from(value: ::uuid::Uuid) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for TypedUuidForWebhookEventKind {
        type Err = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for TypedUuidForWebhookEventKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TypedUuidForWebhookEventKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TypedUuidForWebhookEventKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for TypedUuidForWebhookEventKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// `TypedUuidForWebhookReceiverKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "format": "uuid"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct TypedUuidForWebhookReceiverKind(pub ::uuid::Uuid);
    impl ::std::ops::Deref for TypedUuidForWebhookReceiverKind {
        type Target = ::uuid::Uuid;
        fn deref(&self) -> &::uuid::Uuid {
            &self.0
        }
    }

    impl ::std::convert::From<TypedUuidForWebhookReceiverKind> for ::uuid::Uuid {
        fn from(value: TypedUuidForWebhookReceiverKind) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&TypedUuidForWebhookReceiverKind> for TypedUuidForWebhookReceiverKind {
        fn from(value: &TypedUuidForWebhookReceiverKind) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::uuid::Uuid> for TypedUuidForWebhookReceiverKind {
        fn from(value: ::uuid::Uuid) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for TypedUuidForWebhookReceiverKind {
        type Err = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for TypedUuidForWebhookReceiverKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for TypedUuidForWebhookReceiverKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for TypedUuidForWebhookReceiverKind {
        type Error = <::uuid::Uuid as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for TypedUuidForWebhookReceiverKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// A sled that has not been added to an initialized rack yet
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A sled that has not been added to an initialized rack
    /// yet",
    ///  "type": "object",
    ///  "required": [
    ///    "baseboard",
    ///    "cubby",
    ///    "rack_id"
    ///  ],
    ///  "properties": {
    ///    "baseboard": {
    ///      "$ref": "#/components/schemas/Baseboard"
    ///    },
    ///    "cubby": {
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "rack_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UninitializedSled {
        pub baseboard: Baseboard,
        pub cubby: u16,
        pub rack_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&UninitializedSled> for UninitializedSled {
        fn from(value: &UninitializedSled) -> Self {
            value.clone()
        }
    }

    impl UninitializedSled {
        pub fn builder() -> builder::UninitializedSled {
            Default::default()
        }
    }

    /// The unique hardware ID for a sled
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The unique hardware ID for a sled",
    ///  "type": "object",
    ///  "required": [
    ///    "part",
    ///    "serial"
    ///  ],
    ///  "properties": {
    ///    "part": {
    ///      "type": "string"
    ///    },
    ///    "serial": {
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UninitializedSledId {
        pub part: ::std::string::String,
        pub serial: ::std::string::String,
    }

    impl ::std::convert::From<&UninitializedSledId> for UninitializedSledId {
        fn from(value: &UninitializedSledId) -> Self {
            value.clone()
        }
    }

    impl UninitializedSledId {
        pub fn builder() -> builder::UninitializedSledId {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UninitializedSled"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UninitializedSledResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<UninitializedSled>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UninitializedSledResultsPage> for UninitializedSledResultsPage {
        fn from(value: &UninitializedSledResultsPage) -> Self {
            value.clone()
        }
    }

    impl UninitializedSledResultsPage {
        pub fn builder() -> builder::UninitializedSledResultsPage {
            Default::default()
        }
    }

    /// Measurement units for timeseries samples.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Measurement units for timeseries samples.",
    ///  "oneOf": [
    ///    {
    ///      "type": "string",
    ///      "enum": [
    ///        "count",
    ///        "bytes",
    ///        "seconds",
    ///        "nanoseconds",
    ///        "volts",
    ///        "amps",
    ///        "watts",
    ///        "degrees_celsius"
    ///      ]
    ///    },
    ///    {
    ///      "description": "No meaningful units, e.g. a dimensionless
    /// quanity.",
    ///      "type": "string",
    ///      "enum": [
    ///        "none"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Rotations per minute.",
    ///      "type": "string",
    ///      "enum": [
    ///        "rpm"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum Units {
        #[serde(rename = "count")]
        Count,
        #[serde(rename = "bytes")]
        Bytes,
        #[serde(rename = "seconds")]
        Seconds,
        #[serde(rename = "nanoseconds")]
        Nanoseconds,
        #[serde(rename = "volts")]
        Volts,
        #[serde(rename = "amps")]
        Amps,
        #[serde(rename = "watts")]
        Watts,
        #[serde(rename = "degrees_celsius")]
        DegreesCelsius,
        /// No meaningful units, e.g. a dimensionless quanity.
        #[serde(rename = "none")]
        None,
        /// Rotations per minute.
        #[serde(rename = "rpm")]
        Rpm,
    }

    impl ::std::convert::From<&Self> for Units {
        fn from(value: &Units) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for Units {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Count => write!(f, "count"),
                Self::Bytes => write!(f, "bytes"),
                Self::Seconds => write!(f, "seconds"),
                Self::Nanoseconds => write!(f, "nanoseconds"),
                Self::Volts => write!(f, "volts"),
                Self::Amps => write!(f, "amps"),
                Self::Watts => write!(f, "watts"),
                Self::DegreesCelsius => write!(f, "degrees_celsius"),
                Self::None => write!(f, "none"),
                Self::Rpm => write!(f, "rpm"),
            }
        }
    }

    impl ::std::str::FromStr for Units {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "count" => Ok(Self::Count),
                "bytes" => Ok(Self::Bytes),
                "seconds" => Ok(Self::Seconds),
                "nanoseconds" => Ok(Self::Nanoseconds),
                "volts" => Ok(Self::Volts),
                "amps" => Ok(Self::Amps),
                "watts" => Ok(Self::Watts),
                "degrees_celsius" => Ok(Self::DegreesCelsius),
                "none" => Ok(Self::None),
                "rpm" => Ok(Self::Rpm),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for Units {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for Units {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for Units {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// View of a User
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a User",
    ///  "type": "object",
    ///  "required": [
    ///    "display_name",
    ///    "id",
    ///    "silo_id"
    ///  ],
    ///  "properties": {
    ///    "display_name": {
    ///      "description": "Human-readable name that can identify the user",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "silo_id": {
    ///      "description": "Uuid of the silo to which this user belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct User {
        /// Human-readable name that can identify the user
        pub display_name: ::std::string::String,
        pub id: ::uuid::Uuid,
        /// Uuid of the silo to which this user belongs
        pub silo_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    impl User {
        pub fn builder() -> builder::User {
            Default::default()
        }
    }

    /// View of a Built-in User
    ///
    /// Built-in users are identities internal to the system, used when the
    /// control plane performs actions autonomously
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a Built-in User\n\nBuilt-in users are
    /// identities internal to the system, used when the control plane performs
    /// actions autonomously",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "name",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UserBuiltin {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&UserBuiltin> for UserBuiltin {
        fn from(value: &UserBuiltin) -> Self {
            value.clone()
        }
    }

    impl UserBuiltin {
        pub fn builder() -> builder::UserBuiltin {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/UserBuiltin"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UserBuiltinResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<UserBuiltin>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserBuiltinResultsPage> for UserBuiltinResultsPage {
        fn from(value: &UserBuiltinResultsPage) -> Self {
            value.clone()
        }
    }

    impl UserBuiltinResultsPage {
        pub fn builder() -> builder::UserBuiltinResultsPage {
            Default::default()
        }
    }

    /// Create-time parameters for a `User`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `User`",
    ///  "type": "object",
    ///  "required": [
    ///    "external_id",
    ///    "password"
    ///  ],
    ///  "properties": {
    ///    "external_id": {
    ///      "description": "username used to log in",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/UserId"
    ///        }
    ///      ]
    ///    },
    ///    "password": {
    ///      "description": "how to set the user's login password",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/UserPassword"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UserCreate {
        /// username used to log in
        pub external_id: UserId,
        /// how to set the user's login password
        pub password: UserPassword,
    }

    impl ::std::convert::From<&UserCreate> for UserCreate {
        fn from(value: &UserCreate) -> Self {
            value.clone()
        }
    }

    impl UserCreate {
        pub fn builder() -> builder::UserCreate {
            Default::default()
        }
    }

    /// Usernames must begin with a lower case ASCII letter, be composed
    /// exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and
    /// may not end with a '-'. Usernames cannot be a UUID, but they may contain
    /// a UUID. They can be at most 63 characters long.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A username for a local-only user",
    ///  "description": "Usernames must begin with a lower case ASCII letter, be
    /// composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and
    /// '-', and may not end with a '-'. Usernames cannot be a UUID, but they
    /// may contain a UUID. They can be at most 63 characters long.",
    ///  "type": "string",
    ///  "maxLength": 63,
    ///  "minLength": 1,
    ///  "pattern":
    /// "^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*
    /// [a-zA-Z0-9]+)?$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct UserId(::std::string::String);
    impl ::std::ops::Deref for UserId {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<UserId> for ::std::string::String {
        fn from(value: UserId) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&UserId> for UserId {
        fn from(value: &UserId) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for UserId {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if value.chars().count() > 63usize {
                return Err("longer than 63 characters".into());
            }
            if value.chars().count() < 1usize {
                return Err("shorter than 1 characters".into());
            }
            if regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z]([a-zA-Z0-9-]*[a-zA-Z0-9]+)?$\"" . into ()) ; }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for UserId {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for UserId {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// Parameters for setting a user's password
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters for setting a user's password",
    ///  "oneOf": [
    ///    {
    ///      "description": "Sets the user's password to the provided value",
    ///      "type": "object",
    ///      "required": [
    ///        "mode",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "mode": {
    ///          "type": "string",
    ///          "enum": [
    ///            "password"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Password"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "Invalidates any current password (disabling
    /// password authentication)",
    ///      "type": "object",
    ///      "required": [
    ///        "mode"
    ///      ],
    ///      "properties": {
    ///        "mode": {
    ///          "type": "string",
    ///          "enum": [
    ///            "login_disallowed"
    ///          ]
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "mode", content = "value")]
    pub enum UserPassword {
        /// Sets the user's password to the provided value
        #[serde(rename = "password")]
        Password(Password),
        #[serde(rename = "login_disallowed")]
        LoginDisallowed,
    }

    impl ::std::convert::From<&Self> for UserPassword {
        fn from(value: &UserPassword) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<Password> for UserPassword {
        fn from(value: Password) -> Self {
            Self::Password(value)
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/User"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UserResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<User>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&UserResultsPage> for UserResultsPage {
        fn from(value: &UserResultsPage) -> Self {
            value.clone()
        }
    }

    impl UserResultsPage {
        pub fn builder() -> builder::UserResultsPage {
            Default::default()
        }
    }

    /// Credentials for local user login
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Credentials for local user login",
    ///  "type": "object",
    ///  "required": [
    ///    "password",
    ///    "username"
    ///  ],
    ///  "properties": {
    ///    "password": {
    ///      "$ref": "#/components/schemas/Password"
    ///    },
    ///    "username": {
    ///      "$ref": "#/components/schemas/UserId"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct UsernamePasswordCredentials {
        pub password: Password,
        pub username: UserId,
    }

    impl ::std::convert::From<&UsernamePasswordCredentials> for UsernamePasswordCredentials {
        fn from(value: &UsernamePasswordCredentials) -> Self {
            value.clone()
        }
    }

    impl UsernamePasswordCredentials {
        pub fn builder() -> builder::UsernamePasswordCredentials {
            Default::default()
        }
    }

    /// View of the current silo's resource utilization and capacity
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of the current silo's resource utilization and
    /// capacity",
    ///  "type": "object",
    ///  "required": [
    ///    "capacity",
    ///    "provisioned"
    ///  ],
    ///  "properties": {
    ///    "capacity": {
    ///      "description": "The total amount of resources that can be
    /// provisioned in this silo Actions that would exceed this limit will
    /// fail",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VirtualResourceCounts"
    ///        }
    ///      ]
    ///    },
    ///    "provisioned": {
    ///      "description": "Accounts for resources allocated to running
    /// instances or storage allocated via disks or snapshots Note that CPU and
    /// memory resources associated with a stopped instances are not counted
    /// here whereas associated disks will still be counted",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VirtualResourceCounts"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Utilization {
        /// The total amount of resources that can be provisioned in this silo
        /// Actions that would exceed this limit will fail
        pub capacity: VirtualResourceCounts,
        /// Accounts for resources allocated to running instances or storage
        /// allocated via disks or snapshots Note that CPU and memory resources
        /// associated with a stopped instances are not counted here whereas
        /// associated disks will still be counted
        pub provisioned: VirtualResourceCounts,
    }

    impl ::std::convert::From<&Utilization> for Utilization {
        fn from(value: &Utilization) -> Self {
            value.clone()
        }
    }

    impl Utilization {
        pub fn builder() -> builder::Utilization {
            Default::default()
        }
    }

    /// List of data values for one timeseries.
    ///
    /// Each element is an option, where `None` represents a missing sample.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "List of data values for one timeseries.\n\nEach element
    /// is an option, where `None` represents a missing sample.",
    ///  "oneOf": [
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "integer"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": [
    ///              "integer",
    ///              "null"
    ///            ],
    ///            "format": "int64"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "double"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": [
    ///              "number",
    ///              "null"
    ///            ],
    ///            "format": "double"
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "boolean"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": [
    ///              "boolean",
    ///              "null"
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "string"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "type": [
    ///              "string",
    ///              "null"
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "integer_distribution"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "oneOf": [
    ///              {
    ///                "type": "null"
    ///              },
    ///              {
    ///                "allOf": [
    ///                  {
    ///                    "$ref": "#/components/schemas/Distributionint64"
    ///                  }
    ///                ]
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "values"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "double_distribution"
    ///          ]
    ///        },
    ///        "values": {
    ///          "type": "array",
    ///          "items": {
    ///            "oneOf": [
    ///              {
    ///                "type": "null"
    ///              },
    ///              {
    ///                "allOf": [
    ///                  {
    ///                    "$ref": "#/components/schemas/Distributiondouble"
    ///                  }
    ///                ]
    ///              }
    ///            ]
    ///          }
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "values")]
    pub enum ValueArray {
        #[serde(rename = "integer")]
        Integer(::std::vec::Vec<::std::option::Option<i64>>),
        #[serde(rename = "double")]
        Double(::std::vec::Vec<::std::option::Option<f64>>),
        #[serde(rename = "boolean")]
        Boolean(::std::vec::Vec<::std::option::Option<bool>>),
        #[serde(rename = "string")]
        String(::std::vec::Vec<::std::option::Option<::std::string::String>>),
        #[serde(rename = "integer_distribution")]
        IntegerDistribution(::std::vec::Vec<::std::option::Option<Distributionint64>>),
        #[serde(rename = "double_distribution")]
        DoubleDistribution(::std::vec::Vec<::std::option::Option<Distributiondouble>>),
    }

    impl ::std::convert::From<&Self> for ValueArray {
        fn from(value: &ValueArray) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<i64>>> for ValueArray {
        fn from(value: ::std::vec::Vec<::std::option::Option<i64>>) -> Self {
            Self::Integer(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<f64>>> for ValueArray {
        fn from(value: ::std::vec::Vec<::std::option::Option<f64>>) -> Self {
            Self::Double(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<bool>>> for ValueArray {
        fn from(value: ::std::vec::Vec<::std::option::Option<bool>>) -> Self {
            Self::Boolean(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<::std::string::String>>>
        for ValueArray
    {
        fn from(value: ::std::vec::Vec<::std::option::Option<::std::string::String>>) -> Self {
            Self::String(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<Distributionint64>>>
        for ValueArray
    {
        fn from(value: ::std::vec::Vec<::std::option::Option<Distributionint64>>) -> Self {
            Self::IntegerDistribution(value)
        }
    }

    impl ::std::convert::From<::std::vec::Vec<::std::option::Option<Distributiondouble>>>
        for ValueArray
    {
        fn from(value: ::std::vec::Vec<::std::option::Option<Distributiondouble>>) -> Self {
            Self::DoubleDistribution(value)
        }
    }

    /// A single list of values, for one dimension of a timeseries.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single list of values, for one dimension of a
    /// timeseries.",
    ///  "type": "object",
    ///  "required": [
    ///    "metric_type",
    ///    "values"
    ///  ],
    ///  "properties": {
    ///    "metric_type": {
    ///      "description": "The type of this metric.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/MetricType"
    ///        }
    ///      ]
    ///    },
    ///    "values": {
    ///      "description": "The data values.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ValueArray"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Values {
        /// The type of this metric.
        pub metric_type: MetricType,
        /// The data values.
        pub values: ValueArray,
    }

    impl ::std::convert::From<&Values> for Values {
        fn from(value: &Values) -> Self {
            value.clone()
        }
    }

    impl Values {
        pub fn builder() -> builder::Values {
            Default::default()
        }
    }

    /// A collection of resource counts used to describe capacity and
    /// utilization
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A collection of resource counts used to describe
    /// capacity and utilization",
    ///  "type": "object",
    ///  "required": [
    ///    "cpus",
    ///    "memory",
    ///    "storage"
    ///  ],
    ///  "properties": {
    ///    "cpus": {
    ///      "description": "Number of virtual CPUs",
    ///      "type": "integer",
    ///      "format": "int64"
    ///    },
    ///    "memory": {
    ///      "description": "Amount of memory in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    },
    ///    "storage": {
    ///      "description": "Amount of disk storage in bytes",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/ByteCount"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VirtualResourceCounts {
        /// Number of virtual CPUs
        pub cpus: i64,
        /// Amount of memory in bytes
        pub memory: ByteCount,
        /// Amount of disk storage in bytes
        pub storage: ByteCount,
    }

    impl ::std::convert::From<&VirtualResourceCounts> for VirtualResourceCounts {
        fn from(value: &VirtualResourceCounts) -> Self {
            value.clone()
        }
    }

    impl VirtualResourceCounts {
        pub fn builder() -> builder::VirtualResourceCounts {
            Default::default()
        }
    }

    /// A Geneve Virtual Network Identifier
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A Geneve Virtual Network Identifier",
    ///  "type": "integer",
    ///  "format": "uint32",
    ///  "minimum": 0.0
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct Vni(pub u32);
    impl ::std::ops::Deref for Vni {
        type Target = u32;
        fn deref(&self) -> &u32 {
            &self.0
        }
    }

    impl ::std::convert::From<Vni> for u32 {
        fn from(value: Vni) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&Vni> for Vni {
        fn from(value: &Vni) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<u32> for Vni {
        fn from(value: u32) -> Self {
            Self(value)
        }
    }

    impl ::std::str::FromStr for Vni {
        type Err = <u32 as ::std::str::FromStr>::Err;
        fn from_str(value: &str) -> ::std::result::Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl ::std::convert::TryFrom<&str> for Vni {
        type Error = <u32 as ::std::str::FromStr>::Err;
        fn try_from(value: &str) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&String> for Vni {
        type Error = <u32 as ::std::str::FromStr>::Err;
        fn try_from(value: &String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<String> for Vni {
        type Error = <u32 as ::std::str::FromStr>::Err;
        fn try_from(value: String) -> ::std::result::Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ::std::fmt::Display for Vni {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            self.0.fmt(f)
        }
    }

    /// View of a VPC
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "View of a VPC",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "dns_name",
    ///    "id",
    ///    "ipv6_prefix",
    ///    "name",
    ///    "project_id",
    ///    "system_router_id",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "dns_name": {
    ///      "description": "The name used for the VPC in DNS.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ipv6_prefix": {
    ///      "description": "The unique local IPv6 address range for subnets in
    /// this VPC",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "project_id": {
    ///      "description": "id for the project containing this VPC",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "system_router_id": {
    ///      "description": "id for the system router where subnet default
    /// routes are registered",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct Vpc {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// The name used for the VPC in DNS.
        pub dns_name: Name,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The unique local IPv6 address range for subnets in this VPC
        pub ipv6_prefix: Ipv6Net,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// id for the project containing this VPC
        pub project_id: ::uuid::Uuid,
        /// id for the system router where subnet default routes are registered
        pub system_router_id: ::uuid::Uuid,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&Vpc> for Vpc {
        fn from(value: &Vpc) -> Self {
            value.clone()
        }
    }

    impl Vpc {
        pub fn builder() -> builder::Vpc {
            Default::default()
        }
    }

    /// Create-time parameters for a `Vpc`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `Vpc`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "dns_name",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "dns_name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "ipv6_prefix": {
    ///      "description": "The IPv6 prefix for this VPC\n\nAll IPv6 subnets
    /// created from this VPC must be taken from this range, which should be a
    /// Unique Local Address in the range `fd00::/48`. The default VPC Subnet
    /// will have the first `/64` range from this prefix.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Ipv6Net"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcCreate {
        pub description: ::std::string::String,
        pub dns_name: Name,
        /// The IPv6 prefix for this VPC
        ///
        /// All IPv6 subnets created from this VPC must be taken from this
        /// range, which should be a Unique Local Address in the range
        /// `fd00::/48`. The default VPC Subnet will have the first `/64` range
        /// from this prefix.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ipv6_prefix: ::std::option::Option<Ipv6Net>,
        pub name: Name,
    }

    impl ::std::convert::From<&VpcCreate> for VpcCreate {
        fn from(value: &VpcCreate) -> Self {
            value.clone()
        }
    }

    impl VpcCreate {
        pub fn builder() -> builder::VpcCreate {
            Default::default()
        }
    }

    /// A single rule in a VPC firewall
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single rule in a VPC firewall",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "description",
    ///    "direction",
    ///    "filters",
    ///    "id",
    ///    "name",
    ///    "priority",
    ///    "status",
    ///    "targets",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether traffic matching the rule should be allowed
    /// or dropped",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleAction"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "description": "Whether this rule is for incoming or outgoing
    /// traffic",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleDirection"
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "description": "Reductions on the scope of the rule",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleFilter"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "priority": {
    ///      "description": "The relative priority of this rule",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "Whether this rule is in effect",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleStatus"
    ///        }
    ///      ]
    ///    },
    ///    "targets": {
    ///      "description": "Determine the set of instances that the rule
    /// applies to",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleTarget"
    ///      }
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which this rule belongs",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcFirewallRule {
        /// Whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// Whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        /// Reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// The relative priority of this rule
        pub priority: u16,
        /// Whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        /// Determine the set of instances that the rule applies to
        pub targets: ::std::vec::Vec<VpcFirewallRuleTarget>,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The VPC to which this rule belongs
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&VpcFirewallRule> for VpcFirewallRule {
        fn from(value: &VpcFirewallRule) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRule {
        pub fn builder() -> builder::VpcFirewallRule {
            Default::default()
        }
    }

    /// `VpcFirewallRuleAction`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "allow",
    ///    "deny"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleAction {
        fn from(value: &VpcFirewallRuleAction) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleAction {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Allow => write!(f, "allow"),
                Self::Deny => write!(f, "deny"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleAction {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "allow" => Ok(Self::Allow),
                "deny" => Ok(Self::Deny),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleAction {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `VpcFirewallRuleDirection`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "inbound",
    ///    "outbound"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleDirection {
        fn from(value: &VpcFirewallRuleDirection) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleDirection {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Inbound => write!(f, "inbound"),
                Self::Outbound => write!(f, "outbound"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleDirection {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "inbound" => Ok(Self::Inbound),
                "outbound" => Ok(Self::Outbound),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleDirection {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Filters reduce the scope of a firewall rule. Without filters, the rule
    /// applies to all packets to the targets (or from the targets, if it's an
    /// outbound rule). With multiple filters, the rule applies only to packets
    /// matching ALL filters. The maximum number of each type of filter is 256.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Filters reduce the scope of a firewall rule. Without
    /// filters, the rule applies to all packets to the targets (or from the
    /// targets, if it's an outbound rule). With multiple filters, the rule
    /// applies only to packets matching ALL filters. The maximum number of each
    /// type of filter is 256.",
    ///  "type": "object",
    ///  "properties": {
    ///    "hosts": {
    ///      "description": "If present, host filters match the \"other end\" of
    /// traffic from the targets perspective: for an inbound rule, they match
    /// the source of traffic. For an outbound rule, they match the
    /// destination.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleHostFilter"
    ///      },
    ///      "maxItems": 256
    ///    },
    ///    "ports": {
    ///      "description": "If present, the destination ports or port ranges
    /// this rule applies to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/L4PortRange"
    ///      },
    ///      "maxItems": 256
    ///    },
    ///    "protocols": {
    ///      "description": "If present, the networking protocols this rule
    /// applies to.",
    ///      "type": [
    ///        "array",
    ///        "null"
    ///      ],
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleProtocol"
    ///      },
    ///      "maxItems": 256
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcFirewallRuleFilter {
        /// If present, host filters match the "other end" of traffic from the
        /// targets perspective: for an inbound rule, they match the source of
        /// traffic. For an outbound rule, they match the destination.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub hosts: ::std::option::Option<::std::vec::Vec<VpcFirewallRuleHostFilter>>,
        /// If present, the destination ports or port ranges this rule applies
        /// to.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ports: ::std::option::Option<::std::vec::Vec<L4PortRange>>,
        /// If present, the networking protocols this rule applies to.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub protocols: ::std::option::Option<::std::vec::Vec<VpcFirewallRuleProtocol>>,
    }

    impl ::std::convert::From<&VpcFirewallRuleFilter> for VpcFirewallRuleFilter {
        fn from(value: &VpcFirewallRuleFilter) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcFirewallRuleFilter {
        fn default() -> Self {
            Self {
                hosts: Default::default(),
                ports: Default::default(),
                protocols: Default::default(),
            }
        }
    }

    impl VpcFirewallRuleFilter {
        pub fn builder() -> builder::VpcFirewallRuleFilter {
            Default::default()
        }
    }

    /// The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis
    /// of its source or destination host.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The `VpcFirewallRuleHostFilter` is used to filter
    /// traffic on the basis of its source or destination host.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The rule applies to traffic from/to all instances
    /// in the VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to all instances
    /// in the VPC Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to this specific
    /// instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to a specific IP
    /// address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to traffic from/to a specific IP
    /// subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        /// The rule applies to traffic from/to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        /// The rule applies to traffic from/to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        /// The rule applies to traffic from/to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        /// The rule applies to traffic from/to a specific IP address
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        /// The rule applies to traffic from/to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleHostFilter {
        fn from(value: &VpcFirewallRuleHostFilter) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for VpcFirewallRuleHostFilter {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl ::std::convert::From<IpNet> for VpcFirewallRuleHostFilter {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    /// The protocols that may be specified in a firewall rule's filter
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The protocols that may be specified in a firewall
    /// rule's filter",
    ///  "type": "string",
    ///  "enum": [
    ///    "TCP",
    ///    "UDP",
    ///    "ICMP"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleProtocol {
        fn from(value: &VpcFirewallRuleProtocol) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleProtocol {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Tcp => write!(f, "TCP"),
                Self::Udp => write!(f, "UDP"),
                Self::Icmp => write!(f, "ICMP"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleProtocol {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "TCP" => Ok(Self::Tcp),
                "UDP" => Ok(Self::Udp),
                "ICMP" => Ok(Self::Icmp),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleProtocol {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `VpcFirewallRuleStatus`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "disabled",
    ///    "enabled"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleStatus {
        fn from(value: &VpcFirewallRuleStatus) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcFirewallRuleStatus {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Disabled => write!(f, "disabled"),
                Self::Enabled => write!(f, "enabled"),
            }
        }
    }

    impl ::std::str::FromStr for VpcFirewallRuleStatus {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "disabled" => Ok(Self::Disabled),
                "enabled" => Ok(Self::Enabled),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcFirewallRuleStatus {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A `VpcFirewallRuleTarget` is used to specify the set of instances to
    /// which a firewall rule applies. You can target instances directly by
    /// name, or specify a VPC, VPC subnet, IP, or IP subnet, which will apply
    /// the rule to traffic going to all matching instances. Targets are
    /// additive: the rule applies to instances matching ANY target.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A `VpcFirewallRuleTarget` is used to specify the set of
    /// instances to which a firewall rule applies. You can target instances
    /// directly by name, or specify a VPC, VPC subnet, IP, or IP subnet, which
    /// will apply the rule to traffic going to all matching instances. Targets
    /// are additive: the rule applies to instances matching ANY target.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The rule applies to all instances in the VPC",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "vpc"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to all instances in the VPC
    /// Subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "subnet"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to this specific instance",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "instance"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to a specific IP address",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip"
    ///          ]
    ///        },
    ///        "value": {
    ///          "type": "string",
    ///          "format": "ip"
    ///        }
    ///      }
    ///    },
    ///    {
    ///      "description": "The rule applies to a specific IP subnet",
    ///      "type": "object",
    ///      "required": [
    ///        "type",
    ///        "value"
    ///      ],
    ///      "properties": {
    ///        "type": {
    ///          "type": "string",
    ///          "enum": [
    ///            "ip_net"
    ///          ]
    ///        },
    ///        "value": {
    ///          "$ref": "#/components/schemas/IpNet"
    ///        }
    ///      }
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        /// The rule applies to all instances in the VPC
        #[serde(rename = "vpc")]
        Vpc(Name),
        /// The rule applies to all instances in the VPC Subnet
        #[serde(rename = "subnet")]
        Subnet(Name),
        /// The rule applies to this specific instance
        #[serde(rename = "instance")]
        Instance(Name),
        /// The rule applies to a specific IP address
        #[serde(rename = "ip")]
        Ip(::std::net::IpAddr),
        /// The rule applies to a specific IP subnet
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl ::std::convert::From<&Self> for VpcFirewallRuleTarget {
        fn from(value: &VpcFirewallRuleTarget) -> Self {
            value.clone()
        }
    }

    impl ::std::convert::From<::std::net::IpAddr> for VpcFirewallRuleTarget {
        fn from(value: ::std::net::IpAddr) -> Self {
            Self::Ip(value)
        }
    }

    impl ::std::convert::From<IpNet> for VpcFirewallRuleTarget {
        fn from(value: IpNet) -> Self {
            Self::IpNet(value)
        }
    }

    /// A single rule in a VPC firewall
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single rule in a VPC firewall",
    ///  "type": "object",
    ///  "required": [
    ///    "action",
    ///    "description",
    ///    "direction",
    ///    "filters",
    ///    "name",
    ///    "priority",
    ///    "status",
    ///    "targets"
    ///  ],
    ///  "properties": {
    ///    "action": {
    ///      "description": "Whether traffic matching the rule should be allowed
    /// or dropped",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleAction"
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "description": "Human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "direction": {
    ///      "description": "Whether this rule is for incoming or outgoing
    /// traffic",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleDirection"
    ///        }
    ///      ]
    ///    },
    ///    "filters": {
    ///      "description": "Reductions on the scope of the rule",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleFilter"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "Name of the rule, unique to this VPC",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "priority": {
    ///      "description": "The relative priority of this rule",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "Whether this rule is in effect",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/VpcFirewallRuleStatus"
    ///        }
    ///      ]
    ///    },
    ///    "targets": {
    ///      "description": "Determine the set of instances that the rule
    /// applies to",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleTarget"
    ///      },
    ///      "maxItems": 256
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcFirewallRuleUpdate {
        /// Whether traffic matching the rule should be allowed or dropped
        pub action: VpcFirewallRuleAction,
        /// Human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// Whether this rule is for incoming or outgoing traffic
        pub direction: VpcFirewallRuleDirection,
        /// Reductions on the scope of the rule
        pub filters: VpcFirewallRuleFilter,
        /// Name of the rule, unique to this VPC
        pub name: Name,
        /// The relative priority of this rule
        pub priority: u16,
        /// Whether this rule is in effect
        pub status: VpcFirewallRuleStatus,
        /// Determine the set of instances that the rule applies to
        pub targets: ::std::vec::Vec<VpcFirewallRuleTarget>,
    }

    impl ::std::convert::From<&VpcFirewallRuleUpdate> for VpcFirewallRuleUpdate {
        fn from(value: &VpcFirewallRuleUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleUpdate {
        pub fn builder() -> builder::VpcFirewallRuleUpdate {
            Default::default()
        }
    }

    /// Updated list of firewall rules. Will replace all existing rules.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updated list of firewall rules. Will replace all
    /// existing rules.",
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRuleUpdate"
    ///      },
    ///      "maxItems": 1024
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcFirewallRuleUpdateParams {
        pub rules: ::std::vec::Vec<VpcFirewallRuleUpdate>,
    }

    impl ::std::convert::From<&VpcFirewallRuleUpdateParams> for VpcFirewallRuleUpdateParams {
        fn from(value: &VpcFirewallRuleUpdateParams) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleUpdateParams {
        pub fn builder() -> builder::VpcFirewallRuleUpdateParams {
            Default::default()
        }
    }

    /// Collection of a Vpc's firewall rules
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Collection of a Vpc's firewall rules",
    ///  "type": "object",
    ///  "required": [
    ///    "rules"
    ///  ],
    ///  "properties": {
    ///    "rules": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcFirewallRule"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcFirewallRules {
        pub rules: ::std::vec::Vec<VpcFirewallRule>,
    }

    impl ::std::convert::From<&VpcFirewallRules> for VpcFirewallRules {
        fn from(value: &VpcFirewallRules) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRules {
        pub fn builder() -> builder::VpcFirewallRules {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/Vpc"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<Vpc>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VpcResultsPage> for VpcResultsPage {
        fn from(value: &VpcResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcResultsPage {
        pub fn builder() -> builder::VpcResultsPage {
            Default::default()
        }
    }

    /// A VPC router defines a series of rules that indicate where traffic
    /// should be sent depending on its destination.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A VPC router defines a series of rules that indicate
    /// where traffic should be sent depending on its destination.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "kind",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "kind": {
    ///      "$ref": "#/components/schemas/VpcRouterKind"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the router belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcRouter {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        pub kind: VpcRouterKind,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The VPC to which the router belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&VpcRouter> for VpcRouter {
        fn from(value: &VpcRouter) -> Self {
            value.clone()
        }
    }

    impl VpcRouter {
        pub fn builder() -> builder::VpcRouter {
            Default::default()
        }
    }

    /// Create-time parameters for a `VpcRouter`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `VpcRouter`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcRouterCreate {
        pub description: ::std::string::String,
        pub name: Name,
    }

    impl ::std::convert::From<&VpcRouterCreate> for VpcRouterCreate {
        fn from(value: &VpcRouterCreate) -> Self {
            value.clone()
        }
    }

    impl VpcRouterCreate {
        pub fn builder() -> builder::VpcRouterCreate {
            Default::default()
        }
    }

    /// `VpcRouterKind`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "string",
    ///  "enum": [
    ///    "system",
    ///    "custom"
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl ::std::convert::From<&Self> for VpcRouterKind {
        fn from(value: &VpcRouterKind) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for VpcRouterKind {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::System => write!(f, "system"),
                Self::Custom => write!(f, "custom"),
            }
        }
    }

    impl ::std::str::FromStr for VpcRouterKind {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "system" => Ok(Self::System),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for VpcRouterKind {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcRouter"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcRouterResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<VpcRouter>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VpcRouterResultsPage> for VpcRouterResultsPage {
        fn from(value: &VpcRouterResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcRouterResultsPage {
        pub fn builder() -> builder::VpcRouterResultsPage {
            Default::default()
        }
    }

    /// Updateable properties of a `VpcRouter`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of a `VpcRouter`",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&VpcRouterUpdate> for VpcRouterUpdate {
        fn from(value: &VpcRouterUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcRouterUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl VpcRouterUpdate {
        pub fn builder() -> builder::VpcRouterUpdate {
            Default::default()
        }
    }

    /// A VPC subnet represents a logical grouping for instances that allows
    /// network traffic between them, within a IPv4 subnetwork or optionally an
    /// IPv6 subnetwork.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A VPC subnet represents a logical grouping for
    /// instances that allows network traffic between them, within a IPv4
    /// subnetwork or optionally an IPv6 subnetwork.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "id",
    ///    "ipv4_block",
    ///    "ipv6_block",
    ///    "name",
    ///    "time_created",
    ///    "time_modified",
    ///    "vpc_id"
    ///  ],
    ///  "properties": {
    ///    "custom_router_id": {
    ///      "description": "ID for an attached custom router.",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uuid"
    ///    },
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "ipv4_block": {
    ///      "description": "The IPv4 subnet CIDR block.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6_block": {
    ///      "description": "The IPv6 subnet CIDR block.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv6Net"
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "vpc_id": {
    ///      "description": "The VPC to which the subnet belongs.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcSubnet {
        /// ID for an attached custom router.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_router_id: ::std::option::Option<::uuid::Uuid>,
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// The IPv4 subnet CIDR block.
        pub ipv4_block: Ipv4Net,
        /// The IPv6 subnet CIDR block.
        pub ipv6_block: Ipv6Net,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
        /// The VPC to which the subnet belongs.
        pub vpc_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&VpcSubnet> for VpcSubnet {
        fn from(value: &VpcSubnet) -> Self {
            value.clone()
        }
    }

    impl VpcSubnet {
        pub fn builder() -> builder::VpcSubnet {
            Default::default()
        }
    }

    /// Create-time parameters for a `VpcSubnet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time parameters for a `VpcSubnet`",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "ipv4_block",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "custom_router": {
    ///      "description": "An optional router, used to direct packets sent
    /// from hosts in this subnet to any destination address.\n\nCustom routers
    /// apply in addition to the VPC-wide *system* router, and have higher
    /// priority than the system router for an otherwise equal-prefix-length
    /// match.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/NameOrId"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "ipv4_block": {
    ///      "description": "The IPv4 address range for this subnet.\n\nIt must
    /// be allocated from an RFC 1918 private address range, and must not
    /// overlap with any other existing subnet in the VPC.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Ipv4Net"
    ///        }
    ///      ]
    ///    },
    ///    "ipv6_block": {
    ///      "description": "The IPv6 address range for this subnet.\n\nIt must
    /// be allocated from the RFC 4193 Unique Local Address range, with the
    /// prefix equal to the parent VPC's prefix. A random `/64` block will be
    /// assigned if one is not provided. It must not overlap with any existing
    /// subnet in the VPC.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Ipv6Net"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcSubnetCreate {
        /// An optional router, used to direct packets sent from hosts in this
        /// subnet to any destination address.
        ///
        /// Custom routers apply in addition to the VPC-wide *system* router,
        /// and have higher priority than the system router for an otherwise
        /// equal-prefix-length match.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_router: ::std::option::Option<NameOrId>,
        pub description: ::std::string::String,
        /// The IPv4 address range for this subnet.
        ///
        /// It must be allocated from an RFC 1918 private address range, and
        /// must not overlap with any other existing subnet in the VPC.
        pub ipv4_block: Ipv4Net,
        /// The IPv6 address range for this subnet.
        ///
        /// It must be allocated from the RFC 4193 Unique Local Address range,
        /// with the prefix equal to the parent VPC's prefix. A random `/64`
        /// block will be assigned if one is not provided. It must not overlap
        /// with any existing subnet in the VPC.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub ipv6_block: ::std::option::Option<Ipv6Net>,
        pub name: Name,
    }

    impl ::std::convert::From<&VpcSubnetCreate> for VpcSubnetCreate {
        fn from(value: &VpcSubnetCreate) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetCreate {
        pub fn builder() -> builder::VpcSubnetCreate {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/VpcSubnet"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcSubnetResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<VpcSubnet>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&VpcSubnetResultsPage> for VpcSubnetResultsPage {
        fn from(value: &VpcSubnetResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetResultsPage {
        pub fn builder() -> builder::VpcSubnetResultsPage {
            Default::default()
        }
    }

    /// Updateable properties of a `VpcSubnet`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of a `VpcSubnet`",
    ///  "type": "object",
    ///  "properties": {
    ///    "custom_router": {
    ///      "description": "An optional router, used to direct packets sent
    /// from hosts in this subnet to any destination address.",
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/NameOrId"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcSubnetUpdate {
        /// An optional router, used to direct packets sent from hosts in this
        /// subnet to any destination address.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub custom_router: ::std::option::Option<NameOrId>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&VpcSubnetUpdate> for VpcSubnetUpdate {
        fn from(value: &VpcSubnetUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcSubnetUpdate {
        fn default() -> Self {
            Self {
                custom_router: Default::default(),
                description: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl VpcSubnetUpdate {
        pub fn builder() -> builder::VpcSubnetUpdate {
            Default::default()
        }
    }

    /// Updateable properties of a `Vpc`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Updateable properties of a `Vpc`",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "dns_name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub dns_name: ::std::option::Option<Name>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&VpcUpdate> for VpcUpdate {
        fn from(value: &VpcUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for VpcUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                dns_name: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl VpcUpdate {
        pub fn builder() -> builder::VpcUpdate {
            Default::default()
        }
    }

    /// Create-time identity-related parameters
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Create-time identity-related parameters",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "endpoint",
    ///    "name",
    ///    "secrets"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "type": "string"
    ///    },
    ///    "endpoint": {
    ///      "description": "The URL that webhook notification requests should
    /// be sent to",
    ///      "type": "string",
    ///      "format": "uri"
    ///    },
    ///    "name": {
    ///      "$ref": "#/components/schemas/Name"
    ///    },
    ///    "secrets": {
    ///      "description": "A non-empty list of secret keys used to sign
    /// webhook payloads.",
    ///      "type": "array",
    ///      "items": {
    ///        "type": "string"
    ///      }
    ///    },
    ///    "subscriptions": {
    ///      "description": "A list of webhook event class subscriptions.\n\nIf
    /// this list is empty or is not included in the request body, the webhook
    /// will not be subscribed to any events.",
    ///      "default": [],
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookSubscription"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookCreate {
        pub description: ::std::string::String,
        /// The URL that webhook notification requests should be sent to
        pub endpoint: ::std::string::String,
        pub name: Name,
        /// A non-empty list of secret keys used to sign webhook payloads.
        pub secrets: ::std::vec::Vec<::std::string::String>,
        /// A list of webhook event class subscriptions.
        ///
        /// If this list is empty or is not included in the request body, the
        /// webhook will not be subscribed to any events.
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        pub subscriptions: ::std::vec::Vec<WebhookSubscription>,
    }

    impl ::std::convert::From<&WebhookCreate> for WebhookCreate {
        fn from(value: &WebhookCreate) -> Self {
            value.clone()
        }
    }

    impl WebhookCreate {
        pub fn builder() -> builder::WebhookCreate {
            Default::default()
        }
    }

    /// A delivery of a webhook event.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A delivery of a webhook event.",
    ///  "type": "object",
    ///  "required": [
    ///    "attempts",
    ///    "event_class",
    ///    "event_id",
    ///    "id",
    ///    "state",
    ///    "time_started",
    ///    "trigger",
    ///    "webhook_id"
    ///  ],
    ///  "properties": {
    ///    "attempts": {
    ///      "description": "Individual attempts to deliver this webhook event,
    /// and their outcomes.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookDeliveryAttempt"
    ///      }
    ///    },
    ///    "event_class": {
    ///      "description": "The event class.",
    ///      "type": "string"
    ///    },
    ///    "event_id": {
    ///      "description": "The UUID of the event.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TypedUuidForWebhookEventKind"
    ///        }
    ///      ]
    ///    },
    ///    "id": {
    ///      "description": "The UUID of this delivery attempt.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "state": {
    ///      "description": "The state of this delivery.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/WebhookDeliveryState"
    ///        }
    ///      ]
    ///    },
    ///    "time_started": {
    ///      "description": "The time at which this delivery began (i.e. the
    /// event was dispatched to the receiver).",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "trigger": {
    ///      "description": "Why this delivery was performed.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/WebhookDeliveryTrigger"
    ///        }
    ///      ]
    ///    },
    ///    "webhook_id": {
    ///      "description": "The UUID of the webhook receiver that this event
    /// was delivered to.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/TypedUuidForWebhookReceiverKind"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookDelivery {
        /// Individual attempts to deliver this webhook event, and their
        /// outcomes.
        pub attempts: ::std::vec::Vec<WebhookDeliveryAttempt>,
        /// The event class.
        pub event_class: ::std::string::String,
        /// The UUID of the event.
        pub event_id: TypedUuidForWebhookEventKind,
        /// The UUID of this delivery attempt.
        pub id: ::uuid::Uuid,
        /// The state of this delivery.
        pub state: WebhookDeliveryState,
        /// The time at which this delivery began (i.e. the event was dispatched
        /// to the receiver).
        pub time_started: ::chrono::DateTime<::chrono::offset::Utc>,
        /// Why this delivery was performed.
        pub trigger: WebhookDeliveryTrigger,
        /// The UUID of the webhook receiver that this event was delivered to.
        pub webhook_id: TypedUuidForWebhookReceiverKind,
    }

    impl ::std::convert::From<&WebhookDelivery> for WebhookDelivery {
        fn from(value: &WebhookDelivery) -> Self {
            value.clone()
        }
    }

    impl WebhookDelivery {
        pub fn builder() -> builder::WebhookDelivery {
            Default::default()
        }
    }

    /// An individual delivery attempt for a webhook event.
    ///
    /// This represents a single HTTP request that was sent to the receiver, and
    /// its outcome.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "An individual delivery attempt for a webhook
    /// event.\n\nThis represents a single HTTP request that was sent to the
    /// receiver, and its outcome.",
    ///  "type": "object",
    ///  "required": [
    ///    "attempt",
    ///    "result",
    ///    "time_sent"
    ///  ],
    ///  "properties": {
    ///    "attempt": {
    ///      "description": "The attempt number.",
    ///      "type": "integer",
    ///      "format": "uint",
    ///      "minimum": 0.0
    ///    },
    ///    "response": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/WebhookDeliveryResponse"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    },
    ///    "result": {
    ///      "description": "The outcome of this delivery attempt: either the
    /// event was delivered successfully, or the request failed for one of
    /// several reasons.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/WebhookDeliveryAttemptResult"
    ///        }
    ///      ]
    ///    },
    ///    "time_sent": {
    ///      "description": "The time at which the webhook delivery was
    /// attempted.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookDeliveryAttempt {
        /// The attempt number.
        pub attempt: u32,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub response: ::std::option::Option<WebhookDeliveryResponse>,
        /// The outcome of this delivery attempt: either the event was delivered
        /// successfully, or the request failed for one of several reasons.
        pub result: WebhookDeliveryAttemptResult,
        /// The time at which the webhook delivery was attempted.
        pub time_sent: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&WebhookDeliveryAttempt> for WebhookDeliveryAttempt {
        fn from(value: &WebhookDeliveryAttempt) -> Self {
            value.clone()
        }
    }

    impl WebhookDeliveryAttempt {
        pub fn builder() -> builder::WebhookDeliveryAttempt {
            Default::default()
        }
    }

    /// `WebhookDeliveryAttemptResult`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "oneOf": [
    ///    {
    ///      "description": "The webhook event has been delivered
    /// successfully.",
    ///      "type": "string",
    ///      "enum": [
    ///        "succeeded"
    ///      ]
    ///    },
    ///    {
    ///      "description": "A webhook request was sent to the endpoint, and it
    /// returned a HTTP error status code indicating an error.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed_http_error"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The webhook request could not be sent to the
    /// receiver endpoint.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed_unreachable"
    ///      ]
    ///    },
    ///    {
    ///      "description": "A connection to the receiver endpoint was
    /// successfully established, but no response was received within the
    /// delivery timeout.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed_timeout"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum WebhookDeliveryAttemptResult {
        /// The webhook event has been delivered successfully.
        #[serde(rename = "succeeded")]
        Succeeded,
        /// A webhook request was sent to the endpoint, and it returned a HTTP
        /// error status code indicating an error.
        #[serde(rename = "failed_http_error")]
        FailedHttpError,
        /// The webhook request could not be sent to the receiver endpoint.
        #[serde(rename = "failed_unreachable")]
        FailedUnreachable,
        /// A connection to the receiver endpoint was successfully established,
        /// but no response was received within the delivery timeout.
        #[serde(rename = "failed_timeout")]
        FailedTimeout,
    }

    impl ::std::convert::From<&Self> for WebhookDeliveryAttemptResult {
        fn from(value: &WebhookDeliveryAttemptResult) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WebhookDeliveryAttemptResult {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Succeeded => write!(f, "succeeded"),
                Self::FailedHttpError => write!(f, "failed_http_error"),
                Self::FailedUnreachable => write!(f, "failed_unreachable"),
                Self::FailedTimeout => write!(f, "failed_timeout"),
            }
        }
    }

    impl ::std::str::FromStr for WebhookDeliveryAttemptResult {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "succeeded" => Ok(Self::Succeeded),
                "failed_http_error" => Ok(Self::FailedHttpError),
                "failed_unreachable" => Ok(Self::FailedUnreachable),
                "failed_timeout" => Ok(Self::FailedTimeout),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookDeliveryAttemptResult {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookDeliveryAttemptResult {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookDeliveryAttemptResult {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// `WebhookDeliveryId`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "delivery_id"
    ///  ],
    ///  "properties": {
    ///    "delivery_id": {
    ///      "type": "string",
    ///      "format": "uuid"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookDeliveryId {
        pub delivery_id: ::uuid::Uuid,
    }

    impl ::std::convert::From<&WebhookDeliveryId> for WebhookDeliveryId {
        fn from(value: &WebhookDeliveryId) -> Self {
            value.clone()
        }
    }

    impl WebhookDeliveryId {
        pub fn builder() -> builder::WebhookDeliveryId {
            Default::default()
        }
    }

    /// The response received from a webhook receiver endpoint.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The response received from a webhook receiver
    /// endpoint.",
    ///  "type": "object",
    ///  "required": [
    ///    "duration_ms",
    ///    "status"
    ///  ],
    ///  "properties": {
    ///    "duration_ms": {
    ///      "description": "The response time of the webhook endpoint, in
    /// milliseconds.",
    ///      "type": "integer",
    ///      "format": "uint",
    ///      "minimum": 0.0
    ///    },
    ///    "status": {
    ///      "description": "The HTTP status code returned from the webhook
    /// endpoint.",
    ///      "type": "integer",
    ///      "format": "uint16",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookDeliveryResponse {
        /// The response time of the webhook endpoint, in milliseconds.
        pub duration_ms: u32,
        /// The HTTP status code returned from the webhook endpoint.
        pub status: u16,
    }

    impl ::std::convert::From<&WebhookDeliveryResponse> for WebhookDeliveryResponse {
        fn from(value: &WebhookDeliveryResponse) -> Self {
            value.clone()
        }
    }

    impl WebhookDeliveryResponse {
        pub fn builder() -> builder::WebhookDeliveryResponse {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookDelivery"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookDeliveryResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<WebhookDelivery>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&WebhookDeliveryResultsPage> for WebhookDeliveryResultsPage {
        fn from(value: &WebhookDeliveryResultsPage) -> Self {
            value.clone()
        }
    }

    impl WebhookDeliveryResultsPage {
        pub fn builder() -> builder::WebhookDeliveryResultsPage {
            Default::default()
        }
    }

    /// The state of a webhook delivery attempt.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The state of a webhook delivery attempt.",
    ///  "oneOf": [
    ///    {
    ///      "description": "The webhook event has not yet been delivered
    /// successfully.\n\nEither no delivery attempts have yet been performed, or
    /// the delivery has failed at least once but has retries remaining.",
    ///      "type": "string",
    ///      "enum": [
    ///        "pending"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The webhook event has been delivered
    /// successfully.",
    ///      "type": "string",
    ///      "enum": [
    ///        "delivered"
    ///      ]
    ///    },
    ///    {
    ///      "description": "The webhook delivery attempt has failed permanently
    /// and will not be retried again.",
    ///      "type": "string",
    ///      "enum": [
    ///        "failed"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum WebhookDeliveryState {
        /// The webhook event has not yet been delivered successfully.
        ///
        /// Either no delivery attempts have yet been performed, or the delivery
        /// has failed at least once but has retries remaining.
        #[serde(rename = "pending")]
        Pending,
        /// The webhook event has been delivered successfully.
        #[serde(rename = "delivered")]
        Delivered,
        /// The webhook delivery attempt has failed permanently and will not be
        /// retried again.
        #[serde(rename = "failed")]
        Failed,
    }

    impl ::std::convert::From<&Self> for WebhookDeliveryState {
        fn from(value: &WebhookDeliveryState) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WebhookDeliveryState {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Pending => write!(f, "pending"),
                Self::Delivered => write!(f, "delivered"),
                Self::Failed => write!(f, "failed"),
            }
        }
    }

    impl ::std::str::FromStr for WebhookDeliveryState {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "pending" => Ok(Self::Pending),
                "delivered" => Ok(Self::Delivered),
                "failed" => Ok(Self::Failed),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookDeliveryState {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookDeliveryState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookDeliveryState {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// The reason a webhook event was delivered
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The reason a webhook event was delivered",
    ///  "oneOf": [
    ///    {
    ///      "description": "Delivery was triggered by the event occurring for
    /// the first time.",
    ///      "type": "string",
    ///      "enum": [
    ///        "event"
    ///      ]
    ///    },
    ///    {
    ///      "description": "Delivery was triggered by a request to resend the
    /// event.",
    ///      "type": "string",
    ///      "enum": [
    ///        "resend"
    ///      ]
    ///    },
    ///    {
    ///      "description": "This delivery is a liveness probe.",
    ///      "type": "string",
    ///      "enum": [
    ///        "probe"
    ///      ]
    ///    }
    ///  ]
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize,
        :: serde :: Serialize,
        Clone,
        Copy,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    pub enum WebhookDeliveryTrigger {
        /// Delivery was triggered by the event occurring for the first time.
        #[serde(rename = "event")]
        Event,
        /// Delivery was triggered by a request to resend the event.
        #[serde(rename = "resend")]
        Resend,
        /// This delivery is a liveness probe.
        #[serde(rename = "probe")]
        Probe,
    }

    impl ::std::convert::From<&Self> for WebhookDeliveryTrigger {
        fn from(value: &WebhookDeliveryTrigger) -> Self {
            value.clone()
        }
    }

    impl ::std::fmt::Display for WebhookDeliveryTrigger {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            match *self {
                Self::Event => write!(f, "event"),
                Self::Resend => write!(f, "resend"),
                Self::Probe => write!(f, "probe"),
            }
        }
    }

    impl ::std::str::FromStr for WebhookDeliveryTrigger {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            match value {
                "event" => Ok(Self::Event),
                "resend" => Ok(Self::Resend),
                "probe" => Ok(Self::Probe),
                _ => Err("invalid value".into()),
            }
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookDeliveryTrigger {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookDeliveryTrigger {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookDeliveryTrigger {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    /// Data describing the result of a webhook liveness probe attempt.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Data describing the result of a webhook liveness probe
    /// attempt.",
    ///  "type": "object",
    ///  "required": [
    ///    "probe"
    ///  ],
    ///  "properties": {
    ///    "probe": {
    ///      "description": "The outcome of the probe request.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/WebhookDelivery"
    ///        }
    ///      ]
    ///    },
    ///    "resends_started": {
    ///      "description": "If the probe request succeeded, and resending
    /// failed deliveries on success was requested, the number of new delivery
    /// attempts started. Otherwise, if the probe did not succeed, or resending
    /// failed deliveries was not requested, this is null.\n\nNote that this may
    /// be 0, if there were no events found which had not been delivered
    /// successfully to this receiver.",
    ///      "type": [
    ///        "integer",
    ///        "null"
    ///      ],
    ///      "format": "uint",
    ///      "minimum": 0.0
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookProbeResult {
        /// The outcome of the probe request.
        pub probe: WebhookDelivery,
        /// If the probe request succeeded, and resending failed deliveries on
        /// success was requested, the number of new delivery attempts started.
        /// Otherwise, if the probe did not succeed, or resending failed
        /// deliveries was not requested, this is null.
        ///
        /// Note that this may be 0, if there were no events found which had not
        /// been delivered successfully to this receiver.
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub resends_started: ::std::option::Option<u32>,
    }

    impl ::std::convert::From<&WebhookProbeResult> for WebhookProbeResult {
        fn from(value: &WebhookProbeResult) -> Self {
            value.clone()
        }
    }

    impl WebhookProbeResult {
        pub fn builder() -> builder::WebhookProbeResult {
            Default::default()
        }
    }

    /// The configuration for a webhook.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "The configuration for a webhook.",
    ///  "type": "object",
    ///  "required": [
    ///    "description",
    ///    "endpoint",
    ///    "id",
    ///    "name",
    ///    "secrets",
    ///    "subscriptions",
    ///    "time_created",
    ///    "time_modified"
    ///  ],
    ///  "properties": {
    ///    "description": {
    ///      "description": "human-readable free-form text about a resource",
    ///      "type": "string"
    ///    },
    ///    "endpoint": {
    ///      "description": "The URL that webhook notification requests are sent
    /// to.",
    ///      "type": "string",
    ///      "format": "uri"
    ///    },
    ///    "id": {
    ///      "description": "unique, immutable, system-controlled identifier for
    /// each resource",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "name": {
    ///      "description": "unique, mutable, user-controlled identifier for
    /// each resource",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/Name"
    ///        }
    ///      ]
    ///    },
    ///    "secrets": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookSecret"
    ///      }
    ///    },
    ///    "subscriptions": {
    ///      "description": "The list of event classes to which this receiver is
    /// subscribed.",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookSubscription"
    ///      }
    ///    },
    ///    "time_created": {
    ///      "description": "timestamp when this resource was created",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    },
    ///    "time_modified": {
    ///      "description": "timestamp when this resource was last modified",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookReceiver {
        /// human-readable free-form text about a resource
        pub description: ::std::string::String,
        /// The URL that webhook notification requests are sent to.
        pub endpoint: ::std::string::String,
        /// unique, immutable, system-controlled identifier for each resource
        pub id: ::uuid::Uuid,
        /// unique, mutable, user-controlled identifier for each resource
        pub name: Name,
        pub secrets: ::std::vec::Vec<WebhookSecret>,
        /// The list of event classes to which this receiver is subscribed.
        pub subscriptions: ::std::vec::Vec<WebhookSubscription>,
        /// timestamp when this resource was created
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
        /// timestamp when this resource was last modified
        pub time_modified: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&WebhookReceiver> for WebhookReceiver {
        fn from(value: &WebhookReceiver) -> Self {
            value.clone()
        }
    }

    impl WebhookReceiver {
        pub fn builder() -> builder::WebhookReceiver {
            Default::default()
        }
    }

    /// A single page of results
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A single page of results",
    ///  "type": "object",
    ///  "required": [
    ///    "items"
    ///  ],
    ///  "properties": {
    ///    "items": {
    ///      "description": "list of items on this page of results",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookReceiver"
    ///      }
    ///    },
    ///    "next_page": {
    ///      "description": "token used to fetch the next page of results (if
    /// any)",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookReceiverResultsPage {
        /// list of items on this page of results
        pub items: ::std::vec::Vec<WebhookReceiver>,
        /// token used to fetch the next page of results (if any)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub next_page: ::std::option::Option<::std::string::String>,
    }

    impl ::std::convert::From<&WebhookReceiverResultsPage> for WebhookReceiverResultsPage {
        fn from(value: &WebhookReceiverResultsPage) -> Self {
            value.clone()
        }
    }

    impl WebhookReceiverResultsPage {
        pub fn builder() -> builder::WebhookReceiverResultsPage {
            Default::default()
        }
    }

    /// Parameters to update a webhook configuration.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "Parameters to update a webhook configuration.",
    ///  "type": "object",
    ///  "properties": {
    ///    "description": {
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ]
    ///    },
    ///    "endpoint": {
    ///      "description": "The URL that webhook notification requests should
    /// be sent to",
    ///      "type": [
    ///        "string",
    ///        "null"
    ///      ],
    ///      "format": "uri"
    ///    },
    ///    "name": {
    ///      "oneOf": [
    ///        {
    ///          "type": "null"
    ///        },
    ///        {
    ///          "allOf": [
    ///            {
    ///              "$ref": "#/components/schemas/Name"
    ///            }
    ///          ]
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookReceiverUpdate {
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub description: ::std::option::Option<::std::string::String>,
        /// The URL that webhook notification requests should be sent to
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub endpoint: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<Name>,
    }

    impl ::std::convert::From<&WebhookReceiverUpdate> for WebhookReceiverUpdate {
        fn from(value: &WebhookReceiverUpdate) -> Self {
            value.clone()
        }
    }

    impl ::std::default::Default for WebhookReceiverUpdate {
        fn default() -> Self {
            Self {
                description: Default::default(),
                endpoint: Default::default(),
                name: Default::default(),
            }
        }
    }

    impl WebhookReceiverUpdate {
        pub fn builder() -> builder::WebhookReceiverUpdate {
            Default::default()
        }
    }

    /// A view of a shared secret key assigned to a webhook receiver.
    ///
    /// Once a secret is created, the value of the secret is not available in
    /// the API, as it must remain secret. Instead, secrets are referenced by
    /// their unique IDs assigned when they are created.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A view of a shared secret key assigned to a webhook
    /// receiver.\n\nOnce a secret is created, the value of the secret is not
    /// available in the API, as it must remain secret. Instead, secrets are
    /// referenced by their unique IDs assigned when they are created.",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "time_created"
    ///  ],
    ///  "properties": {
    ///    "id": {
    ///      "description": "The public unique ID of the secret.",
    ///      "type": "string",
    ///      "format": "uuid"
    ///    },
    ///    "time_created": {
    ///      "description": "The UTC timestamp at which this secret was
    /// created.",
    ///      "type": "string",
    ///      "format": "date-time"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookSecret {
        /// The public unique ID of the secret.
        pub id: ::uuid::Uuid,
        /// The UTC timestamp at which this secret was created.
        pub time_created: ::chrono::DateTime<::chrono::offset::Utc>,
    }

    impl ::std::convert::From<&WebhookSecret> for WebhookSecret {
        fn from(value: &WebhookSecret) -> Self {
            value.clone()
        }
    }

    impl WebhookSecret {
        pub fn builder() -> builder::WebhookSecret {
            Default::default()
        }
    }

    /// `WebhookSecretCreate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "secret"
    ///  ],
    ///  "properties": {
    ///    "secret": {
    ///      "description": "The value of the shared secret key.",
    ///      "type": "string"
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookSecretCreate {
        /// The value of the shared secret key.
        pub secret: ::std::string::String,
    }

    impl ::std::convert::From<&WebhookSecretCreate> for WebhookSecretCreate {
        fn from(value: &WebhookSecretCreate) -> Self {
            value.clone()
        }
    }

    impl WebhookSecretCreate {
        pub fn builder() -> builder::WebhookSecretCreate {
            Default::default()
        }
    }

    /// A list of the IDs of secrets associated with a webhook.
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "description": "A list of the IDs of secrets associated with a
    /// webhook.",
    ///  "type": "object",
    ///  "required": [
    ///    "secrets"
    ///  ],
    ///  "properties": {
    ///    "secrets": {
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/WebhookSecret"
    ///      }
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookSecrets {
        pub secrets: ::std::vec::Vec<WebhookSecret>,
    }

    impl ::std::convert::From<&WebhookSecrets> for WebhookSecrets {
        fn from(value: &WebhookSecrets) -> Self {
            value.clone()
        }
    }

    impl WebhookSecrets {
        pub fn builder() -> builder::WebhookSecrets {
            Default::default()
        }
    }

    /// A webhook event class subscription matches either a single event class
    /// exactly, or a glob pattern including wildcards that may match multiple
    /// event classes
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "title": "A webhook event class subscription",
    ///  "description": "A webhook event class subscription matches either a
    /// single event class exactly, or a glob pattern including wildcards that
    /// may match multiple event classes",
    ///  "type": "string",
    ///  "pattern":
    /// "^([a-zA-Z0-9_]+|\\*|\\*\\*)(\\.([a-zA-Z0-9_]+|\\*|\\*\\*))*$"
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Serialize,
        Clone,
        Debug,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        schemars :: JsonSchema,
    )]
    #[serde(transparent)]
    pub struct WebhookSubscription(::std::string::String);
    impl ::std::ops::Deref for WebhookSubscription {
        type Target = ::std::string::String;
        fn deref(&self) -> &::std::string::String {
            &self.0
        }
    }

    impl ::std::convert::From<WebhookSubscription> for ::std::string::String {
        fn from(value: WebhookSubscription) -> Self {
            value.0
        }
    }

    impl ::std::convert::From<&WebhookSubscription> for WebhookSubscription {
        fn from(value: &WebhookSubscription) -> Self {
            value.clone()
        }
    }

    impl ::std::str::FromStr for WebhookSubscription {
        type Err = self::error::ConversionError;
        fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            if regress::Regex::new("^([a-zA-Z0-9_]+|\\*|\\*\\*)(\\.([a-zA-Z0-9_]+|\\*|\\*\\*))*$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \
                            \"^([a-zA-Z0-9_]+|\\*|\\*\\*)(\\.([a-zA-Z0-9_]+|\\*|\\*\\*))*$\""
                    .into());
            }
            Ok(Self(value.to_string()))
        }
    }

    impl ::std::convert::TryFrom<&str> for WebhookSubscription {
        type Error = self::error::ConversionError;
        fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<&::std::string::String> for WebhookSubscription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: &::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl ::std::convert::TryFrom<::std::string::String> for WebhookSubscription {
        type Error = self::error::ConversionError;
        fn try_from(
            value: ::std::string::String,
        ) -> ::std::result::Result<Self, self::error::ConversionError> {
            value.parse()
        }
    }

    impl<'de> ::serde::Deserialize<'de> for WebhookSubscription {
        fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
        where
            D: ::serde::Deserializer<'de>,
        {
            ::std::string::String::deserialize(deserializer)?
                .parse()
                .map_err(|e: self::error::ConversionError| {
                    <D::Error as ::serde::de::Error>::custom(e.to_string())
                })
        }
    }

    /// `WebhookSubscriptionCreate`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "subscription"
    ///  ],
    ///  "properties": {
    ///    "subscription": {
    ///      "description": "The event class pattern to subscribe to.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/WebhookSubscription"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookSubscriptionCreate {
        /// The event class pattern to subscribe to.
        pub subscription: WebhookSubscription,
    }

    impl ::std::convert::From<&WebhookSubscriptionCreate> for WebhookSubscriptionCreate {
        fn from(value: &WebhookSubscriptionCreate) -> Self {
            value.clone()
        }
    }

    impl WebhookSubscriptionCreate {
        pub fn builder() -> builder::WebhookSubscriptionCreate {
            Default::default()
        }
    }

    /// `WebhookSubscriptionCreated`
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    /// {
    ///  "type": "object",
    ///  "required": [
    ///    "subscription"
    ///  ],
    ///  "properties": {
    ///    "subscription": {
    ///      "description": "The new subscription added to the receiver.",
    ///      "allOf": [
    ///        {
    ///          "$ref": "#/components/schemas/WebhookSubscription"
    ///        }
    ///      ]
    ///    }
    ///  }
    /// }
    /// ```
    /// </details>
    #[derive(
        :: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, schemars :: JsonSchema,
    )]
    pub struct WebhookSubscriptionCreated {
        /// The new subscription added to the receiver.
        pub subscription: WebhookSubscription,
    }

    impl ::std::convert::From<&WebhookSubscriptionCreated> for WebhookSubscriptionCreated {
        fn from(value: &WebhookSubscriptionCreated) -> Self {
            value.clone()
        }
    }

    impl WebhookSubscriptionCreated {
        pub fn builder() -> builder::WebhookSubscriptionCreated {
            Default::default()
        }
    }

    /// Types for composing complex structures.
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct Address {
            address: ::std::result::Result<super::IpNet, ::std::string::String>,
            address_lot: ::std::result::Result<super::NameOrId, ::std::string::String>,
            vlan_id: ::std::result::Result<::std::option::Option<u16>, ::std::string::String>,
        }

        impl ::std::default::Default for Address {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    address_lot: Err("no value supplied for address_lot".to_string()),
                    vlan_id: Ok(Default::default()),
                }
            }
        }

        impl Address {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn address_lot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.address_lot = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address_lot: {}", e));
                self
            }
            pub fn vlan_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u16>>,
                T::Error: ::std::fmt::Display,
            {
                self.vlan_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vlan_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Address> for super::Address {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Address,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    address_lot: value.address_lot?,
                    vlan_id: value.vlan_id?,
                })
            }
        }

        impl ::std::convert::From<super::Address> for Address {
            fn from(value: super::Address) -> Self {
                Self {
                    address: Ok(value.address),
                    address_lot: Ok(value.address_lot),
                    vlan_id: Ok(value.vlan_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressConfig {
            addresses:
                ::std::result::Result<::std::vec::Vec<super::Address>, ::std::string::String>,
        }

        impl ::std::default::Default for AddressConfig {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                }
            }
        }

        impl AddressConfig {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Address>>,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AddressConfig> for super::AddressConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                })
            }
        }

        impl ::std::convert::From<super::AddressConfig> for AddressConfig {
            fn from(value: super::AddressConfig) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLot {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            kind: ::std::result::Result<super::AddressLotKind, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AddressLot {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl AddressLot {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AddressLotKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLot> for super::AddressLot {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLot,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLot> for AddressLot {
            fn from(value: super::AddressLot) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    kind: Ok(value.kind),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLotBlock {
            first_address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            last_address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
        }

        impl ::std::default::Default for AddressLotBlock {
            fn default() -> Self {
                Self {
                    first_address: Err("no value supplied for first_address".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    last_address: Err("no value supplied for last_address".to_string()),
                }
            }
        }

        impl AddressLotBlock {
            pub fn first_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.first_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for first_address: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn last_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.last_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_address: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLotBlock> for super::AddressLotBlock {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLotBlock,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_address: value.first_address?,
                    id: value.id?,
                    last_address: value.last_address?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLotBlock> for AddressLotBlock {
            fn from(value: super::AddressLotBlock) -> Self {
                Self {
                    first_address: Ok(value.first_address),
                    id: Ok(value.id),
                    last_address: Ok(value.last_address),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLotBlockCreate {
            first_address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            last_address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
        }

        impl ::std::default::Default for AddressLotBlockCreate {
            fn default() -> Self {
                Self {
                    first_address: Err("no value supplied for first_address".to_string()),
                    last_address: Err("no value supplied for last_address".to_string()),
                }
            }
        }

        impl AddressLotBlockCreate {
            pub fn first_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.first_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for first_address: {}", e)
                });
                self
            }
            pub fn last_address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.last_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for last_address: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLotBlockCreate> for super::AddressLotBlockCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLotBlockCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_address: value.first_address?,
                    last_address: value.last_address?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLotBlockCreate> for AddressLotBlockCreate {
            fn from(value: super::AddressLotBlockCreate) -> Self {
                Self {
                    first_address: Ok(value.first_address),
                    last_address: Ok(value.last_address),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLotBlockResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::AddressLotBlock>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AddressLotBlockResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl AddressLotBlockResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressLotBlock>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLotBlockResultsPage> for super::AddressLotBlockResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLotBlockResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLotBlockResultsPage> for AddressLotBlockResultsPage {
            fn from(value: super::AddressLotBlockResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLotCreate {
            blocks: ::std::result::Result<
                ::std::vec::Vec<super::AddressLotBlockCreate>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            kind: ::std::result::Result<super::AddressLotKind, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for AddressLotCreate {
            fn default() -> Self {
                Self {
                    blocks: Err("no value supplied for blocks".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl AddressLotCreate {
            pub fn blocks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressLotBlockCreate>>,
                T::Error: ::std::fmt::Display,
            {
                self.blocks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for blocks: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AddressLotKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLotCreate> for super::AddressLotCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLotCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    blocks: value.blocks?,
                    description: value.description?,
                    kind: value.kind?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLotCreate> for AddressLotCreate {
            fn from(value: super::AddressLotCreate) -> Self {
                Self {
                    blocks: Ok(value.blocks),
                    description: Ok(value.description),
                    kind: Ok(value.kind),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLotCreateResponse {
            blocks: ::std::result::Result<
                ::std::vec::Vec<super::AddressLotBlock>,
                ::std::string::String,
            >,
            lot: ::std::result::Result<super::AddressLot, ::std::string::String>,
        }

        impl ::std::default::Default for AddressLotCreateResponse {
            fn default() -> Self {
                Self {
                    blocks: Err("no value supplied for blocks".to_string()),
                    lot: Err("no value supplied for lot".to_string()),
                }
            }
        }

        impl AddressLotCreateResponse {
            pub fn blocks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressLotBlock>>,
                T::Error: ::std::fmt::Display,
            {
                self.blocks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for blocks: {}", e));
                self
            }
            pub fn lot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AddressLot>,
                T::Error: ::std::fmt::Display,
            {
                self.lot = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for lot: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLotCreateResponse> for super::AddressLotCreateResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLotCreateResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    blocks: value.blocks?,
                    lot: value.lot?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLotCreateResponse> for AddressLotCreateResponse {
            fn from(value: super::AddressLotCreateResponse) -> Self {
                Self {
                    blocks: Ok(value.blocks),
                    lot: Ok(value.lot),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AddressLotResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::AddressLot>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AddressLotResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl AddressLotResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AddressLot>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AddressLotResultsPage> for super::AddressLotResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AddressLotResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::AddressLotResultsPage> for AddressLotResultsPage {
            fn from(value: super::AddressLotResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AffinityGroup {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            failure_domain: ::std::result::Result<super::FailureDomain, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            policy: ::std::result::Result<super::AffinityPolicy, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AffinityGroup {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    failure_domain: Err("no value supplied for failure_domain".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl AffinityGroup {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn failure_domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FailureDomain>,
                T::Error: ::std::fmt::Display,
            {
                self.failure_domain = value.try_into().map_err(|e| {
                    format!("error converting supplied value for failure_domain: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AffinityPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AffinityGroup> for super::AffinityGroup {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AffinityGroup,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    failure_domain: value.failure_domain?,
                    id: value.id?,
                    name: value.name?,
                    policy: value.policy?,
                    project_id: value.project_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::AffinityGroup> for AffinityGroup {
            fn from(value: super::AffinityGroup) -> Self {
                Self {
                    description: Ok(value.description),
                    failure_domain: Ok(value.failure_domain),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    policy: Ok(value.policy),
                    project_id: Ok(value.project_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AffinityGroupCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            failure_domain: ::std::result::Result<super::FailureDomain, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            policy: ::std::result::Result<super::AffinityPolicy, ::std::string::String>,
        }

        impl ::std::default::Default for AffinityGroupCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    failure_domain: Err("no value supplied for failure_domain".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                }
            }
        }

        impl AffinityGroupCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn failure_domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FailureDomain>,
                T::Error: ::std::fmt::Display,
            {
                self.failure_domain = value.try_into().map_err(|e| {
                    format!("error converting supplied value for failure_domain: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AffinityPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AffinityGroupCreate> for super::AffinityGroupCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AffinityGroupCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    failure_domain: value.failure_domain?,
                    name: value.name?,
                    policy: value.policy?,
                })
            }
        }

        impl ::std::convert::From<super::AffinityGroupCreate> for AffinityGroupCreate {
            fn from(value: super::AffinityGroupCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    failure_domain: Ok(value.failure_domain),
                    name: Ok(value.name),
                    policy: Ok(value.policy),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AffinityGroupMemberResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::AffinityGroupMember>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AffinityGroupMemberResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl AffinityGroupMemberResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AffinityGroupMember>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AffinityGroupMemberResultsPage>
            for super::AffinityGroupMemberResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AffinityGroupMemberResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::AffinityGroupMemberResultsPage>
            for AffinityGroupMemberResultsPage
        {
            fn from(value: super::AffinityGroupMemberResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AffinityGroupResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::AffinityGroup>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AffinityGroupResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl AffinityGroupResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AffinityGroup>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AffinityGroupResultsPage> for super::AffinityGroupResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AffinityGroupResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::AffinityGroupResultsPage> for AffinityGroupResultsPage {
            fn from(value: super::AffinityGroupResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AffinityGroupUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for AffinityGroupUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl AffinityGroupUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AffinityGroupUpdate> for super::AffinityGroupUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AffinityGroupUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::AffinityGroupUpdate> for AffinityGroupUpdate {
            fn from(value: super::AffinityGroupUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AggregateBgpMessageHistory {
            switch_histories: ::std::result::Result<
                ::std::vec::Vec<super::SwitchBgpHistory>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AggregateBgpMessageHistory {
            fn default() -> Self {
                Self {
                    switch_histories: Err("no value supplied for switch_histories".to_string()),
                }
            }
        }

        impl AggregateBgpMessageHistory {
            pub fn switch_histories<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchBgpHistory>>,
                T::Error: ::std::fmt::Display,
            {
                self.switch_histories = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for switch_histories: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AggregateBgpMessageHistory> for super::AggregateBgpMessageHistory {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AggregateBgpMessageHistory,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    switch_histories: value.switch_histories?,
                })
            }
        }

        impl ::std::convert::From<super::AggregateBgpMessageHistory> for AggregateBgpMessageHistory {
            fn from(value: super::AggregateBgpMessageHistory) -> Self {
                Self {
                    switch_histories: Ok(value.switch_histories),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AllowList {
            allowed_ips: ::std::result::Result<super::AllowedSourceIps, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AllowList {
            fn default() -> Self {
                Self {
                    allowed_ips: Err("no value supplied for allowed_ips".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl AllowList {
            pub fn allowed_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AllowedSourceIps>,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_ips = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowed_ips: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AllowList> for super::AllowList {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AllowList,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowed_ips: value.allowed_ips?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::AllowList> for AllowList {
            fn from(value: super::AllowList) -> Self {
                Self {
                    allowed_ips: Ok(value.allowed_ips),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AllowListUpdate {
            allowed_ips: ::std::result::Result<super::AllowedSourceIps, ::std::string::String>,
        }

        impl ::std::default::Default for AllowListUpdate {
            fn default() -> Self {
                Self {
                    allowed_ips: Err("no value supplied for allowed_ips".to_string()),
                }
            }
        }

        impl AllowListUpdate {
            pub fn allowed_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AllowedSourceIps>,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_ips = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allowed_ips: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AllowListUpdate> for super::AllowListUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AllowListUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allowed_ips: value.allowed_ips?,
                })
            }
        }

        impl ::std::convert::From<super::AllowListUpdate> for AllowListUpdate {
            fn from(value: super::AllowListUpdate) -> Self {
                Self {
                    allowed_ips: Ok(value.allowed_ips),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AntiAffinityGroup {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            failure_domain: ::std::result::Result<super::FailureDomain, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            policy: ::std::result::Result<super::AffinityPolicy, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AntiAffinityGroup {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    failure_domain: Err("no value supplied for failure_domain".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl AntiAffinityGroup {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn failure_domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FailureDomain>,
                T::Error: ::std::fmt::Display,
            {
                self.failure_domain = value.try_into().map_err(|e| {
                    format!("error converting supplied value for failure_domain: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AffinityPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<AntiAffinityGroup> for super::AntiAffinityGroup {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AntiAffinityGroup,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    failure_domain: value.failure_domain?,
                    id: value.id?,
                    name: value.name?,
                    policy: value.policy?,
                    project_id: value.project_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::AntiAffinityGroup> for AntiAffinityGroup {
            fn from(value: super::AntiAffinityGroup) -> Self {
                Self {
                    description: Ok(value.description),
                    failure_domain: Ok(value.failure_domain),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    policy: Ok(value.policy),
                    project_id: Ok(value.project_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AntiAffinityGroupCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            failure_domain: ::std::result::Result<super::FailureDomain, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            policy: ::std::result::Result<super::AffinityPolicy, ::std::string::String>,
        }

        impl ::std::default::Default for AntiAffinityGroupCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    failure_domain: Err("no value supplied for failure_domain".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                }
            }
        }

        impl AntiAffinityGroupCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn failure_domain<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FailureDomain>,
                T::Error: ::std::fmt::Display,
            {
                self.failure_domain = value.try_into().map_err(|e| {
                    format!("error converting supplied value for failure_domain: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AffinityPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AntiAffinityGroupCreate> for super::AntiAffinityGroupCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AntiAffinityGroupCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    failure_domain: value.failure_domain?,
                    name: value.name?,
                    policy: value.policy?,
                })
            }
        }

        impl ::std::convert::From<super::AntiAffinityGroupCreate> for AntiAffinityGroupCreate {
            fn from(value: super::AntiAffinityGroupCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    failure_domain: Ok(value.failure_domain),
                    name: Ok(value.name),
                    policy: Ok(value.policy),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AntiAffinityGroupMemberResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::AntiAffinityGroupMember>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AntiAffinityGroupMemberResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl AntiAffinityGroupMemberResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AntiAffinityGroupMember>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AntiAffinityGroupMemberResultsPage>
            for super::AntiAffinityGroupMemberResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AntiAffinityGroupMemberResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::AntiAffinityGroupMemberResultsPage>
            for AntiAffinityGroupMemberResultsPage
        {
            fn from(value: super::AntiAffinityGroupMemberResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AntiAffinityGroupResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::AntiAffinityGroup>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for AntiAffinityGroupResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl AntiAffinityGroupResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::AntiAffinityGroup>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AntiAffinityGroupResultsPage> for super::AntiAffinityGroupResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AntiAffinityGroupResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::AntiAffinityGroupResultsPage> for AntiAffinityGroupResultsPage {
            fn from(value: super::AntiAffinityGroupResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct AntiAffinityGroupUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for AntiAffinityGroupUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl AntiAffinityGroupUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<AntiAffinityGroupUpdate> for super::AntiAffinityGroupUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: AntiAffinityGroupUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::AntiAffinityGroupUpdate> for AntiAffinityGroupUpdate {
            fn from(value: super::AntiAffinityGroupUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Baseboard {
            part: ::std::result::Result<::std::string::String, ::std::string::String>,
            revision: ::std::result::Result<u32, ::std::string::String>,
            serial: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for Baseboard {
            fn default() -> Self {
                Self {
                    part: Err("no value supplied for part".to_string()),
                    revision: Err("no value supplied for revision".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                }
            }
        }

        impl Baseboard {
            pub fn part<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.part = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for part: {}", e));
                self
            }
            pub fn revision<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.revision = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revision: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Baseboard> for super::Baseboard {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Baseboard,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    part: value.part?,
                    revision: value.revision?,
                    serial: value.serial?,
                })
            }
        }

        impl ::std::convert::From<super::Baseboard> for Baseboard {
            fn from(value: super::Baseboard) -> Self {
                Self {
                    part: Ok(value.part),
                    revision: Ok(value.revision),
                    serial: Ok(value.serial),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BfdSessionDisable {
            remote: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            switch: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for BfdSessionDisable {
            fn default() -> Self {
                Self {
                    remote: Err("no value supplied for remote".to_string()),
                    switch: Err("no value supplied for switch".to_string()),
                }
            }
        }

        impl BfdSessionDisable {
            pub fn remote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.remote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for remote: {}", e));
                self
            }
            pub fn switch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.switch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for switch: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BfdSessionDisable> for super::BfdSessionDisable {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BfdSessionDisable,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    remote: value.remote?,
                    switch: value.switch?,
                })
            }
        }

        impl ::std::convert::From<super::BfdSessionDisable> for BfdSessionDisable {
            fn from(value: super::BfdSessionDisable) -> Self {
                Self {
                    remote: Ok(value.remote),
                    switch: Ok(value.switch),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BfdSessionEnable {
            detection_threshold: ::std::result::Result<u8, ::std::string::String>,
            local: ::std::result::Result<
                ::std::option::Option<::std::net::IpAddr>,
                ::std::string::String,
            >,
            mode: ::std::result::Result<super::BfdMode, ::std::string::String>,
            remote: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            required_rx: ::std::result::Result<u64, ::std::string::String>,
            switch: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for BfdSessionEnable {
            fn default() -> Self {
                Self {
                    detection_threshold: Err(
                        "no value supplied for detection_threshold".to_string()
                    ),
                    local: Ok(Default::default()),
                    mode: Err("no value supplied for mode".to_string()),
                    remote: Err("no value supplied for remote".to_string()),
                    required_rx: Err("no value supplied for required_rx".to_string()),
                    switch: Err("no value supplied for switch".to_string()),
                }
            }
        }

        impl BfdSessionEnable {
            pub fn detection_threshold<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.detection_threshold = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for detection_threshold: {}",
                        e
                    )
                });
                self
            }
            pub fn local<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::net::IpAddr>>,
                T::Error: ::std::fmt::Display,
            {
                self.local = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for local: {}", e));
                self
            }
            pub fn mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BfdMode>,
                T::Error: ::std::fmt::Display,
            {
                self.mode = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mode: {}", e));
                self
            }
            pub fn remote<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.remote = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for remote: {}", e));
                self
            }
            pub fn required_rx<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.required_rx = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for required_rx: {}", e));
                self
            }
            pub fn switch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.switch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for switch: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BfdSessionEnable> for super::BfdSessionEnable {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BfdSessionEnable,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    detection_threshold: value.detection_threshold?,
                    local: value.local?,
                    mode: value.mode?,
                    remote: value.remote?,
                    required_rx: value.required_rx?,
                    switch: value.switch?,
                })
            }
        }

        impl ::std::convert::From<super::BfdSessionEnable> for BfdSessionEnable {
            fn from(value: super::BfdSessionEnable) -> Self {
                Self {
                    detection_threshold: Ok(value.detection_threshold),
                    local: Ok(value.local),
                    mode: Ok(value.mode),
                    remote: Ok(value.remote),
                    required_rx: Ok(value.required_rx),
                    switch: Ok(value.switch),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BfdStatus {
            detection_threshold: ::std::result::Result<u8, ::std::string::String>,
            local: ::std::result::Result<
                ::std::option::Option<::std::net::IpAddr>,
                ::std::string::String,
            >,
            mode: ::std::result::Result<super::BfdMode, ::std::string::String>,
            peer: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            required_rx: ::std::result::Result<u64, ::std::string::String>,
            state: ::std::result::Result<super::BfdState, ::std::string::String>,
            switch: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for BfdStatus {
            fn default() -> Self {
                Self {
                    detection_threshold: Err(
                        "no value supplied for detection_threshold".to_string()
                    ),
                    local: Ok(Default::default()),
                    mode: Err("no value supplied for mode".to_string()),
                    peer: Err("no value supplied for peer".to_string()),
                    required_rx: Err("no value supplied for required_rx".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    switch: Err("no value supplied for switch".to_string()),
                }
            }
        }

        impl BfdStatus {
            pub fn detection_threshold<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.detection_threshold = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for detection_threshold: {}",
                        e
                    )
                });
                self
            }
            pub fn local<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::net::IpAddr>>,
                T::Error: ::std::fmt::Display,
            {
                self.local = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for local: {}", e));
                self
            }
            pub fn mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BfdMode>,
                T::Error: ::std::fmt::Display,
            {
                self.mode = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mode: {}", e));
                self
            }
            pub fn peer<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.peer = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peer: {}", e));
                self
            }
            pub fn required_rx<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.required_rx = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for required_rx: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BfdState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn switch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.switch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for switch: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BfdStatus> for super::BfdStatus {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BfdStatus,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    detection_threshold: value.detection_threshold?,
                    local: value.local?,
                    mode: value.mode?,
                    peer: value.peer?,
                    required_rx: value.required_rx?,
                    state: value.state?,
                    switch: value.switch?,
                })
            }
        }

        impl ::std::convert::From<super::BfdStatus> for BfdStatus {
            fn from(value: super::BfdStatus) -> Self {
                Self {
                    detection_threshold: Ok(value.detection_threshold),
                    local: Ok(value.local),
                    mode: Ok(value.mode),
                    peer: Ok(value.peer),
                    required_rx: Ok(value.required_rx),
                    state: Ok(value.state),
                    switch: Ok(value.switch),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpAnnounceSet {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for BgpAnnounceSet {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl BgpAnnounceSet {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<BgpAnnounceSet> for super::BgpAnnounceSet {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpAnnounceSet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::BgpAnnounceSet> for BgpAnnounceSet {
            fn from(value: super::BgpAnnounceSet) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpAnnounceSetCreate {
            announcement: ::std::result::Result<
                ::std::vec::Vec<super::BgpAnnouncementCreate>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for BgpAnnounceSetCreate {
            fn default() -> Self {
                Self {
                    announcement: Err("no value supplied for announcement".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl BgpAnnounceSetCreate {
            pub fn announcement<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BgpAnnouncementCreate>>,
                T::Error: ::std::fmt::Display,
            {
                self.announcement = value.try_into().map_err(|e| {
                    format!("error converting supplied value for announcement: {}", e)
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpAnnounceSetCreate> for super::BgpAnnounceSetCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpAnnounceSetCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    announcement: value.announcement?,
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::BgpAnnounceSetCreate> for BgpAnnounceSetCreate {
            fn from(value: super::BgpAnnounceSetCreate) -> Self {
                Self {
                    announcement: Ok(value.announcement),
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpAnnouncement {
            address_lot_block_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            announce_set_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            network: ::std::result::Result<super::IpNet, ::std::string::String>,
        }

        impl ::std::default::Default for BgpAnnouncement {
            fn default() -> Self {
                Self {
                    address_lot_block_id: Err(
                        "no value supplied for address_lot_block_id".to_string()
                    ),
                    announce_set_id: Err("no value supplied for announce_set_id".to_string()),
                    network: Err("no value supplied for network".to_string()),
                }
            }
        }

        impl BgpAnnouncement {
            pub fn address_lot_block_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.address_lot_block_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for address_lot_block_id: {}",
                        e
                    )
                });
                self
            }
            pub fn announce_set_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.announce_set_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for announce_set_id: {}", e)
                });
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpAnnouncement> for super::BgpAnnouncement {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpAnnouncement,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address_lot_block_id: value.address_lot_block_id?,
                    announce_set_id: value.announce_set_id?,
                    network: value.network?,
                })
            }
        }

        impl ::std::convert::From<super::BgpAnnouncement> for BgpAnnouncement {
            fn from(value: super::BgpAnnouncement) -> Self {
                Self {
                    address_lot_block_id: Ok(value.address_lot_block_id),
                    announce_set_id: Ok(value.announce_set_id),
                    network: Ok(value.network),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpAnnouncementCreate {
            address_lot_block: ::std::result::Result<super::NameOrId, ::std::string::String>,
            network: ::std::result::Result<super::IpNet, ::std::string::String>,
        }

        impl ::std::default::Default for BgpAnnouncementCreate {
            fn default() -> Self {
                Self {
                    address_lot_block: Err("no value supplied for address_lot_block".to_string()),
                    network: Err("no value supplied for network".to_string()),
                }
            }
        }

        impl BgpAnnouncementCreate {
            pub fn address_lot_block<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.address_lot_block = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for address_lot_block: {}",
                        e
                    )
                });
                self
            }
            pub fn network<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.network = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for network: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpAnnouncementCreate> for super::BgpAnnouncementCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpAnnouncementCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address_lot_block: value.address_lot_block?,
                    network: value.network?,
                })
            }
        }

        impl ::std::convert::From<super::BgpAnnouncementCreate> for BgpAnnouncementCreate {
            fn from(value: super::BgpAnnouncementCreate) -> Self {
                Self {
                    address_lot_block: Ok(value.address_lot_block),
                    network: Ok(value.network),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpConfig {
            asn: ::std::result::Result<u32, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vrf: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for BgpConfig {
            fn default() -> Self {
                Self {
                    asn: Err("no value supplied for asn".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vrf: Ok(Default::default()),
                }
            }
        }

        impl BgpConfig {
            pub fn asn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.asn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for asn: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vrf<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.vrf = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vrf: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpConfig> for super::BgpConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    asn: value.asn?,
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vrf: value.vrf?,
                })
            }
        }

        impl ::std::convert::From<super::BgpConfig> for BgpConfig {
            fn from(value: super::BgpConfig) -> Self {
                Self {
                    asn: Ok(value.asn),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vrf: Ok(value.vrf),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpConfigCreate {
            asn: ::std::result::Result<u32, ::std::string::String>,
            bgp_announce_set_id: ::std::result::Result<super::NameOrId, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            vrf: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for BgpConfigCreate {
            fn default() -> Self {
                Self {
                    asn: Err("no value supplied for asn".to_string()),
                    bgp_announce_set_id: Err(
                        "no value supplied for bgp_announce_set_id".to_string()
                    ),
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    vrf: Ok(Default::default()),
                }
            }
        }

        impl BgpConfigCreate {
            pub fn asn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.asn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for asn: {}", e));
                self
            }
            pub fn bgp_announce_set_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.bgp_announce_set_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for bgp_announce_set_id: {}",
                        e
                    )
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn vrf<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.vrf = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vrf: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpConfigCreate> for super::BgpConfigCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpConfigCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    asn: value.asn?,
                    bgp_announce_set_id: value.bgp_announce_set_id?,
                    description: value.description?,
                    name: value.name?,
                    vrf: value.vrf?,
                })
            }
        }

        impl ::std::convert::From<super::BgpConfigCreate> for BgpConfigCreate {
            fn from(value: super::BgpConfigCreate) -> Self {
                Self {
                    asn: Ok(value.asn),
                    bgp_announce_set_id: Ok(value.bgp_announce_set_id),
                    description: Ok(value.description),
                    name: Ok(value.name),
                    vrf: Ok(value.vrf),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpConfigResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::BgpConfig>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for BgpConfigResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl BgpConfigResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BgpConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpConfigResultsPage> for super::BgpConfigResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpConfigResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::BgpConfigResultsPage> for BgpConfigResultsPage {
            fn from(value: super::BgpConfigResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpExported {
            exports: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<super::Ipv4Net>>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for BgpExported {
            fn default() -> Self {
                Self {
                    exports: Err("no value supplied for exports".to_string()),
                }
            }
        }

        impl BgpExported {
            pub fn exports<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        ::std::vec::Vec<super::Ipv4Net>,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.exports = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for exports: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpExported> for super::BgpExported {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpExported,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    exports: value.exports?,
                })
            }
        }

        impl ::std::convert::From<super::BgpExported> for BgpExported {
            fn from(value: super::BgpExported) -> Self {
                Self {
                    exports: Ok(value.exports),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpImportedRouteIpv4 {
            id: ::std::result::Result<u32, ::std::string::String>,
            nexthop: ::std::result::Result<::std::net::Ipv4Addr, ::std::string::String>,
            prefix: ::std::result::Result<super::Ipv4Net, ::std::string::String>,
            switch: ::std::result::Result<super::SwitchLocation, ::std::string::String>,
        }

        impl ::std::default::Default for BgpImportedRouteIpv4 {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    nexthop: Err("no value supplied for nexthop".to_string()),
                    prefix: Err("no value supplied for prefix".to_string()),
                    switch: Err("no value supplied for switch".to_string()),
                }
            }
        }

        impl BgpImportedRouteIpv4 {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn nexthop<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::Ipv4Addr>,
                T::Error: ::std::fmt::Display,
            {
                self.nexthop = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for nexthop: {}", e));
                self
            }
            pub fn prefix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv4Net>,
                T::Error: ::std::fmt::Display,
            {
                self.prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for prefix: {}", e));
                self
            }
            pub fn switch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchLocation>,
                T::Error: ::std::fmt::Display,
            {
                self.switch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for switch: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpImportedRouteIpv4> for super::BgpImportedRouteIpv4 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpImportedRouteIpv4,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    nexthop: value.nexthop?,
                    prefix: value.prefix?,
                    switch: value.switch?,
                })
            }
        }

        impl ::std::convert::From<super::BgpImportedRouteIpv4> for BgpImportedRouteIpv4 {
            fn from(value: super::BgpImportedRouteIpv4) -> Self {
                Self {
                    id: Ok(value.id),
                    nexthop: Ok(value.nexthop),
                    prefix: Ok(value.prefix),
                    switch: Ok(value.switch),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpPeer {
            addr: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            allowed_export: ::std::result::Result<super::ImportExportPolicy, ::std::string::String>,
            allowed_import: ::std::result::Result<super::ImportExportPolicy, ::std::string::String>,
            bgp_config: ::std::result::Result<super::NameOrId, ::std::string::String>,
            communities: ::std::result::Result<::std::vec::Vec<u32>, ::std::string::String>,
            connect_retry: ::std::result::Result<u32, ::std::string::String>,
            delay_open: ::std::result::Result<u32, ::std::string::String>,
            enforce_first_as: ::std::result::Result<bool, ::std::string::String>,
            hold_time: ::std::result::Result<u32, ::std::string::String>,
            idle_hold_time: ::std::result::Result<u32, ::std::string::String>,
            interface_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            keepalive: ::std::result::Result<u32, ::std::string::String>,
            local_pref: ::std::result::Result<::std::option::Option<u32>, ::std::string::String>,
            md5_auth_key: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            min_ttl: ::std::result::Result<::std::option::Option<u8>, ::std::string::String>,
            multi_exit_discriminator:
                ::std::result::Result<::std::option::Option<u32>, ::std::string::String>,
            remote_asn: ::std::result::Result<::std::option::Option<u32>, ::std::string::String>,
            vlan_id: ::std::result::Result<::std::option::Option<u16>, ::std::string::String>,
        }

        impl ::std::default::Default for BgpPeer {
            fn default() -> Self {
                Self {
                    addr: Err("no value supplied for addr".to_string()),
                    allowed_export: Err("no value supplied for allowed_export".to_string()),
                    allowed_import: Err("no value supplied for allowed_import".to_string()),
                    bgp_config: Err("no value supplied for bgp_config".to_string()),
                    communities: Err("no value supplied for communities".to_string()),
                    connect_retry: Err("no value supplied for connect_retry".to_string()),
                    delay_open: Err("no value supplied for delay_open".to_string()),
                    enforce_first_as: Err("no value supplied for enforce_first_as".to_string()),
                    hold_time: Err("no value supplied for hold_time".to_string()),
                    idle_hold_time: Err("no value supplied for idle_hold_time".to_string()),
                    interface_name: Err("no value supplied for interface_name".to_string()),
                    keepalive: Err("no value supplied for keepalive".to_string()),
                    local_pref: Ok(Default::default()),
                    md5_auth_key: Ok(Default::default()),
                    min_ttl: Ok(Default::default()),
                    multi_exit_discriminator: Ok(Default::default()),
                    remote_asn: Ok(Default::default()),
                    vlan_id: Ok(Default::default()),
                }
            }
        }

        impl BgpPeer {
            pub fn addr<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.addr = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addr: {}", e));
                self
            }
            pub fn allowed_export<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ImportExportPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_export = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_export: {}", e)
                });
                self
            }
            pub fn allowed_import<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ImportExportPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.allowed_import = value.try_into().map_err(|e| {
                    format!("error converting supplied value for allowed_import: {}", e)
                });
                self
            }
            pub fn bgp_config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.bgp_config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bgp_config: {}", e));
                self
            }
            pub fn communities<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u32>>,
                T::Error: ::std::fmt::Display,
            {
                self.communities = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for communities: {}", e));
                self
            }
            pub fn connect_retry<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.connect_retry = value.try_into().map_err(|e| {
                    format!("error converting supplied value for connect_retry: {}", e)
                });
                self
            }
            pub fn delay_open<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.delay_open = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delay_open: {}", e));
                self
            }
            pub fn enforce_first_as<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enforce_first_as = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for enforce_first_as: {}",
                        e
                    )
                });
                self
            }
            pub fn hold_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.hold_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hold_time: {}", e));
                self
            }
            pub fn idle_hold_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.idle_hold_time = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idle_hold_time: {}", e)
                });
                self
            }
            pub fn interface_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.interface_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for interface_name: {}", e)
                });
                self
            }
            pub fn keepalive<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.keepalive = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for keepalive: {}", e));
                self
            }
            pub fn local_pref<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u32>>,
                T::Error: ::std::fmt::Display,
            {
                self.local_pref = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for local_pref: {}", e));
                self
            }
            pub fn md5_auth_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.md5_auth_key = value.try_into().map_err(|e| {
                    format!("error converting supplied value for md5_auth_key: {}", e)
                });
                self
            }
            pub fn min_ttl<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u8>>,
                T::Error: ::std::fmt::Display,
            {
                self.min_ttl = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min_ttl: {}", e));
                self
            }
            pub fn multi_exit_discriminator<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u32>>,
                T::Error: ::std::fmt::Display,
            {
                self.multi_exit_discriminator = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for multi_exit_discriminator: {}",
                        e
                    )
                });
                self
            }
            pub fn remote_asn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u32>>,
                T::Error: ::std::fmt::Display,
            {
                self.remote_asn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for remote_asn: {}", e));
                self
            }
            pub fn vlan_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u16>>,
                T::Error: ::std::fmt::Display,
            {
                self.vlan_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vlan_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpPeer> for super::BgpPeer {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpPeer,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addr: value.addr?,
                    allowed_export: value.allowed_export?,
                    allowed_import: value.allowed_import?,
                    bgp_config: value.bgp_config?,
                    communities: value.communities?,
                    connect_retry: value.connect_retry?,
                    delay_open: value.delay_open?,
                    enforce_first_as: value.enforce_first_as?,
                    hold_time: value.hold_time?,
                    idle_hold_time: value.idle_hold_time?,
                    interface_name: value.interface_name?,
                    keepalive: value.keepalive?,
                    local_pref: value.local_pref?,
                    md5_auth_key: value.md5_auth_key?,
                    min_ttl: value.min_ttl?,
                    multi_exit_discriminator: value.multi_exit_discriminator?,
                    remote_asn: value.remote_asn?,
                    vlan_id: value.vlan_id?,
                })
            }
        }

        impl ::std::convert::From<super::BgpPeer> for BgpPeer {
            fn from(value: super::BgpPeer) -> Self {
                Self {
                    addr: Ok(value.addr),
                    allowed_export: Ok(value.allowed_export),
                    allowed_import: Ok(value.allowed_import),
                    bgp_config: Ok(value.bgp_config),
                    communities: Ok(value.communities),
                    connect_retry: Ok(value.connect_retry),
                    delay_open: Ok(value.delay_open),
                    enforce_first_as: Ok(value.enforce_first_as),
                    hold_time: Ok(value.hold_time),
                    idle_hold_time: Ok(value.idle_hold_time),
                    interface_name: Ok(value.interface_name),
                    keepalive: Ok(value.keepalive),
                    local_pref: Ok(value.local_pref),
                    md5_auth_key: Ok(value.md5_auth_key),
                    min_ttl: Ok(value.min_ttl),
                    multi_exit_discriminator: Ok(value.multi_exit_discriminator),
                    remote_asn: Ok(value.remote_asn),
                    vlan_id: Ok(value.vlan_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpPeerConfig {
            peers: ::std::result::Result<::std::vec::Vec<super::BgpPeer>, ::std::string::String>,
        }

        impl ::std::default::Default for BgpPeerConfig {
            fn default() -> Self {
                Self {
                    peers: Err("no value supplied for peers".to_string()),
                }
            }
        }

        impl BgpPeerConfig {
            pub fn peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BgpPeer>>,
                T::Error: ::std::fmt::Display,
            {
                self.peers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for peers: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpPeerConfig> for super::BgpPeerConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpPeerConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    peers: value.peers?,
                })
            }
        }

        impl ::std::convert::From<super::BgpPeerConfig> for BgpPeerConfig {
            fn from(value: super::BgpPeerConfig) -> Self {
                Self {
                    peers: Ok(value.peers),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct BgpPeerStatus {
            addr: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            local_asn: ::std::result::Result<u32, ::std::string::String>,
            remote_asn: ::std::result::Result<u32, ::std::string::String>,
            state: ::std::result::Result<super::BgpPeerState, ::std::string::String>,
            state_duration_millis: ::std::result::Result<u64, ::std::string::String>,
            switch: ::std::result::Result<super::SwitchLocation, ::std::string::String>,
        }

        impl ::std::default::Default for BgpPeerStatus {
            fn default() -> Self {
                Self {
                    addr: Err("no value supplied for addr".to_string()),
                    local_asn: Err("no value supplied for local_asn".to_string()),
                    remote_asn: Err("no value supplied for remote_asn".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    state_duration_millis: Err(
                        "no value supplied for state_duration_millis".to_string()
                    ),
                    switch: Err("no value supplied for switch".to_string()),
                }
            }
        }

        impl BgpPeerStatus {
            pub fn addr<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.addr = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addr: {}", e));
                self
            }
            pub fn local_asn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.local_asn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for local_asn: {}", e));
                self
            }
            pub fn remote_asn<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.remote_asn = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for remote_asn: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BgpPeerState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn state_duration_millis<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.state_duration_millis = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for state_duration_millis: {}",
                        e
                    )
                });
                self
            }
            pub fn switch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchLocation>,
                T::Error: ::std::fmt::Display,
            {
                self.switch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for switch: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<BgpPeerStatus> for super::BgpPeerStatus {
            type Error = super::error::ConversionError;
            fn try_from(
                value: BgpPeerStatus,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addr: value.addr?,
                    local_asn: value.local_asn?,
                    remote_asn: value.remote_asn?,
                    state: value.state?,
                    state_duration_millis: value.state_duration_millis?,
                    switch: value.switch?,
                })
            }
        }

        impl ::std::convert::From<super::BgpPeerStatus> for BgpPeerStatus {
            fn from(value: super::BgpPeerStatus) -> Self {
                Self {
                    addr: Ok(value.addr),
                    local_asn: Ok(value.local_asn),
                    remote_asn: Ok(value.remote_asn),
                    state: Ok(value.state),
                    state_duration_millis: Ok(value.state_duration_millis),
                    switch: Ok(value.switch),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Bindouble {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangedouble, ::std::string::String>,
        }

        impl ::std::default::Default for Bindouble {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Bindouble {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangedouble>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Bindouble> for super::Bindouble {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Bindouble,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Bindouble> for Bindouble {
            fn from(value: super::Bindouble) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binfloat {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangefloat, ::std::string::String>,
        }

        impl ::std::default::Default for Binfloat {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binfloat {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangefloat>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binfloat> for super::Binfloat {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binfloat,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binfloat> for Binfloat {
            fn from(value: super::Binfloat) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binint16 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeint16, ::std::string::String>,
        }

        impl ::std::default::Default for Binint16 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binint16 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeint16>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binint16> for super::Binint16 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binint16,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binint16> for Binint16 {
            fn from(value: super::Binint16) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binint32 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeint32, ::std::string::String>,
        }

        impl ::std::default::Default for Binint32 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binint32 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeint32>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binint32> for super::Binint32 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binint32,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binint32> for Binint32 {
            fn from(value: super::Binint32) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binint64 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeint64, ::std::string::String>,
        }

        impl ::std::default::Default for Binint64 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binint64 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeint64>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binint64> for super::Binint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binint64> for Binint64 {
            fn from(value: super::Binint64) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binint8 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeint8, ::std::string::String>,
        }

        impl ::std::default::Default for Binint8 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binint8 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeint8>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binint8> for super::Binint8 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binint8,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binint8> for Binint8 {
            fn from(value: super::Binint8) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binuint16 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeuint16, ::std::string::String>,
        }

        impl ::std::default::Default for Binuint16 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binuint16 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeuint16>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binuint16> for super::Binuint16 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binuint16,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binuint16> for Binuint16 {
            fn from(value: super::Binuint16) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binuint32 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeuint32, ::std::string::String>,
        }

        impl ::std::default::Default for Binuint32 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binuint32 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeuint32>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binuint32> for super::Binuint32 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binuint32,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binuint32> for Binuint32 {
            fn from(value: super::Binuint32) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binuint64 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeuint64, ::std::string::String>,
        }

        impl ::std::default::Default for Binuint64 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binuint64 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeuint64>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binuint64> for super::Binuint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binuint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binuint64> for Binuint64 {
            fn from(value: super::Binuint64) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Binuint8 {
            count: ::std::result::Result<u64, ::std::string::String>,
            range: ::std::result::Result<super::BinRangeuint8, ::std::string::String>,
        }

        impl ::std::default::Default for Binuint8 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binuint8 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::BinRangeuint8>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Binuint8> for super::Binuint8 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Binuint8,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        impl ::std::convert::From<super::Binuint8> for Binuint8 {
            fn from(value: super::Binuint8) -> Self {
                Self {
                    count: Ok(value.count),
                    range: Ok(value.range),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Certificate {
            cert: ::std::result::Result<::std::string::String, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            service: ::std::result::Result<super::ServiceUsingCertificate, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Certificate {
            fn default() -> Self {
                Self {
                    cert: Err("no value supplied for cert".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    service: Err("no value supplied for service".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Certificate {
            pub fn cert<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cert: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn service<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ServiceUsingCertificate>,
                T::Error: ::std::fmt::Display,
            {
                self.service = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Certificate> for super::Certificate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Certificate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cert: value.cert?,
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    service: value.service?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Certificate> for Certificate {
            fn from(value: super::Certificate) -> Self {
                Self {
                    cert: Ok(value.cert),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    service: Ok(value.service),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct CertificateCreate {
            cert: ::std::result::Result<::std::string::String, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            service: ::std::result::Result<super::ServiceUsingCertificate, ::std::string::String>,
        }

        impl ::std::default::Default for CertificateCreate {
            fn default() -> Self {
                Self {
                    cert: Err("no value supplied for cert".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    service: Err("no value supplied for service".to_string()),
                }
            }
        }

        impl CertificateCreate {
            pub fn cert<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cert: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn service<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ServiceUsingCertificate>,
                T::Error: ::std::fmt::Display,
            {
                self.service = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<CertificateCreate> for super::CertificateCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CertificateCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cert: value.cert?,
                    description: value.description?,
                    key: value.key?,
                    name: value.name?,
                    service: value.service?,
                })
            }
        }

        impl ::std::convert::From<super::CertificateCreate> for CertificateCreate {
            fn from(value: super::CertificateCreate) -> Self {
                Self {
                    cert: Ok(value.cert),
                    description: Ok(value.description),
                    key: Ok(value.key),
                    name: Ok(value.name),
                    service: Ok(value.service),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct CertificateResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::Certificate>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for CertificateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl CertificateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Certificate>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<CertificateResultsPage> for super::CertificateResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CertificateResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::CertificateResultsPage> for CertificateResultsPage {
            fn from(value: super::CertificateResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Cumulativedouble {
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            value: ::std::result::Result<f64, ::std::string::String>,
        }

        impl ::std::default::Default for Cumulativedouble {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativedouble {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Cumulativedouble> for super::Cumulativedouble {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Cumulativedouble,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        impl ::std::convert::From<super::Cumulativedouble> for Cumulativedouble {
            fn from(value: super::Cumulativedouble) -> Self {
                Self {
                    start_time: Ok(value.start_time),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Cumulativefloat {
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            value: ::std::result::Result<f32, ::std::string::String>,
        }

        impl ::std::default::Default for Cumulativefloat {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativefloat {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f32>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Cumulativefloat> for super::Cumulativefloat {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Cumulativefloat,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        impl ::std::convert::From<super::Cumulativefloat> for Cumulativefloat {
            fn from(value: super::Cumulativefloat) -> Self {
                Self {
                    start_time: Ok(value.start_time),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Cumulativeint64 {
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            value: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Cumulativeint64 {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativeint64 {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Cumulativeint64> for super::Cumulativeint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Cumulativeint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        impl ::std::convert::From<super::Cumulativeint64> for Cumulativeint64 {
            fn from(value: super::Cumulativeint64) -> Self {
                Self {
                    start_time: Ok(value.start_time),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Cumulativeuint64 {
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            value: ::std::result::Result<u64, ::std::string::String>,
        }

        impl ::std::default::Default for Cumulativeuint64 {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativeuint64 {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Cumulativeuint64> for super::Cumulativeuint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Cumulativeuint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        impl ::std::convert::From<super::Cumulativeuint64> for Cumulativeuint64 {
            fn from(value: super::Cumulativeuint64) -> Self {
                Self {
                    start_time: Ok(value.start_time),
                    value: Ok(value.value),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct CurrentUser {
            display_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            silo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            silo_name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for CurrentUser {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                    silo_name: Err("no value supplied for silo_name".to_string()),
                }
            }
        }

        impl CurrentUser {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
            pub fn silo_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<CurrentUser> for super::CurrentUser {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CurrentUser,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                    silo_name: value.silo_name?,
                })
            }
        }

        impl ::std::convert::From<super::CurrentUser> for CurrentUser {
            fn from(value: super::CurrentUser) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    id: Ok(value.id),
                    silo_id: Ok(value.silo_id),
                    silo_name: Ok(value.silo_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DerEncodedKeyPair {
            private_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            public_cert: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for DerEncodedKeyPair {
            fn default() -> Self {
                Self {
                    private_key: Err("no value supplied for private_key".to_string()),
                    public_cert: Err("no value supplied for public_cert".to_string()),
                }
            }
        }

        impl DerEncodedKeyPair {
            pub fn private_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.private_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for private_key: {}", e));
                self
            }
            pub fn public_cert<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_cert: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DerEncodedKeyPair> for super::DerEncodedKeyPair {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DerEncodedKeyPair,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    private_key: value.private_key?,
                    public_cert: value.public_cert?,
                })
            }
        }

        impl ::std::convert::From<super::DerEncodedKeyPair> for DerEncodedKeyPair {
            fn from(value: super::DerEncodedKeyPair) -> Self {
                Self {
                    private_key: Ok(value.private_key),
                    public_cert: Ok(value.public_cert),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DeviceAccessTokenRequest {
            client_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            device_code: ::std::result::Result<::std::string::String, ::std::string::String>,
            grant_type: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for DeviceAccessTokenRequest {
            fn default() -> Self {
                Self {
                    client_id: Err("no value supplied for client_id".to_string()),
                    device_code: Err("no value supplied for device_code".to_string()),
                    grant_type: Err("no value supplied for grant_type".to_string()),
                }
            }
        }

        impl DeviceAccessTokenRequest {
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {}", e));
                self
            }
            pub fn device_code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.device_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_code: {}", e));
                self
            }
            pub fn grant_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.grant_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for grant_type: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DeviceAccessTokenRequest> for super::DeviceAccessTokenRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeviceAccessTokenRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    client_id: value.client_id?,
                    device_code: value.device_code?,
                    grant_type: value.grant_type?,
                })
            }
        }

        impl ::std::convert::From<super::DeviceAccessTokenRequest> for DeviceAccessTokenRequest {
            fn from(value: super::DeviceAccessTokenRequest) -> Self {
                Self {
                    client_id: Ok(value.client_id),
                    device_code: Ok(value.device_code),
                    grant_type: Ok(value.grant_type),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DeviceAuthRequest {
            client_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for DeviceAuthRequest {
            fn default() -> Self {
                Self {
                    client_id: Err("no value supplied for client_id".to_string()),
                }
            }
        }

        impl DeviceAuthRequest {
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DeviceAuthRequest> for super::DeviceAuthRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeviceAuthRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    client_id: value.client_id?,
                })
            }
        }

        impl ::std::convert::From<super::DeviceAuthRequest> for DeviceAuthRequest {
            fn from(value: super::DeviceAuthRequest) -> Self {
                Self {
                    client_id: Ok(value.client_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DeviceAuthVerify {
            user_code: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for DeviceAuthVerify {
            fn default() -> Self {
                Self {
                    user_code: Err("no value supplied for user_code".to_string()),
                }
            }
        }

        impl DeviceAuthVerify {
            pub fn user_code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_code: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DeviceAuthVerify> for super::DeviceAuthVerify {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DeviceAuthVerify,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    user_code: value.user_code?,
                })
            }
        }

        impl ::std::convert::From<super::DeviceAuthVerify> for DeviceAuthVerify {
            fn from(value: super::DeviceAuthVerify) -> Self {
                Self {
                    user_code: Ok(value.user_code),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Disk {
            block_size: ::std::result::Result<super::ByteCount, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            device_path: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            image_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            size: ::std::result::Result<super::ByteCount, ::std::string::String>,
            snapshot_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            state: ::std::result::Result<super::DiskState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Disk {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    device_path: Err("no value supplied for device_path".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    image_id: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    snapshot_id: Ok(Default::default()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Disk {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn device_path<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.device_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_path: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn image_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.image_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for image_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn snapshot_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.snapshot_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for snapshot_id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DiskState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Disk> for super::Disk {
            type Error = super::error::ConversionError;
            fn try_from(value: Disk) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    device_path: value.device_path?,
                    id: value.id?,
                    image_id: value.image_id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    snapshot_id: value.snapshot_id?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Disk> for Disk {
            fn from(value: super::Disk) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    device_path: Ok(value.device_path),
                    id: Ok(value.id),
                    image_id: Ok(value.image_id),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    size: Ok(value.size),
                    snapshot_id: Ok(value.snapshot_id),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            disk_source: ::std::result::Result<super::DiskSource, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            size: ::std::result::Result<super::ByteCount, ::std::string::String>,
        }

        impl ::std::default::Default for DiskCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk_source: Err("no value supplied for disk_source".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }

        impl DiskCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DiskSource>,
                T::Error: ::std::fmt::Display,
            {
                self.disk_source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_source: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DiskCreate> for super::DiskCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DiskCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disk_source: value.disk_source?,
                    name: value.name?,
                    size: value.size?,
                })
            }
        }

        impl ::std::convert::From<super::DiskCreate> for DiskCreate {
            fn from(value: super::DiskCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    disk_source: Ok(value.disk_source),
                    name: Ok(value.name),
                    size: Ok(value.size),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskPath {
            disk: ::std::result::Result<super::NameOrId, ::std::string::String>,
        }

        impl ::std::default::Default for DiskPath {
            fn default() -> Self {
                Self {
                    disk: Err("no value supplied for disk".to_string()),
                }
            }
        }

        impl DiskPath {
            pub fn disk<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DiskPath> for super::DiskPath {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DiskPath,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { disk: value.disk? })
            }
        }

        impl ::std::convert::From<super::DiskPath> for DiskPath {
            fn from(value: super::DiskPath) -> Self {
                Self {
                    disk: Ok(value.disk),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct DiskResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Disk>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for DiskResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl DiskResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Disk>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<DiskResultsPage> for super::DiskResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DiskResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::DiskResultsPage> for DiskResultsPage {
            fn from(value: super::DiskResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Distributiondouble {
            bins: ::std::result::Result<::std::vec::Vec<f64>, ::std::string::String>,
            counts: ::std::result::Result<::std::vec::Vec<u64>, ::std::string::String>,
            max: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            min: ::std::result::Result<::std::option::Option<f64>, ::std::string::String>,
            p50: ::std::result::Result<
                ::std::option::Option<super::Quantile>,
                ::std::string::String,
            >,
            p90: ::std::result::Result<
                ::std::option::Option<super::Quantile>,
                ::std::string::String,
            >,
            p99: ::std::result::Result<
                ::std::option::Option<super::Quantile>,
                ::std::string::String,
            >,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            sum_of_samples: ::std::result::Result<f64, ::std::string::String>,
        }

        impl ::std::default::Default for Distributiondouble {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    counts: Err("no value supplied for counts".to_string()),
                    max: Ok(Default::default()),
                    min: Ok(Default::default()),
                    p50: Ok(Default::default()),
                    p90: Ok(Default::default()),
                    p99: Ok(Default::default()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Distributiondouble {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn counts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.counts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for counts: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<f64>>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Quantile>>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Quantile>>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Quantile>>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Distributiondouble> for super::Distributiondouble {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Distributiondouble,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    counts: value.counts?,
                    max: value.max?,
                    min: value.min?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Distributiondouble> for Distributiondouble {
            fn from(value: super::Distributiondouble) -> Self {
                Self {
                    bins: Ok(value.bins),
                    counts: Ok(value.counts),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Distributionint64 {
            bins: ::std::result::Result<::std::vec::Vec<i64>, ::std::string::String>,
            counts: ::std::result::Result<::std::vec::Vec<u64>, ::std::string::String>,
            max: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            min: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            p50: ::std::result::Result<
                ::std::option::Option<super::Quantile>,
                ::std::string::String,
            >,
            p90: ::std::result::Result<
                ::std::option::Option<super::Quantile>,
                ::std::string::String,
            >,
            p99: ::std::result::Result<
                ::std::option::Option<super::Quantile>,
                ::std::string::String,
            >,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Distributionint64 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    counts: Err("no value supplied for counts".to_string()),
                    max: Ok(Default::default()),
                    min: Ok(Default::default()),
                    p50: Ok(Default::default()),
                    p90: Ok(Default::default()),
                    p99: Ok(Default::default()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Distributionint64 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn counts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u64>>,
                T::Error: ::std::fmt::Display,
            {
                self.counts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for counts: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Quantile>>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Quantile>>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Quantile>>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Distributionint64> for super::Distributionint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Distributionint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    counts: value.counts?,
                    max: value.max?,
                    min: value.min?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Distributionint64> for Distributionint64 {
            fn from(value: super::Distributionint64) -> Self {
                Self {
                    bins: Ok(value.bins),
                    counts: Ok(value.counts),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct EphemeralIpCreate {
            pool: ::std::result::Result<
                ::std::option::Option<super::NameOrId>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for EphemeralIpCreate {
            fn default() -> Self {
                Self {
                    pool: Ok(Default::default()),
                }
            }
        }

        impl EphemeralIpCreate {
            pub fn pool<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.pool = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pool: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<EphemeralIpCreate> for super::EphemeralIpCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EphemeralIpCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { pool: value.pool? })
            }
        }

        impl ::std::convert::From<super::EphemeralIpCreate> for EphemeralIpCreate {
            fn from(value: super::EphemeralIpCreate) -> Self {
                Self {
                    pool: Ok(value.pool),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Error {
            error_code: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
            request_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for Error {
            fn default() -> Self {
                Self {
                    error_code: Ok(Default::default()),
                    message: Err("no value supplied for message".to_string()),
                    request_id: Err("no value supplied for request_id".to_string()),
                }
            }
        }

        impl Error {
            pub fn error_code<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.error_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
            pub fn request_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.request_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for request_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Error> for super::Error {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Error,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error_code: value.error_code?,
                    message: value.message?,
                    request_id: value.request_id?,
                })
            }
        }

        impl ::std::convert::From<super::Error> for Error {
            fn from(value: super::Error) -> Self {
                Self {
                    error_code: Ok(value.error_code),
                    message: Ok(value.message),
                    request_id: Ok(value.request_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct EventClass {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for EventClass {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl EventClass {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<EventClass> for super::EventClass {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EventClass,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::EventClass> for EventClass {
            fn from(value: super::EventClass) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct EventClassResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::EventClass>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for EventClassResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl EventClassResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::EventClass>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<EventClassResultsPage> for super::EventClassResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: EventClassResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::EventClassResultsPage> for EventClassResultsPage {
            fn from(value: super::EventClassResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ExternalIpResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::ExternalIp>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for ExternalIpResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ExternalIpResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ExternalIp>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ExternalIpResultsPage> for super::ExternalIpResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ExternalIpResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::ExternalIpResultsPage> for ExternalIpResultsPage {
            fn from(value: super::ExternalIpResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FieldSchema {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            field_type: ::std::result::Result<super::FieldType, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            source: ::std::result::Result<super::FieldSource, ::std::string::String>,
        }

        impl ::std::default::Default for FieldSchema {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    field_type: Err("no value supplied for field_type".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                }
            }
        }

        impl FieldSchema {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn field_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FieldType>,
                T::Error: ::std::fmt::Display,
            {
                self.field_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for field_type: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FieldSource>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<FieldSchema> for super::FieldSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FieldSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    field_type: value.field_type?,
                    name: value.name?,
                    source: value.source?,
                })
            }
        }

        impl ::std::convert::From<super::FieldSchema> for FieldSchema {
            fn from(value: super::FieldSchema) -> Self {
                Self {
                    description: Ok(value.description),
                    field_type: Ok(value.field_type),
                    name: Ok(value.name),
                    source: Ok(value.source),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FinalizeDisk {
            snapshot_name:
                ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for FinalizeDisk {
            fn default() -> Self {
                Self {
                    snapshot_name: Ok(Default::default()),
                }
            }
        }

        impl FinalizeDisk {
            pub fn snapshot_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.snapshot_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for snapshot_name: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<FinalizeDisk> for super::FinalizeDisk {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FinalizeDisk,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    snapshot_name: value.snapshot_name?,
                })
            }
        }

        impl ::std::convert::From<super::FinalizeDisk> for FinalizeDisk {
            fn from(value: super::FinalizeDisk) -> Self {
                Self {
                    snapshot_name: Ok(value.snapshot_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FleetRolePolicy {
            role_assignments: ::std::result::Result<
                ::std::vec::Vec<super::FleetRoleRoleAssignment>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for FleetRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl FleetRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FleetRoleRoleAssignment>>,
                T::Error: ::std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<FleetRolePolicy> for super::FleetRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FleetRolePolicy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl ::std::convert::From<super::FleetRolePolicy> for FleetRolePolicy {
            fn from(value: super::FleetRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FleetRoleRoleAssignment {
            identity_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            identity_type: ::std::result::Result<super::IdentityType, ::std::string::String>,
            role_name: ::std::result::Result<super::FleetRole, ::std::string::String>,
        }

        impl ::std::default::Default for FleetRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl FleetRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IdentityType>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FleetRole>,
                T::Error: ::std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<FleetRoleRoleAssignment> for super::FleetRoleRoleAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FleetRoleRoleAssignment,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl ::std::convert::From<super::FleetRoleRoleAssignment> for FleetRoleRoleAssignment {
            fn from(value: super::FleetRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FloatingIp {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            instance_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            ip: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            ip_pool_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for FloatingIp {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    instance_id: Ok(Default::default()),
                    ip: Err("no value supplied for ip".to_string()),
                    ip_pool_id: Err("no value supplied for ip_pool_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl FloatingIp {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn instance_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.instance_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for instance_id: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn ip_pool_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.ip_pool_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip_pool_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<FloatingIp> for super::FloatingIp {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FloatingIp,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    instance_id: value.instance_id?,
                    ip: value.ip?,
                    ip_pool_id: value.ip_pool_id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::FloatingIp> for FloatingIp {
            fn from(value: super::FloatingIp) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    instance_id: Ok(value.instance_id),
                    ip: Ok(value.ip),
                    ip_pool_id: Ok(value.ip_pool_id),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FloatingIpAttach {
            kind: ::std::result::Result<super::FloatingIpParentKind, ::std::string::String>,
            parent: ::std::result::Result<super::NameOrId, ::std::string::String>,
        }

        impl ::std::default::Default for FloatingIpAttach {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    parent: Err("no value supplied for parent".to_string()),
                }
            }
        }

        impl FloatingIpAttach {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::FloatingIpParentKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn parent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.parent = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for parent: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<FloatingIpAttach> for super::FloatingIpAttach {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FloatingIpAttach,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    parent: value.parent?,
                })
            }
        }

        impl ::std::convert::From<super::FloatingIpAttach> for FloatingIpAttach {
            fn from(value: super::FloatingIpAttach) -> Self {
                Self {
                    kind: Ok(value.kind),
                    parent: Ok(value.parent),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FloatingIpCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            ip: ::std::result::Result<
                ::std::option::Option<::std::net::IpAddr>,
                ::std::string::String,
            >,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            pool: ::std::result::Result<
                ::std::option::Option<super::NameOrId>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for FloatingIpCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ip: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    pool: Ok(Default::default()),
                }
            }
        }

        impl FloatingIpCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::net::IpAddr>>,
                T::Error: ::std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn pool<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.pool = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pool: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<FloatingIpCreate> for super::FloatingIpCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FloatingIpCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    ip: value.ip?,
                    name: value.name?,
                    pool: value.pool?,
                })
            }
        }

        impl ::std::convert::From<super::FloatingIpCreate> for FloatingIpCreate {
            fn from(value: super::FloatingIpCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    ip: Ok(value.ip),
                    name: Ok(value.name),
                    pool: Ok(value.pool),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FloatingIpResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::FloatingIp>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for FloatingIpResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl FloatingIpResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::FloatingIp>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<FloatingIpResultsPage> for super::FloatingIpResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FloatingIpResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::FloatingIpResultsPage> for FloatingIpResultsPage {
            fn from(value: super::FloatingIpResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct FloatingIpUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for FloatingIpUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl FloatingIpUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<FloatingIpUpdate> for super::FloatingIpUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: FloatingIpUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::FloatingIpUpdate> for FloatingIpUpdate {
            fn from(value: super::FloatingIpUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Group {
            display_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            silo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for Group {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl Group {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Group> for super::Group {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Group,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                })
            }
        }

        impl ::std::convert::From<super::Group> for Group {
            fn from(value: super::Group) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    id: Ok(value.id),
                    silo_id: Ok(value.silo_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct GroupResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Group>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for GroupResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl GroupResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Group>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<GroupResultsPage> for super::GroupResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: GroupResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::GroupResultsPage> for GroupResultsPage {
            fn from(value: super::GroupResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramdouble {
            bins: ::std::result::Result<::std::vec::Vec<super::Bindouble>, ::std::string::String>,
            max: ::std::result::Result<f64, ::std::string::String>,
            min: ::std::result::Result<f64, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<f64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramdouble {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramdouble {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Bindouble>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramdouble> for super::Histogramdouble {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramdouble,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramdouble> for Histogramdouble {
            fn from(value: super::Histogramdouble) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramfloat {
            bins: ::std::result::Result<::std::vec::Vec<super::Binfloat>, ::std::string::String>,
            max: ::std::result::Result<f32, ::std::string::String>,
            min: ::std::result::Result<f32, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<f64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramfloat {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramfloat {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binfloat>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f32>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f32>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramfloat> for super::Histogramfloat {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramfloat,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramfloat> for Histogramfloat {
            fn from(value: super::Histogramfloat) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramint16 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binint16>, ::std::string::String>,
            max: ::std::result::Result<i16, ::std::string::String>,
            min: ::std::result::Result<i16, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramint16 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramint16 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binint16>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i16>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i16>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramint16> for super::Histogramint16 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramint16,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramint16> for Histogramint16 {
            fn from(value: super::Histogramint16) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramint32 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binint32>, ::std::string::String>,
            max: ::std::result::Result<i32, ::std::string::String>,
            min: ::std::result::Result<i32, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramint32 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramint32 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binint32>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i32>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramint32> for super::Histogramint32 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramint32,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramint32> for Histogramint32 {
            fn from(value: super::Histogramint32) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramint64 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binint64>, ::std::string::String>,
            max: ::std::result::Result<i64, ::std::string::String>,
            min: ::std::result::Result<i64, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramint64 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramint64 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binint64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramint64> for super::Histogramint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramint64> for Histogramint64 {
            fn from(value: super::Histogramint64) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramint8 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binint8>, ::std::string::String>,
            max: ::std::result::Result<i8, ::std::string::String>,
            min: ::std::result::Result<i8, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramint8 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramint8 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binint8>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i8>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i8>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramint8> for super::Histogramint8 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramint8,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramint8> for Histogramint8 {
            fn from(value: super::Histogramint8) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramuint16 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binuint16>, ::std::string::String>,
            max: ::std::result::Result<u16, ::std::string::String>,
            min: ::std::result::Result<u16, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramuint16 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramuint16 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binuint16>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramuint16> for super::Histogramuint16 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramuint16,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramuint16> for Histogramuint16 {
            fn from(value: super::Histogramuint16) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramuint32 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binuint32>, ::std::string::String>,
            max: ::std::result::Result<u32, ::std::string::String>,
            min: ::std::result::Result<u32, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramuint32 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramuint32 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binuint32>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramuint32> for super::Histogramuint32 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramuint32,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramuint32> for Histogramuint32 {
            fn from(value: super::Histogramuint32) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramuint64 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binuint64>, ::std::string::String>,
            max: ::std::result::Result<u64, ::std::string::String>,
            min: ::std::result::Result<u64, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramuint64 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramuint64 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binuint64>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramuint64> for super::Histogramuint64 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramuint64,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramuint64> for Histogramuint64 {
            fn from(value: super::Histogramuint64) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Histogramuint8 {
            bins: ::std::result::Result<::std::vec::Vec<super::Binuint8>, ::std::string::String>,
            max: ::std::result::Result<u8, ::std::string::String>,
            min: ::std::result::Result<u8, ::std::string::String>,
            n_samples: ::std::result::Result<u64, ::std::string::String>,
            p50: ::std::result::Result<super::Quantile, ::std::string::String>,
            p90: ::std::result::Result<super::Quantile, ::std::string::String>,
            p99: ::std::result::Result<super::Quantile, ::std::string::String>,
            squared_mean: ::std::result::Result<f64, ::std::string::String>,
            start_time: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            sum_of_samples: ::std::result::Result<i64, ::std::string::String>,
        }

        impl ::std::default::Default for Histogramuint8 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    max: Err("no value supplied for max".to_string()),
                    min: Err("no value supplied for min".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    p50: Err("no value supplied for p50".to_string()),
                    p90: Err("no value supplied for p90".to_string()),
                    p99: Err("no value supplied for p99".to_string()),
                    squared_mean: Err("no value supplied for squared_mean".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                    sum_of_samples: Err("no value supplied for sum_of_samples".to_string()),
                }
            }
        }

        impl Histogramuint8 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Binuint8>>,
                T::Error: ::std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn max<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.max = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for max: {}", e));
                self
            }
            pub fn min<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.min = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for min: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn p50<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p50 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p50: {}", e));
                self
            }
            pub fn p90<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p90 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p90: {}", e));
                self
            }
            pub fn p99<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Quantile>,
                T::Error: ::std::fmt::Display,
            {
                self.p99 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p99: {}", e));
                self
            }
            pub fn squared_mean<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.squared_mean = value.try_into().map_err(|e| {
                    format!("error converting supplied value for squared_mean: {}", e)
                });
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn sum_of_samples<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.sum_of_samples = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sum_of_samples: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Histogramuint8> for super::Histogramuint8 {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Histogramuint8,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    bins: value.bins?,
                    max: value.max?,
                    min: value.min?,
                    n_samples: value.n_samples?,
                    p50: value.p50?,
                    p90: value.p90?,
                    p99: value.p99?,
                    squared_mean: value.squared_mean?,
                    start_time: value.start_time?,
                    sum_of_samples: value.sum_of_samples?,
                })
            }
        }

        impl ::std::convert::From<super::Histogramuint8> for Histogramuint8 {
            fn from(value: super::Histogramuint8) -> Self {
                Self {
                    bins: Ok(value.bins),
                    max: Ok(value.max),
                    min: Ok(value.min),
                    n_samples: Ok(value.n_samples),
                    p50: Ok(value.p50),
                    p90: Ok(value.p90),
                    p99: Ok(value.p99),
                    squared_mean: Ok(value.squared_mean),
                    start_time: Ok(value.start_time),
                    sum_of_samples: Ok(value.sum_of_samples),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IdentityProvider {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            provider_type:
                ::std::result::Result<super::IdentityProviderType, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IdentityProvider {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    provider_type: Err("no value supplied for provider_type".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl IdentityProvider {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn provider_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IdentityProviderType>,
                T::Error: ::std::fmt::Display,
            {
                self.provider_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for provider_type: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<IdentityProvider> for super::IdentityProvider {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdentityProvider,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    provider_type: value.provider_type?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::IdentityProvider> for IdentityProvider {
            fn from(value: super::IdentityProvider) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    provider_type: Ok(value.provider_type),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IdentityProviderResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::IdentityProvider>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IdentityProviderResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IdentityProviderResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IdentityProvider>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IdentityProviderResultsPage> for super::IdentityProviderResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IdentityProviderResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::IdentityProviderResultsPage> for IdentityProviderResultsPage {
            fn from(value: super::IdentityProviderResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Image {
            block_size: ::std::result::Result<super::ByteCount, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            digest:
                ::std::result::Result<::std::option::Option<super::Digest>, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            os: ::std::result::Result<::std::string::String, ::std::string::String>,
            project_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            size: ::std::result::Result<super::ByteCount, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for Image {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    digest: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    os: Err("no value supplied for os".to_string()),
                    project_id: Ok(Default::default()),
                    size: Err("no value supplied for size".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl Image {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn digest<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Digest>>,
                T::Error: ::std::fmt::Display,
            {
                self.digest = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for digest: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn os<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.os = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for os: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Image> for super::Image {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Image,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    digest: value.digest?,
                    id: value.id?,
                    name: value.name?,
                    os: value.os?,
                    project_id: value.project_id?,
                    size: value.size?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        impl ::std::convert::From<super::Image> for Image {
            fn from(value: super::Image) -> Self {
                Self {
                    block_size: Ok(value.block_size),
                    description: Ok(value.description),
                    digest: Ok(value.digest),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    os: Ok(value.os),
                    project_id: Ok(value.project_id),
                    size: Ok(value.size),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ImageCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            os: ::std::result::Result<::std::string::String, ::std::string::String>,
            source: ::std::result::Result<super::ImageSource, ::std::string::String>,
            version: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for ImageCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    os: Err("no value supplied for os".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl ImageCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn os<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.os = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for os: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ImageSource>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ImageCreate> for super::ImageCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ImageCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    os: value.os?,
                    source: value.source?,
                    version: value.version?,
                })
            }
        }

        impl ::std::convert::From<super::ImageCreate> for ImageCreate {
            fn from(value: super::ImageCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                    os: Ok(value.os),
                    source: Ok(value.source),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ImageResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Image>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for ImageResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ImageResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Image>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ImageResultsPage> for super::ImageResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ImageResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::ImageResultsPage> for ImageResultsPage {
            fn from(value: super::ImageResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ImportBlocksBulkWrite {
            base64_encoded_data:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            offset: ::std::result::Result<u64, ::std::string::String>,
        }

        impl ::std::default::Default for ImportBlocksBulkWrite {
            fn default() -> Self {
                Self {
                    base64_encoded_data: Err(
                        "no value supplied for base64_encoded_data".to_string()
                    ),
                    offset: Err("no value supplied for offset".to_string()),
                }
            }
        }

        impl ImportBlocksBulkWrite {
            pub fn base64_encoded_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.base64_encoded_data = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for base64_encoded_data: {}",
                        e
                    )
                });
                self
            }
            pub fn offset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.offset = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for offset: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ImportBlocksBulkWrite> for super::ImportBlocksBulkWrite {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ImportBlocksBulkWrite,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    base64_encoded_data: value.base64_encoded_data?,
                    offset: value.offset?,
                })
            }
        }

        impl ::std::convert::From<super::ImportBlocksBulkWrite> for ImportBlocksBulkWrite {
            fn from(value: super::ImportBlocksBulkWrite) -> Self {
                Self {
                    base64_encoded_data: Ok(value.base64_encoded_data),
                    offset: Ok(value.offset),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Instance {
            auto_restart_cooldown_expiration: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            auto_restart_enabled: ::std::result::Result<bool, ::std::string::String>,
            auto_restart_policy: ::std::result::Result<
                ::std::option::Option<super::InstanceAutoRestartPolicy>,
                ::std::string::String,
            >,
            boot_disk_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            hostname: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            memory: ::std::result::Result<super::ByteCount, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            ncpus: ::std::result::Result<super::InstanceCpuCount, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            run_state: ::std::result::Result<super::InstanceState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_last_auto_restarted: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_run_state_updated: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Instance {
            fn default() -> Self {
                Self {
                    auto_restart_cooldown_expiration: Ok(Default::default()),
                    auto_restart_enabled: Err(
                        "no value supplied for auto_restart_enabled".to_string()
                    ),
                    auto_restart_policy: Ok(Default::default()),
                    boot_disk_id: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    hostname: Err("no value supplied for hostname".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    run_state: Err("no value supplied for run_state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_last_auto_restarted: Ok(Default::default()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    time_run_state_updated: Err(
                        "no value supplied for time_run_state_updated".to_string()
                    ),
                }
            }
        }

        impl Instance {
            pub fn auto_restart_cooldown_expiration<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.auto_restart_cooldown_expiration = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for auto_restart_cooldown_expiration: {}",
                        e
                    )
                });
                self
            }
            pub fn auto_restart_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_restart_enabled = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for auto_restart_enabled: {}",
                        e
                    )
                });
                self
            }
            pub fn auto_restart_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::InstanceAutoRestartPolicy>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_restart_policy = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for auto_restart_policy: {}",
                        e
                    )
                });
                self
            }
            pub fn boot_disk_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.boot_disk_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for boot_disk_id: {}", e)
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn hostname<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.hostname = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hostname: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: ::std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn run_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InstanceState>,
                T::Error: ::std::fmt::Display,
            {
                self.run_state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for run_state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_last_auto_restarted<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.time_last_auto_restarted = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for time_last_auto_restarted: {}",
                        e
                    )
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn time_run_state_updated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_run_state_updated = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for time_run_state_updated: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Instance> for super::Instance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Instance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auto_restart_cooldown_expiration: value.auto_restart_cooldown_expiration?,
                    auto_restart_enabled: value.auto_restart_enabled?,
                    auto_restart_policy: value.auto_restart_policy?,
                    boot_disk_id: value.boot_disk_id?,
                    description: value.description?,
                    hostname: value.hostname?,
                    id: value.id?,
                    memory: value.memory?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    project_id: value.project_id?,
                    run_state: value.run_state?,
                    time_created: value.time_created?,
                    time_last_auto_restarted: value.time_last_auto_restarted?,
                    time_modified: value.time_modified?,
                    time_run_state_updated: value.time_run_state_updated?,
                })
            }
        }

        impl ::std::convert::From<super::Instance> for Instance {
            fn from(value: super::Instance) -> Self {
                Self {
                    auto_restart_cooldown_expiration: Ok(value.auto_restart_cooldown_expiration),
                    auto_restart_enabled: Ok(value.auto_restart_enabled),
                    auto_restart_policy: Ok(value.auto_restart_policy),
                    boot_disk_id: Ok(value.boot_disk_id),
                    description: Ok(value.description),
                    hostname: Ok(value.hostname),
                    id: Ok(value.id),
                    memory: Ok(value.memory),
                    name: Ok(value.name),
                    ncpus: Ok(value.ncpus),
                    project_id: Ok(value.project_id),
                    run_state: Ok(value.run_state),
                    time_created: Ok(value.time_created),
                    time_last_auto_restarted: Ok(value.time_last_auto_restarted),
                    time_modified: Ok(value.time_modified),
                    time_run_state_updated: Ok(value.time_run_state_updated),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceCreate {
            anti_affinity_groups:
                ::std::result::Result<::std::vec::Vec<super::NameOrId>, ::std::string::String>,
            auto_restart_policy: ::std::result::Result<
                ::std::option::Option<super::InstanceAutoRestartPolicy>,
                ::std::string::String,
            >,
            boot_disk: ::std::result::Result<
                ::std::option::Option<super::InstanceDiskAttachment>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            disks: ::std::result::Result<
                ::std::vec::Vec<super::InstanceDiskAttachment>,
                ::std::string::String,
            >,
            external_ips: ::std::result::Result<
                ::std::vec::Vec<super::ExternalIpCreate>,
                ::std::string::String,
            >,
            hostname: ::std::result::Result<super::Hostname, ::std::string::String>,
            memory: ::std::result::Result<super::ByteCount, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            ncpus: ::std::result::Result<super::InstanceCpuCount, ::std::string::String>,
            network_interfaces: ::std::result::Result<
                super::InstanceNetworkInterfaceAttachment,
                ::std::string::String,
            >,
            ssh_public_keys: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::NameOrId>>,
                ::std::string::String,
            >,
            start: ::std::result::Result<bool, ::std::string::String>,
            user_data: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for InstanceCreate {
            fn default() -> Self {
                Self {
                    anti_affinity_groups: Ok(Default::default()),
                    auto_restart_policy: Ok(Default::default()),
                    boot_disk: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    disks: Ok(Default::default()),
                    external_ips: Ok(Default::default()),
                    hostname: Err("no value supplied for hostname".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    network_interfaces: Ok(super::defaults::instance_create_network_interfaces()),
                    ssh_public_keys: Ok(Default::default()),
                    start: Ok(super::defaults::default_bool::<true>()),
                    user_data: Ok(Default::default()),
                }
            }
        }

        impl InstanceCreate {
            pub fn anti_affinity_groups<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.anti_affinity_groups = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for anti_affinity_groups: {}",
                        e
                    )
                });
                self
            }
            pub fn auto_restart_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::InstanceAutoRestartPolicy>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_restart_policy = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for auto_restart_policy: {}",
                        e
                    )
                });
                self
            }
            pub fn boot_disk<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::InstanceDiskAttachment>>,
                T::Error: ::std::fmt::Display,
            {
                self.boot_disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for boot_disk: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disks<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::InstanceDiskAttachment>>,
                T::Error: ::std::fmt::Display,
            {
                self.disks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disks: {}", e));
                self
            }
            pub fn external_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ExternalIpCreate>>,
                T::Error: ::std::fmt::Display,
            {
                self.external_ips = value.try_into().map_err(|e| {
                    format!("error converting supplied value for external_ips: {}", e)
                });
                self
            }
            pub fn hostname<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Hostname>,
                T::Error: ::std::fmt::Display,
            {
                self.hostname = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hostname: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: ::std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn network_interfaces<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InstanceNetworkInterfaceAttachment>,
                T::Error: ::std::fmt::Display,
            {
                self.network_interfaces = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for network_interfaces: {}",
                        e
                    )
                });
                self
            }
            pub fn ssh_public_keys<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::vec::Vec<super::NameOrId>>>,
                T::Error: ::std::fmt::Display,
            {
                self.ssh_public_keys = value.try_into().map_err(|e| {
                    format!("error converting supplied value for ssh_public_keys: {}", e)
                });
                self
            }
            pub fn start<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.start = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start: {}", e));
                self
            }
            pub fn user_data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.user_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_data: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceCreate> for super::InstanceCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    anti_affinity_groups: value.anti_affinity_groups?,
                    auto_restart_policy: value.auto_restart_policy?,
                    boot_disk: value.boot_disk?,
                    description: value.description?,
                    disks: value.disks?,
                    external_ips: value.external_ips?,
                    hostname: value.hostname?,
                    memory: value.memory?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    network_interfaces: value.network_interfaces?,
                    ssh_public_keys: value.ssh_public_keys?,
                    start: value.start?,
                    user_data: value.user_data?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceCreate> for InstanceCreate {
            fn from(value: super::InstanceCreate) -> Self {
                Self {
                    anti_affinity_groups: Ok(value.anti_affinity_groups),
                    auto_restart_policy: Ok(value.auto_restart_policy),
                    boot_disk: Ok(value.boot_disk),
                    description: Ok(value.description),
                    disks: Ok(value.disks),
                    external_ips: Ok(value.external_ips),
                    hostname: Ok(value.hostname),
                    memory: Ok(value.memory),
                    name: Ok(value.name),
                    ncpus: Ok(value.ncpus),
                    network_interfaces: Ok(value.network_interfaces),
                    ssh_public_keys: Ok(value.ssh_public_keys),
                    start: Ok(value.start),
                    user_data: Ok(value.user_data),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceNetworkInterface {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            instance_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            ip: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            mac: ::std::result::Result<super::MacAddr, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            primary: ::std::result::Result<bool, ::std::string::String>,
            subnet_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            transit_ips:
                ::std::result::Result<::std::vec::Vec<super::IpNet>, ::std::string::String>,
            vpc_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for InstanceNetworkInterface {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    instance_id: Err("no value supplied for instance_id".to_string()),
                    ip: Err("no value supplied for ip".to_string()),
                    mac: Err("no value supplied for mac".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    primary: Err("no value supplied for primary".to_string()),
                    subnet_id: Err("no value supplied for subnet_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    transit_ips: Ok(Default::default()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl InstanceNetworkInterface {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn instance_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.instance_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for instance_id: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn mac<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MacAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.mac = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mac: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
            pub fn subnet_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.subnet_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn transit_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IpNet>>,
                T::Error: ::std::fmt::Display,
            {
                self.transit_ips = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transit_ips: {}", e));
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceNetworkInterface> for super::InstanceNetworkInterface {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceNetworkInterface,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    instance_id: value.instance_id?,
                    ip: value.ip?,
                    mac: value.mac?,
                    name: value.name?,
                    primary: value.primary?,
                    subnet_id: value.subnet_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    transit_ips: value.transit_ips?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceNetworkInterface> for InstanceNetworkInterface {
            fn from(value: super::InstanceNetworkInterface) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    instance_id: Ok(value.instance_id),
                    ip: Ok(value.ip),
                    mac: Ok(value.mac),
                    name: Ok(value.name),
                    primary: Ok(value.primary),
                    subnet_id: Ok(value.subnet_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    transit_ips: Ok(value.transit_ips),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceNetworkInterfaceCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            ip: ::std::result::Result<
                ::std::option::Option<::std::net::IpAddr>,
                ::std::string::String,
            >,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            subnet_name: ::std::result::Result<super::Name, ::std::string::String>,
            vpc_name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for InstanceNetworkInterfaceCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ip: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    subnet_name: Err("no value supplied for subnet_name".to_string()),
                    vpc_name: Err("no value supplied for vpc_name".to_string()),
                }
            }
        }

        impl InstanceNetworkInterfaceCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::net::IpAddr>>,
                T::Error: ::std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subnet_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.subnet_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet_name: {}", e));
                self
            }
            pub fn vpc_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceNetworkInterfaceCreate>
            for super::InstanceNetworkInterfaceCreate
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceNetworkInterfaceCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    ip: value.ip?,
                    name: value.name?,
                    subnet_name: value.subnet_name?,
                    vpc_name: value.vpc_name?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceNetworkInterfaceCreate>
            for InstanceNetworkInterfaceCreate
        {
            fn from(value: super::InstanceNetworkInterfaceCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    ip: Ok(value.ip),
                    name: Ok(value.name),
                    subnet_name: Ok(value.subnet_name),
                    vpc_name: Ok(value.vpc_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceNetworkInterfaceResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::InstanceNetworkInterface>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InstanceNetworkInterfaceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InstanceNetworkInterfaceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::InstanceNetworkInterface>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceNetworkInterfaceResultsPage>
            for super::InstanceNetworkInterfaceResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceNetworkInterfaceResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceNetworkInterfaceResultsPage>
            for InstanceNetworkInterfaceResultsPage
        {
            fn from(value: super::InstanceNetworkInterfaceResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceNetworkInterfaceUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
            primary: ::std::result::Result<bool, ::std::string::String>,
            transit_ips:
                ::std::result::Result<::std::vec::Vec<super::IpNet>, ::std::string::String>,
        }

        impl ::std::default::Default for InstanceNetworkInterfaceUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                    primary: Ok(Default::default()),
                    transit_ips: Ok(Default::default()),
                }
            }
        }

        impl InstanceNetworkInterfaceUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
            pub fn transit_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IpNet>>,
                T::Error: ::std::fmt::Display,
            {
                self.transit_ips = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transit_ips: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceNetworkInterfaceUpdate>
            for super::InstanceNetworkInterfaceUpdate
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceNetworkInterfaceUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    primary: value.primary?,
                    transit_ips: value.transit_ips?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceNetworkInterfaceUpdate>
            for InstanceNetworkInterfaceUpdate
        {
            fn from(value: super::InstanceNetworkInterfaceUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                    primary: Ok(value.primary),
                    transit_ips: Ok(value.transit_ips),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Instance>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InstanceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InstanceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Instance>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceResultsPage> for super::InstanceResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceResultsPage> for InstanceResultsPage {
            fn from(value: super::InstanceResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceSerialConsoleData {
            data: ::std::result::Result<::std::vec::Vec<u8>, ::std::string::String>,
            last_byte_offset: ::std::result::Result<u64, ::std::string::String>,
        }

        impl ::std::default::Default for InstanceSerialConsoleData {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    last_byte_offset: Err("no value supplied for last_byte_offset".to_string()),
                }
            }
        }

        impl InstanceSerialConsoleData {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<u8>>,
                T::Error: ::std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn last_byte_offset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u64>,
                T::Error: ::std::fmt::Display,
            {
                self.last_byte_offset = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for last_byte_offset: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceSerialConsoleData> for super::InstanceSerialConsoleData {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceSerialConsoleData,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    data: value.data?,
                    last_byte_offset: value.last_byte_offset?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceSerialConsoleData> for InstanceSerialConsoleData {
            fn from(value: super::InstanceSerialConsoleData) -> Self {
                Self {
                    data: Ok(value.data),
                    last_byte_offset: Ok(value.last_byte_offset),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InstanceUpdate {
            auto_restart_policy: ::std::result::Result<
                ::std::option::Option<super::InstanceAutoRestartPolicy>,
                ::std::string::String,
            >,
            boot_disk: ::std::result::Result<
                ::std::option::Option<super::NameOrId>,
                ::std::string::String,
            >,
            memory: ::std::result::Result<super::ByteCount, ::std::string::String>,
            ncpus: ::std::result::Result<super::InstanceCpuCount, ::std::string::String>,
        }

        impl ::std::default::Default for InstanceUpdate {
            fn default() -> Self {
                Self {
                    auto_restart_policy: Ok(Default::default()),
                    boot_disk: Ok(Default::default()),
                    memory: Err("no value supplied for memory".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                }
            }
        }

        impl InstanceUpdate {
            pub fn auto_restart_policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::InstanceAutoRestartPolicy>>,
                T::Error: ::std::fmt::Display,
            {
                self.auto_restart_policy = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for auto_restart_policy: {}",
                        e
                    )
                });
                self
            }
            pub fn boot_disk<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.boot_disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for boot_disk: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: ::std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InstanceUpdate> for super::InstanceUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InstanceUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    auto_restart_policy: value.auto_restart_policy?,
                    boot_disk: value.boot_disk?,
                    memory: value.memory?,
                    ncpus: value.ncpus?,
                })
            }
        }

        impl ::std::convert::From<super::InstanceUpdate> for InstanceUpdate {
            fn from(value: super::InstanceUpdate) -> Self {
                Self {
                    auto_restart_policy: Ok(value.auto_restart_policy),
                    boot_disk: Ok(value.boot_disk),
                    memory: Ok(value.memory),
                    ncpus: Ok(value.ncpus),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGateway {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vpc_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for InternetGateway {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl InternetGateway {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGateway> for super::InternetGateway {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGateway,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGateway> for InternetGateway {
            fn from(value: super::InternetGateway) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for InternetGatewayCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl InternetGatewayCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayCreate> for super::InternetGatewayCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayCreate> for InternetGatewayCreate {
            fn from(value: super::InternetGatewayCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayIpAddress {
            address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            internet_gateway_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InternetGatewayIpAddress {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    internet_gateway_id: Err(
                        "no value supplied for internet_gateway_id".to_string()
                    ),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl InternetGatewayIpAddress {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn internet_gateway_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.internet_gateway_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for internet_gateway_id: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayIpAddress> for super::InternetGatewayIpAddress {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayIpAddress,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    description: value.description?,
                    id: value.id?,
                    internet_gateway_id: value.internet_gateway_id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayIpAddress> for InternetGatewayIpAddress {
            fn from(value: super::InternetGatewayIpAddress) -> Self {
                Self {
                    address: Ok(value.address),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    internet_gateway_id: Ok(value.internet_gateway_id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayIpAddressCreate {
            address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for InternetGatewayIpAddressCreate {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl InternetGatewayIpAddressCreate {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayIpAddressCreate>
            for super::InternetGatewayIpAddressCreate
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayIpAddressCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayIpAddressCreate>
            for InternetGatewayIpAddressCreate
        {
            fn from(value: super::InternetGatewayIpAddressCreate) -> Self {
                Self {
                    address: Ok(value.address),
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayIpAddressResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::InternetGatewayIpAddress>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InternetGatewayIpAddressResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InternetGatewayIpAddressResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::InternetGatewayIpAddress>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayIpAddressResultsPage>
            for super::InternetGatewayIpAddressResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayIpAddressResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayIpAddressResultsPage>
            for InternetGatewayIpAddressResultsPage
        {
            fn from(value: super::InternetGatewayIpAddressResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayIpPool {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            internet_gateway_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            ip_pool_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InternetGatewayIpPool {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    internet_gateway_id: Err(
                        "no value supplied for internet_gateway_id".to_string()
                    ),
                    ip_pool_id: Err("no value supplied for ip_pool_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl InternetGatewayIpPool {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn internet_gateway_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.internet_gateway_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for internet_gateway_id: {}",
                        e
                    )
                });
                self
            }
            pub fn ip_pool_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.ip_pool_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip_pool_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayIpPool> for super::InternetGatewayIpPool {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayIpPool,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    internet_gateway_id: value.internet_gateway_id?,
                    ip_pool_id: value.ip_pool_id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayIpPool> for InternetGatewayIpPool {
            fn from(value: super::InternetGatewayIpPool) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    internet_gateway_id: Ok(value.internet_gateway_id),
                    ip_pool_id: Ok(value.ip_pool_id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayIpPoolCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            ip_pool: ::std::result::Result<super::NameOrId, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for InternetGatewayIpPoolCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ip_pool: Err("no value supplied for ip_pool".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl InternetGatewayIpPoolCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ip_pool<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.ip_pool = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip_pool: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayIpPoolCreate> for super::InternetGatewayIpPoolCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayIpPoolCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    ip_pool: value.ip_pool?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayIpPoolCreate> for InternetGatewayIpPoolCreate {
            fn from(value: super::InternetGatewayIpPoolCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    ip_pool: Ok(value.ip_pool),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayIpPoolResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::InternetGatewayIpPool>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InternetGatewayIpPoolResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InternetGatewayIpPoolResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::InternetGatewayIpPool>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayIpPoolResultsPage>
            for super::InternetGatewayIpPoolResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayIpPoolResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayIpPoolResultsPage>
            for InternetGatewayIpPoolResultsPage
        {
            fn from(value: super::InternetGatewayIpPoolResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct InternetGatewayResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::InternetGateway>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for InternetGatewayResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InternetGatewayResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::InternetGateway>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<InternetGatewayResultsPage> for super::InternetGatewayResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: InternetGatewayResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::InternetGatewayResultsPage> for InternetGatewayResultsPage {
            fn from(value: super::InternetGatewayResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPool {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IpPool {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl IpPool {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<IpPool> for super::IpPool {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPool,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::IpPool> for IpPool {
            fn from(value: super::IpPool) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for IpPoolCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl IpPoolCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolCreate> for super::IpPoolCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolCreate> for IpPoolCreate {
            fn from(value: super::IpPoolCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolLinkSilo {
            is_default: ::std::result::Result<bool, ::std::string::String>,
            silo: ::std::result::Result<super::NameOrId, ::std::string::String>,
        }

        impl ::std::default::Default for IpPoolLinkSilo {
            fn default() -> Self {
                Self {
                    is_default: Err("no value supplied for is_default".to_string()),
                    silo: Err("no value supplied for silo".to_string()),
                }
            }
        }

        impl IpPoolLinkSilo {
            pub fn is_default<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_default = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_default: {}", e));
                self
            }
            pub fn silo<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.silo = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolLinkSilo> for super::IpPoolLinkSilo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolLinkSilo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_default: value.is_default?,
                    silo: value.silo?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolLinkSilo> for IpPoolLinkSilo {
            fn from(value: super::IpPoolLinkSilo) -> Self {
                Self {
                    is_default: Ok(value.is_default),
                    silo: Ok(value.silo),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolRange {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            ip_pool_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            range: ::std::result::Result<super::IpRange, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IpPoolRange {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    ip_pool_id: Err("no value supplied for ip_pool_id".to_string()),
                    range: Err("no value supplied for range".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                }
            }
        }

        impl IpPoolRange {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ip_pool_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.ip_pool_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip_pool_id: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpRange>,
                T::Error: ::std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolRange> for super::IpPoolRange {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolRange,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    ip_pool_id: value.ip_pool_id?,
                    range: value.range?,
                    time_created: value.time_created?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolRange> for IpPoolRange {
            fn from(value: super::IpPoolRange) -> Self {
                Self {
                    id: Ok(value.id),
                    ip_pool_id: Ok(value.ip_pool_id),
                    range: Ok(value.range),
                    time_created: Ok(value.time_created),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolRangeResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::IpPoolRange>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IpPoolRangeResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolRangeResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IpPoolRange>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolRangeResultsPage> for super::IpPoolRangeResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolRangeResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolRangeResultsPage> for IpPoolRangeResultsPage {
            fn from(value: super::IpPoolRangeResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::IpPool>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IpPoolResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IpPool>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolResultsPage> for super::IpPoolResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolResultsPage> for IpPoolResultsPage {
            fn from(value: super::IpPoolResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolSiloLink {
            ip_pool_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_default: ::std::result::Result<bool, ::std::string::String>,
            silo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for IpPoolSiloLink {
            fn default() -> Self {
                Self {
                    ip_pool_id: Err("no value supplied for ip_pool_id".to_string()),
                    is_default: Err("no value supplied for is_default".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl IpPoolSiloLink {
            pub fn ip_pool_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.ip_pool_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip_pool_id: {}", e));
                self
            }
            pub fn is_default<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_default = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_default: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolSiloLink> for super::IpPoolSiloLink {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolSiloLink,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ip_pool_id: value.ip_pool_id?,
                    is_default: value.is_default?,
                    silo_id: value.silo_id?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolSiloLink> for IpPoolSiloLink {
            fn from(value: super::IpPoolSiloLink) -> Self {
                Self {
                    ip_pool_id: Ok(value.ip_pool_id),
                    is_default: Ok(value.is_default),
                    silo_id: Ok(value.silo_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolSiloLinkResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::IpPoolSiloLink>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for IpPoolSiloLinkResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolSiloLinkResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IpPoolSiloLink>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolSiloLinkResultsPage> for super::IpPoolSiloLinkResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolSiloLinkResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolSiloLinkResultsPage> for IpPoolSiloLinkResultsPage {
            fn from(value: super::IpPoolSiloLinkResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolSiloUpdate {
            is_default: ::std::result::Result<bool, ::std::string::String>,
        }

        impl ::std::default::Default for IpPoolSiloUpdate {
            fn default() -> Self {
                Self {
                    is_default: Err("no value supplied for is_default".to_string()),
                }
            }
        }

        impl IpPoolSiloUpdate {
            pub fn is_default<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_default = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_default: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolSiloUpdate> for super::IpPoolSiloUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolSiloUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    is_default: value.is_default?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolSiloUpdate> for IpPoolSiloUpdate {
            fn from(value: super::IpPoolSiloUpdate) -> Self {
                Self {
                    is_default: Ok(value.is_default),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for IpPoolUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl IpPoolUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolUpdate> for super::IpPoolUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolUpdate> for IpPoolUpdate {
            fn from(value: super::IpPoolUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct IpPoolUtilization {
            ipv4: ::std::result::Result<super::Ipv4Utilization, ::std::string::String>,
            ipv6: ::std::result::Result<super::Ipv6Utilization, ::std::string::String>,
        }

        impl ::std::default::Default for IpPoolUtilization {
            fn default() -> Self {
                Self {
                    ipv4: Err("no value supplied for ipv4".to_string()),
                    ipv6: Err("no value supplied for ipv6".to_string()),
                }
            }
        }

        impl IpPoolUtilization {
            pub fn ipv4<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv4Utilization>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv4 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4: {}", e));
                self
            }
            pub fn ipv6<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv6Utilization>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv6 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<IpPoolUtilization> for super::IpPoolUtilization {
            type Error = super::error::ConversionError;
            fn try_from(
                value: IpPoolUtilization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    ipv4: value.ipv4?,
                    ipv6: value.ipv6?,
                })
            }
        }

        impl ::std::convert::From<super::IpPoolUtilization> for IpPoolUtilization {
            fn from(value: super::IpPoolUtilization) -> Self {
                Self {
                    ipv4: Ok(value.ipv4),
                    ipv6: Ok(value.ipv6),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ipv4Range {
            first: ::std::result::Result<::std::net::Ipv4Addr, ::std::string::String>,
            last: ::std::result::Result<::std::net::Ipv4Addr, ::std::string::String>,
        }

        impl ::std::default::Default for Ipv4Range {
            fn default() -> Self {
                Self {
                    first: Err("no value supplied for first".to_string()),
                    last: Err("no value supplied for last".to_string()),
                }
            }
        }

        impl Ipv4Range {
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::Ipv4Addr>,
                T::Error: ::std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn last<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::Ipv4Addr>,
                T::Error: ::std::fmt::Display,
            {
                self.last = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Ipv4Range> for super::Ipv4Range {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Ipv4Range,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first: value.first?,
                    last: value.last?,
                })
            }
        }

        impl ::std::convert::From<super::Ipv4Range> for Ipv4Range {
            fn from(value: super::Ipv4Range) -> Self {
                Self {
                    first: Ok(value.first),
                    last: Ok(value.last),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ipv4Utilization {
            allocated: ::std::result::Result<u32, ::std::string::String>,
            capacity: ::std::result::Result<u32, ::std::string::String>,
        }

        impl ::std::default::Default for Ipv4Utilization {
            fn default() -> Self {
                Self {
                    allocated: Err("no value supplied for allocated".to_string()),
                    capacity: Err("no value supplied for capacity".to_string()),
                }
            }
        }

        impl Ipv4Utilization {
            pub fn allocated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.allocated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allocated: {}", e));
                self
            }
            pub fn capacity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.capacity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for capacity: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Ipv4Utilization> for super::Ipv4Utilization {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Ipv4Utilization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allocated: value.allocated?,
                    capacity: value.capacity?,
                })
            }
        }

        impl ::std::convert::From<super::Ipv4Utilization> for Ipv4Utilization {
            fn from(value: super::Ipv4Utilization) -> Self {
                Self {
                    allocated: Ok(value.allocated),
                    capacity: Ok(value.capacity),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ipv6Range {
            first: ::std::result::Result<::std::net::Ipv6Addr, ::std::string::String>,
            last: ::std::result::Result<::std::net::Ipv6Addr, ::std::string::String>,
        }

        impl ::std::default::Default for Ipv6Range {
            fn default() -> Self {
                Self {
                    first: Err("no value supplied for first".to_string()),
                    last: Err("no value supplied for last".to_string()),
                }
            }
        }

        impl Ipv6Range {
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::Ipv6Addr>,
                T::Error: ::std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn last<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::Ipv6Addr>,
                T::Error: ::std::fmt::Display,
            {
                self.last = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Ipv6Range> for super::Ipv6Range {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Ipv6Range,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first: value.first?,
                    last: value.last?,
                })
            }
        }

        impl ::std::convert::From<super::Ipv6Range> for Ipv6Range {
            fn from(value: super::Ipv6Range) -> Self {
                Self {
                    first: Ok(value.first),
                    last: Ok(value.last),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ipv6Utilization {
            allocated: ::std::result::Result<::std::string::String, ::std::string::String>,
            capacity: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for Ipv6Utilization {
            fn default() -> Self {
                Self {
                    allocated: Err("no value supplied for allocated".to_string()),
                    capacity: Err("no value supplied for capacity".to_string()),
                }
            }
        }

        impl Ipv6Utilization {
            pub fn allocated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.allocated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allocated: {}", e));
                self
            }
            pub fn capacity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.capacity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for capacity: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Ipv6Utilization> for super::Ipv6Utilization {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Ipv6Utilization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allocated: value.allocated?,
                    capacity: value.capacity?,
                })
            }
        }

        impl ::std::convert::From<super::Ipv6Utilization> for Ipv6Utilization {
            fn from(value: super::Ipv6Utilization) -> Self {
                Self {
                    allocated: Ok(value.allocated),
                    capacity: Ok(value.capacity),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LinkConfigCreate {
            autoneg: ::std::result::Result<bool, ::std::string::String>,
            fec:
                ::std::result::Result<::std::option::Option<super::LinkFec>, ::std::string::String>,
            lldp: ::std::result::Result<super::LldpLinkConfigCreate, ::std::string::String>,
            mtu: ::std::result::Result<u16, ::std::string::String>,
            speed: ::std::result::Result<super::LinkSpeed, ::std::string::String>,
            tx_eq: ::std::result::Result<
                ::std::option::Option<super::TxEqConfig>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for LinkConfigCreate {
            fn default() -> Self {
                Self {
                    autoneg: Err("no value supplied for autoneg".to_string()),
                    fec: Ok(Default::default()),
                    lldp: Err("no value supplied for lldp".to_string()),
                    mtu: Err("no value supplied for mtu".to_string()),
                    speed: Err("no value supplied for speed".to_string()),
                    tx_eq: Ok(Default::default()),
                }
            }
        }

        impl LinkConfigCreate {
            pub fn autoneg<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.autoneg = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for autoneg: {}", e));
                self
            }
            pub fn fec<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::LinkFec>>,
                T::Error: ::std::fmt::Display,
            {
                self.fec = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fec: {}", e));
                self
            }
            pub fn lldp<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LldpLinkConfigCreate>,
                T::Error: ::std::fmt::Display,
            {
                self.lldp = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for lldp: {}", e));
                self
            }
            pub fn mtu<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.mtu = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mtu: {}", e));
                self
            }
            pub fn speed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkSpeed>,
                T::Error: ::std::fmt::Display,
            {
                self.speed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for speed: {}", e));
                self
            }
            pub fn tx_eq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::TxEqConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.tx_eq = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tx_eq: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<LinkConfigCreate> for super::LinkConfigCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LinkConfigCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    autoneg: value.autoneg?,
                    fec: value.fec?,
                    lldp: value.lldp?,
                    mtu: value.mtu?,
                    speed: value.speed?,
                    tx_eq: value.tx_eq?,
                })
            }
        }

        impl ::std::convert::From<super::LinkConfigCreate> for LinkConfigCreate {
            fn from(value: super::LinkConfigCreate) -> Self {
                Self {
                    autoneg: Ok(value.autoneg),
                    fec: Ok(value.fec),
                    lldp: Ok(value.lldp),
                    mtu: Ok(value.mtu),
                    speed: Ok(value.speed),
                    tx_eq: Ok(value.tx_eq),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LldpLinkConfig {
            chassis_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enabled: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            link_description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            link_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            management_ip:
                ::std::result::Result<::std::option::Option<super::IpNet>, ::std::string::String>,
            system_description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            system_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for LldpLinkConfig {
            fn default() -> Self {
                Self {
                    chassis_id: Ok(Default::default()),
                    enabled: Err("no value supplied for enabled".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    link_description: Ok(Default::default()),
                    link_name: Ok(Default::default()),
                    management_ip: Ok(Default::default()),
                    system_description: Ok(Default::default()),
                    system_name: Ok(Default::default()),
                }
            }
        }

        impl LldpLinkConfig {
            pub fn chassis_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.chassis_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chassis_id: {}", e));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn link_description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.link_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for link_description: {}",
                        e
                    )
                });
                self
            }
            pub fn link_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.link_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for link_name: {}", e));
                self
            }
            pub fn management_ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::IpNet>>,
                T::Error: ::std::fmt::Display,
            {
                self.management_ip = value.try_into().map_err(|e| {
                    format!("error converting supplied value for management_ip: {}", e)
                });
                self
            }
            pub fn system_description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.system_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for system_description: {}",
                        e
                    )
                });
                self
            }
            pub fn system_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.system_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for system_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<LldpLinkConfig> for super::LldpLinkConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LldpLinkConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chassis_id: value.chassis_id?,
                    enabled: value.enabled?,
                    id: value.id?,
                    link_description: value.link_description?,
                    link_name: value.link_name?,
                    management_ip: value.management_ip?,
                    system_description: value.system_description?,
                    system_name: value.system_name?,
                })
            }
        }

        impl ::std::convert::From<super::LldpLinkConfig> for LldpLinkConfig {
            fn from(value: super::LldpLinkConfig) -> Self {
                Self {
                    chassis_id: Ok(value.chassis_id),
                    enabled: Ok(value.enabled),
                    id: Ok(value.id),
                    link_description: Ok(value.link_description),
                    link_name: Ok(value.link_name),
                    management_ip: Ok(value.management_ip),
                    system_description: Ok(value.system_description),
                    system_name: Ok(value.system_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LldpLinkConfigCreate {
            chassis_id: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            enabled: ::std::result::Result<bool, ::std::string::String>,
            link_description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            link_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            management_ip: ::std::result::Result<
                ::std::option::Option<::std::net::IpAddr>,
                ::std::string::String,
            >,
            system_description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            system_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for LldpLinkConfigCreate {
            fn default() -> Self {
                Self {
                    chassis_id: Ok(Default::default()),
                    enabled: Err("no value supplied for enabled".to_string()),
                    link_description: Ok(Default::default()),
                    link_name: Ok(Default::default()),
                    management_ip: Ok(Default::default()),
                    system_description: Ok(Default::default()),
                    system_name: Ok(Default::default()),
                }
            }
        }

        impl LldpLinkConfigCreate {
            pub fn chassis_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.chassis_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chassis_id: {}", e));
                self
            }
            pub fn enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for enabled: {}", e));
                self
            }
            pub fn link_description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.link_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for link_description: {}",
                        e
                    )
                });
                self
            }
            pub fn link_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.link_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for link_name: {}", e));
                self
            }
            pub fn management_ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::net::IpAddr>>,
                T::Error: ::std::fmt::Display,
            {
                self.management_ip = value.try_into().map_err(|e| {
                    format!("error converting supplied value for management_ip: {}", e)
                });
                self
            }
            pub fn system_description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.system_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for system_description: {}",
                        e
                    )
                });
                self
            }
            pub fn system_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.system_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for system_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<LldpLinkConfigCreate> for super::LldpLinkConfigCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LldpLinkConfigCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chassis_id: value.chassis_id?,
                    enabled: value.enabled?,
                    link_description: value.link_description?,
                    link_name: value.link_name?,
                    management_ip: value.management_ip?,
                    system_description: value.system_description?,
                    system_name: value.system_name?,
                })
            }
        }

        impl ::std::convert::From<super::LldpLinkConfigCreate> for LldpLinkConfigCreate {
            fn from(value: super::LldpLinkConfigCreate) -> Self {
                Self {
                    chassis_id: Ok(value.chassis_id),
                    enabled: Ok(value.enabled),
                    link_description: Ok(value.link_description),
                    link_name: Ok(value.link_name),
                    management_ip: Ok(value.management_ip),
                    system_description: Ok(value.system_description),
                    system_name: Ok(value.system_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LldpNeighbor {
            chassis_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            first_seen: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            last_seen: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            link_description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            link_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            local_port: ::std::result::Result<::std::string::String, ::std::string::String>,
            management_ip: ::std::result::Result<
                ::std::vec::Vec<super::ManagementAddress>,
                ::std::string::String,
            >,
            system_description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            system_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for LldpNeighbor {
            fn default() -> Self {
                Self {
                    chassis_id: Err("no value supplied for chassis_id".to_string()),
                    first_seen: Err("no value supplied for first_seen".to_string()),
                    last_seen: Err("no value supplied for last_seen".to_string()),
                    link_description: Ok(Default::default()),
                    link_name: Err("no value supplied for link_name".to_string()),
                    local_port: Err("no value supplied for local_port".to_string()),
                    management_ip: Err("no value supplied for management_ip".to_string()),
                    system_description: Ok(Default::default()),
                    system_name: Ok(Default::default()),
                }
            }
        }

        impl LldpNeighbor {
            pub fn chassis_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.chassis_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for chassis_id: {}", e));
                self
            }
            pub fn first_seen<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.first_seen = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first_seen: {}", e));
                self
            }
            pub fn last_seen<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.last_seen = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_seen: {}", e));
                self
            }
            pub fn link_description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.link_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for link_description: {}",
                        e
                    )
                });
                self
            }
            pub fn link_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.link_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for link_name: {}", e));
                self
            }
            pub fn local_port<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.local_port = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for local_port: {}", e));
                self
            }
            pub fn management_ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ManagementAddress>>,
                T::Error: ::std::fmt::Display,
            {
                self.management_ip = value.try_into().map_err(|e| {
                    format!("error converting supplied value for management_ip: {}", e)
                });
                self
            }
            pub fn system_description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.system_description = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for system_description: {}",
                        e
                    )
                });
                self
            }
            pub fn system_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.system_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for system_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<LldpNeighbor> for super::LldpNeighbor {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LldpNeighbor,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    chassis_id: value.chassis_id?,
                    first_seen: value.first_seen?,
                    last_seen: value.last_seen?,
                    link_description: value.link_description?,
                    link_name: value.link_name?,
                    local_port: value.local_port?,
                    management_ip: value.management_ip?,
                    system_description: value.system_description?,
                    system_name: value.system_name?,
                })
            }
        }

        impl ::std::convert::From<super::LldpNeighbor> for LldpNeighbor {
            fn from(value: super::LldpNeighbor) -> Self {
                Self {
                    chassis_id: Ok(value.chassis_id),
                    first_seen: Ok(value.first_seen),
                    last_seen: Ok(value.last_seen),
                    link_description: Ok(value.link_description),
                    link_name: Ok(value.link_name),
                    local_port: Ok(value.local_port),
                    management_ip: Ok(value.management_ip),
                    system_description: Ok(value.system_description),
                    system_name: Ok(value.system_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LldpNeighborResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::LldpNeighbor>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for LldpNeighborResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl LldpNeighborResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::LldpNeighbor>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<LldpNeighborResultsPage> for super::LldpNeighborResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LldpNeighborResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::LldpNeighborResultsPage> for LldpNeighborResultsPage {
            fn from(value: super::LldpNeighborResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LoopbackAddress {
            address: ::std::result::Result<super::IpNet, ::std::string::String>,
            address_lot_block_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            rack_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            switch_location: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for LoopbackAddress {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    address_lot_block_id: Err(
                        "no value supplied for address_lot_block_id".to_string()
                    ),
                    id: Err("no value supplied for id".to_string()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                    switch_location: Err("no value supplied for switch_location".to_string()),
                }
            }
        }

        impl LoopbackAddress {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn address_lot_block_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.address_lot_block_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for address_lot_block_id: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
            pub fn switch_location<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.switch_location = value.try_into().map_err(|e| {
                    format!("error converting supplied value for switch_location: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<LoopbackAddress> for super::LoopbackAddress {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LoopbackAddress,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    address_lot_block_id: value.address_lot_block_id?,
                    id: value.id?,
                    rack_id: value.rack_id?,
                    switch_location: value.switch_location?,
                })
            }
        }

        impl ::std::convert::From<super::LoopbackAddress> for LoopbackAddress {
            fn from(value: super::LoopbackAddress) -> Self {
                Self {
                    address: Ok(value.address),
                    address_lot_block_id: Ok(value.address_lot_block_id),
                    id: Ok(value.id),
                    rack_id: Ok(value.rack_id),
                    switch_location: Ok(value.switch_location),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LoopbackAddressCreate {
            address: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            address_lot: ::std::result::Result<super::NameOrId, ::std::string::String>,
            anycast: ::std::result::Result<bool, ::std::string::String>,
            mask: ::std::result::Result<u8, ::std::string::String>,
            rack_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            switch_location: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for LoopbackAddressCreate {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    address_lot: Err("no value supplied for address_lot".to_string()),
                    anycast: Err("no value supplied for anycast".to_string()),
                    mask: Err("no value supplied for mask".to_string()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                    switch_location: Err("no value supplied for switch_location".to_string()),
                }
            }
        }

        impl LoopbackAddressCreate {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn address_lot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.address_lot = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address_lot: {}", e));
                self
            }
            pub fn anycast<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.anycast = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for anycast: {}", e));
                self
            }
            pub fn mask<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.mask = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mask: {}", e));
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
            pub fn switch_location<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.switch_location = value.try_into().map_err(|e| {
                    format!("error converting supplied value for switch_location: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<LoopbackAddressCreate> for super::LoopbackAddressCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LoopbackAddressCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    address_lot: value.address_lot?,
                    anycast: value.anycast?,
                    mask: value.mask?,
                    rack_id: value.rack_id?,
                    switch_location: value.switch_location?,
                })
            }
        }

        impl ::std::convert::From<super::LoopbackAddressCreate> for LoopbackAddressCreate {
            fn from(value: super::LoopbackAddressCreate) -> Self {
                Self {
                    address: Ok(value.address),
                    address_lot: Ok(value.address_lot),
                    anycast: Ok(value.anycast),
                    mask: Ok(value.mask),
                    rack_id: Ok(value.rack_id),
                    switch_location: Ok(value.switch_location),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct LoopbackAddressResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::LoopbackAddress>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for LoopbackAddressResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl LoopbackAddressResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::LoopbackAddress>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<LoopbackAddressResultsPage> for super::LoopbackAddressResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: LoopbackAddressResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::LoopbackAddressResultsPage> for LoopbackAddressResultsPage {
            fn from(value: super::LoopbackAddressResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ManagementAddress {
            addr: ::std::result::Result<super::NetworkAddress, ::std::string::String>,
            interface_num: ::std::result::Result<super::InterfaceNum, ::std::string::String>,
            oid: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<u8>>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for ManagementAddress {
            fn default() -> Self {
                Self {
                    addr: Err("no value supplied for addr".to_string()),
                    interface_num: Err("no value supplied for interface_num".to_string()),
                    oid: Ok(Default::default()),
                }
            }
        }

        impl ManagementAddress {
            pub fn addr<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NetworkAddress>,
                T::Error: ::std::fmt::Display,
            {
                self.addr = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addr: {}", e));
                self
            }
            pub fn interface_num<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InterfaceNum>,
                T::Error: ::std::fmt::Display,
            {
                self.interface_num = value.try_into().map_err(|e| {
                    format!("error converting supplied value for interface_num: {}", e)
                });
                self
            }
            pub fn oid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::vec::Vec<u8>>>,
                T::Error: ::std::fmt::Display,
            {
                self.oid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for oid: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ManagementAddress> for super::ManagementAddress {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ManagementAddress,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addr: value.addr?,
                    interface_num: value.interface_num?,
                    oid: value.oid?,
                })
            }
        }

        impl ::std::convert::From<super::ManagementAddress> for ManagementAddress {
            fn from(value: super::ManagementAddress) -> Self {
                Self {
                    addr: Ok(value.addr),
                    interface_num: Ok(value.interface_num),
                    oid: Ok(value.oid),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Measurement {
            datum: ::std::result::Result<super::Datum, ::std::string::String>,
            timestamp: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Measurement {
            fn default() -> Self {
                Self {
                    datum: Err("no value supplied for datum".to_string()),
                    timestamp: Err("no value supplied for timestamp".to_string()),
                }
            }
        }

        impl Measurement {
            pub fn datum<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Datum>,
                T::Error: ::std::fmt::Display,
            {
                self.datum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum: {}", e));
                self
            }
            pub fn timestamp<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.timestamp = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for timestamp: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Measurement> for super::Measurement {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Measurement,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    datum: value.datum?,
                    timestamp: value.timestamp?,
                })
            }
        }

        impl ::std::convert::From<super::Measurement> for Measurement {
            fn from(value: super::Measurement) -> Self {
                Self {
                    datum: Ok(value.datum),
                    timestamp: Ok(value.timestamp),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct MeasurementResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::Measurement>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for MeasurementResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl MeasurementResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Measurement>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<MeasurementResultsPage> for super::MeasurementResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MeasurementResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::MeasurementResultsPage> for MeasurementResultsPage {
            fn from(value: super::MeasurementResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct MissingDatum {
            datum_type: ::std::result::Result<super::DatumType, ::std::string::String>,
            start_time: ::std::result::Result<
                ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for MissingDatum {
            fn default() -> Self {
                Self {
                    datum_type: Err("no value supplied for datum_type".to_string()),
                    start_time: Ok(Default::default()),
                }
            }
        }

        impl MissingDatum {
            pub fn datum_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DatumType>,
                T::Error: ::std::fmt::Display,
            {
                self.datum_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum_type: {}", e));
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<MissingDatum> for super::MissingDatum {
            type Error = super::error::ConversionError;
            fn try_from(
                value: MissingDatum,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    datum_type: value.datum_type?,
                    start_time: value.start_time?,
                })
            }
        }

        impl ::std::convert::From<super::MissingDatum> for MissingDatum {
            fn from(value: super::MissingDatum) -> Self {
                Self {
                    datum_type: Ok(value.datum_type),
                    start_time: Ok(value.start_time),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct NetworkInterface {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            ip: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            kind: ::std::result::Result<super::NetworkInterfaceKind, ::std::string::String>,
            mac: ::std::result::Result<super::MacAddr, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            primary: ::std::result::Result<bool, ::std::string::String>,
            slot: ::std::result::Result<u8, ::std::string::String>,
            subnet: ::std::result::Result<super::IpNet, ::std::string::String>,
            transit_ips:
                ::std::result::Result<::std::vec::Vec<super::IpNet>, ::std::string::String>,
            vni: ::std::result::Result<super::Vni, ::std::string::String>,
        }

        impl ::std::default::Default for NetworkInterface {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    ip: Err("no value supplied for ip".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    mac: Err("no value supplied for mac".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    primary: Err("no value supplied for primary".to_string()),
                    slot: Err("no value supplied for slot".to_string()),
                    subnet: Err("no value supplied for subnet".to_string()),
                    transit_ips: Ok(Default::default()),
                    vni: Err("no value supplied for vni".to_string()),
                }
            }
        }

        impl NetworkInterface {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NetworkInterfaceKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn mac<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MacAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.mac = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mac: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
            pub fn slot<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u8>,
                T::Error: ::std::fmt::Display,
            {
                self.slot = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slot: {}", e));
                self
            }
            pub fn subnet<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.subnet = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet: {}", e));
                self
            }
            pub fn transit_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::IpNet>>,
                T::Error: ::std::fmt::Display,
            {
                self.transit_ips = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for transit_ips: {}", e));
                self
            }
            pub fn vni<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Vni>,
                T::Error: ::std::fmt::Display,
            {
                self.vni = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vni: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<NetworkInterface> for super::NetworkInterface {
            type Error = super::error::ConversionError;
            fn try_from(
                value: NetworkInterface,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    ip: value.ip?,
                    kind: value.kind?,
                    mac: value.mac?,
                    name: value.name?,
                    primary: value.primary?,
                    slot: value.slot?,
                    subnet: value.subnet?,
                    transit_ips: value.transit_ips?,
                    vni: value.vni?,
                })
            }
        }

        impl ::std::convert::From<super::NetworkInterface> for NetworkInterface {
            fn from(value: super::NetworkInterface) -> Self {
                Self {
                    id: Ok(value.id),
                    ip: Ok(value.ip),
                    kind: Ok(value.kind),
                    mac: Ok(value.mac),
                    name: Ok(value.name),
                    primary: Ok(value.primary),
                    slot: Ok(value.slot),
                    subnet: Ok(value.subnet),
                    transit_ips: Ok(value.transit_ips),
                    vni: Ok(value.vni),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct OxqlQueryResult {
            tables: ::std::result::Result<::std::vec::Vec<super::Table>, ::std::string::String>,
        }

        impl ::std::default::Default for OxqlQueryResult {
            fn default() -> Self {
                Self {
                    tables: Err("no value supplied for tables".to_string()),
                }
            }
        }

        impl OxqlQueryResult {
            pub fn tables<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Table>>,
                T::Error: ::std::fmt::Display,
            {
                self.tables = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tables: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<OxqlQueryResult> for super::OxqlQueryResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: OxqlQueryResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    tables: value.tables?,
                })
            }
        }

        impl ::std::convert::From<super::OxqlQueryResult> for OxqlQueryResult {
            fn from(value: super::OxqlQueryResult) -> Self {
                Self {
                    tables: Ok(value.tables),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct PhysicalDisk {
            form_factor: ::std::result::Result<super::PhysicalDiskKind, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            model: ::std::result::Result<::std::string::String, ::std::string::String>,
            policy: ::std::result::Result<super::PhysicalDiskPolicy, ::std::string::String>,
            serial: ::std::result::Result<::std::string::String, ::std::string::String>,
            sled_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            state: ::std::result::Result<super::PhysicalDiskState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vendor: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for PhysicalDisk {
            fn default() -> Self {
                Self {
                    form_factor: Err("no value supplied for form_factor".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    model: Err("no value supplied for model".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                    sled_id: Ok(Default::default()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vendor: Err("no value supplied for vendor".to_string()),
                }
            }
        }

        impl PhysicalDisk {
            pub fn form_factor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PhysicalDiskKind>,
                T::Error: ::std::fmt::Display,
            {
                self.form_factor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for form_factor: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn model<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.model = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for model: {}", e));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PhysicalDiskPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
            pub fn sled_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.sled_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sled_id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PhysicalDiskState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vendor<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.vendor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vendor: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<PhysicalDisk> for super::PhysicalDisk {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PhysicalDisk,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    form_factor: value.form_factor?,
                    id: value.id?,
                    model: value.model?,
                    policy: value.policy?,
                    serial: value.serial?,
                    sled_id: value.sled_id?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vendor: value.vendor?,
                })
            }
        }

        impl ::std::convert::From<super::PhysicalDisk> for PhysicalDisk {
            fn from(value: super::PhysicalDisk) -> Self {
                Self {
                    form_factor: Ok(value.form_factor),
                    id: Ok(value.id),
                    model: Ok(value.model),
                    policy: Ok(value.policy),
                    serial: Ok(value.serial),
                    sled_id: Ok(value.sled_id),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vendor: Ok(value.vendor),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct PhysicalDiskResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::PhysicalDisk>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for PhysicalDiskResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl PhysicalDiskResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::PhysicalDisk>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<PhysicalDiskResultsPage> for super::PhysicalDiskResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: PhysicalDiskResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::PhysicalDiskResultsPage> for PhysicalDiskResultsPage {
            fn from(value: super::PhysicalDiskResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Ping {
            status: ::std::result::Result<super::PingStatus, ::std::string::String>,
        }

        impl ::std::default::Default for Ping {
            fn default() -> Self {
                Self {
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }

        impl Ping {
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::PingStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Ping> for super::Ping {
            type Error = super::error::ConversionError;
            fn try_from(value: Ping) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    status: value.status?,
                })
            }
        }

        impl ::std::convert::From<super::Ping> for Ping {
            fn from(value: super::Ping) -> Self {
                Self {
                    status: Ok(value.status),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Points {
            start_times: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<::chrono::DateTime<::chrono::offset::Utc>>>,
                ::std::string::String,
            >,
            timestamps: ::std::result::Result<
                ::std::vec::Vec<::chrono::DateTime<::chrono::offset::Utc>>,
                ::std::string::String,
            >,
            values: ::std::result::Result<::std::vec::Vec<super::Values>, ::std::string::String>,
        }

        impl ::std::default::Default for Points {
            fn default() -> Self {
                Self {
                    start_times: Ok(Default::default()),
                    timestamps: Err("no value supplied for timestamps".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }

        impl Points {
            pub fn start_times<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<
                        ::std::vec::Vec<::chrono::DateTime<::chrono::offset::Utc>>,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.start_times = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_times: {}", e));
                self
            }
            pub fn timestamps<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::chrono::DateTime<::chrono::offset::Utc>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.timestamps = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for timestamps: {}", e));
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Values>>,
                T::Error: ::std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for values: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Points> for super::Points {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Points,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    start_times: value.start_times?,
                    timestamps: value.timestamps?,
                    values: value.values?,
                })
            }
        }

        impl ::std::convert::From<super::Points> for Points {
            fn from(value: super::Points) -> Self {
                Self {
                    start_times: Ok(value.start_times),
                    timestamps: Ok(value.timestamps),
                    values: Ok(value.values),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Probe {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            sled: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Probe {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    sled: Err("no value supplied for sled".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Probe {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn sled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.sled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sled: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Probe> for super::Probe {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Probe,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    sled: value.sled?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Probe> for Probe {
            fn from(value: super::Probe) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    sled: Ok(value.sled),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProbeCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            ip_pool: ::std::result::Result<
                ::std::option::Option<super::NameOrId>,
                ::std::string::String,
            >,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            sled: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for ProbeCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ip_pool: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    sled: Err("no value supplied for sled".to_string()),
                }
            }
        }

        impl ProbeCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ip_pool<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.ip_pool = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip_pool: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn sled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.sled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sled: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProbeCreate> for super::ProbeCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProbeCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    ip_pool: value.ip_pool?,
                    name: value.name?,
                    sled: value.sled?,
                })
            }
        }

        impl ::std::convert::From<super::ProbeCreate> for ProbeCreate {
            fn from(value: super::ProbeCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    ip_pool: Ok(value.ip_pool),
                    name: Ok(value.name),
                    sled: Ok(value.sled),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProbeExternalIp {
            first_port: ::std::result::Result<u16, ::std::string::String>,
            ip: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            kind: ::std::result::Result<super::ProbeExternalIpKind, ::std::string::String>,
            last_port: ::std::result::Result<u16, ::std::string::String>,
        }

        impl ::std::default::Default for ProbeExternalIp {
            fn default() -> Self {
                Self {
                    first_port: Err("no value supplied for first_port".to_string()),
                    ip: Err("no value supplied for ip".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    last_port: Err("no value supplied for last_port".to_string()),
                }
            }
        }

        impl ProbeExternalIp {
            pub fn first_port<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.first_port = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first_port: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ProbeExternalIpKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn last_port<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.last_port = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last_port: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProbeExternalIp> for super::ProbeExternalIp {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProbeExternalIp,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    first_port: value.first_port?,
                    ip: value.ip?,
                    kind: value.kind?,
                    last_port: value.last_port?,
                })
            }
        }

        impl ::std::convert::From<super::ProbeExternalIp> for ProbeExternalIp {
            fn from(value: super::ProbeExternalIp) -> Self {
                Self {
                    first_port: Ok(value.first_port),
                    ip: Ok(value.ip),
                    kind: Ok(value.kind),
                    last_port: Ok(value.last_port),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProbeInfo {
            external_ips: ::std::result::Result<
                ::std::vec::Vec<super::ProbeExternalIp>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            interface: ::std::result::Result<super::NetworkInterface, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            sled: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for ProbeInfo {
            fn default() -> Self {
                Self {
                    external_ips: Err("no value supplied for external_ips".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    interface: Err("no value supplied for interface".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    sled: Err("no value supplied for sled".to_string()),
                }
            }
        }

        impl ProbeInfo {
            pub fn external_ips<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ProbeExternalIp>>,
                T::Error: ::std::fmt::Display,
            {
                self.external_ips = value.try_into().map_err(|e| {
                    format!("error converting supplied value for external_ips: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn interface<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NetworkInterface>,
                T::Error: ::std::fmt::Display,
            {
                self.interface = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for interface: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn sled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.sled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sled: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProbeInfo> for super::ProbeInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProbeInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    external_ips: value.external_ips?,
                    id: value.id?,
                    interface: value.interface?,
                    name: value.name?,
                    sled: value.sled?,
                })
            }
        }

        impl ::std::convert::From<super::ProbeInfo> for ProbeInfo {
            fn from(value: super::ProbeInfo) -> Self {
                Self {
                    external_ips: Ok(value.external_ips),
                    id: Ok(value.id),
                    interface: Ok(value.interface),
                    name: Ok(value.name),
                    sled: Ok(value.sled),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProbeInfoResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::ProbeInfo>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for ProbeInfoResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ProbeInfoResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ProbeInfo>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProbeInfoResultsPage> for super::ProbeInfoResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProbeInfoResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::ProbeInfoResultsPage> for ProbeInfoResultsPage {
            fn from(value: super::ProbeInfoResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Project {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Project {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Project {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Project> for super::Project {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Project,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Project> for Project {
            fn from(value: super::Project) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for ProjectCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl ProjectCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProjectCreate> for super::ProjectCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProjectCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::ProjectCreate> for ProjectCreate {
            fn from(value: super::ProjectCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Project>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for ProjectResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ProjectResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Project>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProjectResultsPage> for super::ProjectResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProjectResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::ProjectResultsPage> for ProjectResultsPage {
            fn from(value: super::ProjectResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectRolePolicy {
            role_assignments: ::std::result::Result<
                ::std::vec::Vec<super::ProjectRoleRoleAssignment>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for ProjectRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl ProjectRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ProjectRoleRoleAssignment>>,
                T::Error: ::std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<ProjectRolePolicy> for super::ProjectRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProjectRolePolicy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl ::std::convert::From<super::ProjectRolePolicy> for ProjectRolePolicy {
            fn from(value: super::ProjectRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectRoleRoleAssignment {
            identity_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            identity_type: ::std::result::Result<super::IdentityType, ::std::string::String>,
            role_name: ::std::result::Result<super::ProjectRole, ::std::string::String>,
        }

        impl ::std::default::Default for ProjectRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl ProjectRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IdentityType>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ProjectRole>,
                T::Error: ::std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProjectRoleRoleAssignment> for super::ProjectRoleRoleAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProjectRoleRoleAssignment,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl ::std::convert::From<super::ProjectRoleRoleAssignment> for ProjectRoleRoleAssignment {
            fn from(value: super::ProjectRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct ProjectUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for ProjectUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl ProjectUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<ProjectUpdate> for super::ProjectUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ProjectUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::ProjectUpdate> for ProjectUpdate {
            fn from(value: super::ProjectUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Quantile {
            desired_marker_positions: ::std::result::Result<[f64; 5usize], ::std::string::String>,
            marker_heights: ::std::result::Result<[f64; 5usize], ::std::string::String>,
            marker_positions: ::std::result::Result<[u64; 5usize], ::std::string::String>,
            p: ::std::result::Result<f64, ::std::string::String>,
        }

        impl ::std::default::Default for Quantile {
            fn default() -> Self {
                Self {
                    desired_marker_positions: Err(
                        "no value supplied for desired_marker_positions".to_string()
                    ),
                    marker_heights: Err("no value supplied for marker_heights".to_string()),
                    marker_positions: Err("no value supplied for marker_positions".to_string()),
                    p: Err("no value supplied for p".to_string()),
                }
            }
        }

        impl Quantile {
            pub fn desired_marker_positions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<[f64; 5usize]>,
                T::Error: ::std::fmt::Display,
            {
                self.desired_marker_positions = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for desired_marker_positions: {}",
                        e
                    )
                });
                self
            }
            pub fn marker_heights<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<[f64; 5usize]>,
                T::Error: ::std::fmt::Display,
            {
                self.marker_heights = value.try_into().map_err(|e| {
                    format!("error converting supplied value for marker_heights: {}", e)
                });
                self
            }
            pub fn marker_positions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<[u64; 5usize]>,
                T::Error: ::std::fmt::Display,
            {
                self.marker_positions = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for marker_positions: {}",
                        e
                    )
                });
                self
            }
            pub fn p<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<f64>,
                T::Error: ::std::fmt::Display,
            {
                self.p = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for p: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Quantile> for super::Quantile {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Quantile,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    desired_marker_positions: value.desired_marker_positions?,
                    marker_heights: value.marker_heights?,
                    marker_positions: value.marker_positions?,
                    p: value.p?,
                })
            }
        }

        impl ::std::convert::From<super::Quantile> for Quantile {
            fn from(value: super::Quantile) -> Self {
                Self {
                    desired_marker_positions: Ok(value.desired_marker_positions),
                    marker_heights: Ok(value.marker_heights),
                    marker_positions: Ok(value.marker_positions),
                    p: Ok(value.p),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Rack {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Rack {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Rack {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Rack> for super::Rack {
            type Error = super::error::ConversionError;
            fn try_from(value: Rack) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Rack> for Rack {
            fn from(value: super::Rack) -> Self {
                Self {
                    id: Ok(value.id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RackResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Rack>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for RackResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RackResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Rack>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<RackResultsPage> for super::RackResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RackResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::RackResultsPage> for RackResultsPage {
            fn from(value: super::RackResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Role {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::RoleName, ::std::string::String>,
        }

        impl ::std::default::Default for Role {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl Role {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RoleName>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Role> for super::Role {
            type Error = super::error::ConversionError;
            fn try_from(value: Role) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::Role> for Role {
            fn from(value: super::Role) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RoleResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Role>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for RoleResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RoleResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Role>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<RoleResultsPage> for super::RoleResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RoleResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::RoleResultsPage> for RoleResultsPage {
            fn from(value: super::RoleResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Route {
            dst: ::std::result::Result<super::IpNet, ::std::string::String>,
            gw: ::std::result::Result<::std::net::IpAddr, ::std::string::String>,
            rib_priority: ::std::result::Result<::std::option::Option<u8>, ::std::string::String>,
            vid: ::std::result::Result<::std::option::Option<u16>, ::std::string::String>,
        }

        impl ::std::default::Default for Route {
            fn default() -> Self {
                Self {
                    dst: Err("no value supplied for dst".to_string()),
                    gw: Err("no value supplied for gw".to_string()),
                    rib_priority: Ok(Default::default()),
                    vid: Ok(Default::default()),
                }
            }
        }

        impl Route {
            pub fn dst<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.dst = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dst: {}", e));
                self
            }
            pub fn gw<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::net::IpAddr>,
                T::Error: ::std::fmt::Display,
            {
                self.gw = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gw: {}", e));
                self
            }
            pub fn rib_priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u8>>,
                T::Error: ::std::fmt::Display,
            {
                self.rib_priority = value.try_into().map_err(|e| {
                    format!("error converting supplied value for rib_priority: {}", e)
                });
                self
            }
            pub fn vid<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u16>>,
                T::Error: ::std::fmt::Display,
            {
                self.vid = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vid: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Route> for super::Route {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Route,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    dst: value.dst?,
                    gw: value.gw?,
                    rib_priority: value.rib_priority?,
                    vid: value.vid?,
                })
            }
        }

        impl ::std::convert::From<super::Route> for Route {
            fn from(value: super::Route) -> Self {
                Self {
                    dst: Ok(value.dst),
                    gw: Ok(value.gw),
                    rib_priority: Ok(value.rib_priority),
                    vid: Ok(value.vid),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouteConfig {
            routes: ::std::result::Result<::std::vec::Vec<super::Route>, ::std::string::String>,
        }

        impl ::std::default::Default for RouteConfig {
            fn default() -> Self {
                Self {
                    routes: Err("no value supplied for routes".to_string()),
                }
            }
        }

        impl RouteConfig {
            pub fn routes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Route>>,
                T::Error: ::std::fmt::Display,
            {
                self.routes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for routes: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<RouteConfig> for super::RouteConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouteConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    routes: value.routes?,
                })
            }
        }

        impl ::std::convert::From<super::RouteConfig> for RouteConfig {
            fn from(value: super::RouteConfig) -> Self {
                Self {
                    routes: Ok(value.routes),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRoute {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            destination: ::std::result::Result<super::RouteDestination, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            kind: ::std::result::Result<super::RouterRouteKind, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            target: ::std::result::Result<super::RouteTarget, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vpc_router_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for RouterRoute {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    destination: Err("no value supplied for destination".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    target: Err("no value supplied for target".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_router_id: Err("no value supplied for vpc_router_id".to_string()),
                }
            }
        }

        impl RouterRoute {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouteDestination>,
                T::Error: ::std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouterRouteKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouteTarget>,
                T::Error: ::std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_router_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_router_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vpc_router_id: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<RouterRoute> for super::RouterRoute {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRoute,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    target: value.target?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_router_id: value.vpc_router_id?,
                })
            }
        }

        impl ::std::convert::From<super::RouterRoute> for RouterRoute {
            fn from(value: super::RouterRoute) -> Self {
                Self {
                    description: Ok(value.description),
                    destination: Ok(value.destination),
                    id: Ok(value.id),
                    kind: Ok(value.kind),
                    name: Ok(value.name),
                    target: Ok(value.target),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_router_id: Ok(value.vpc_router_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRouteCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            destination: ::std::result::Result<super::RouteDestination, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            target: ::std::result::Result<super::RouteTarget, ::std::string::String>,
        }

        impl ::std::default::Default for RouterRouteCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    destination: Err("no value supplied for destination".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl RouterRouteCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouteDestination>,
                T::Error: ::std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouteTarget>,
                T::Error: ::std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<RouterRouteCreate> for super::RouterRouteCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRouteCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    name: value.name?,
                    target: value.target?,
                })
            }
        }

        impl ::std::convert::From<super::RouterRouteCreate> for RouterRouteCreate {
            fn from(value: super::RouterRouteCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    destination: Ok(value.destination),
                    name: Ok(value.name),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRouteResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::RouterRoute>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for RouterRouteResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RouterRouteResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::RouterRoute>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<RouterRouteResultsPage> for super::RouterRouteResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRouteResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::RouterRouteResultsPage> for RouterRouteResultsPage {
            fn from(value: super::RouterRouteResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct RouterRouteUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            destination: ::std::result::Result<super::RouteDestination, ::std::string::String>,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
            target: ::std::result::Result<super::RouteTarget, ::std::string::String>,
        }

        impl ::std::default::Default for RouterRouteUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    destination: Err("no value supplied for destination".to_string()),
                    name: Ok(Default::default()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl RouterRouteUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouteDestination>,
                T::Error: ::std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::RouteTarget>,
                T::Error: ::std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<RouterRouteUpdate> for super::RouterRouteUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: RouterRouteUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    name: value.name?,
                    target: value.target?,
                })
            }
        }

        impl ::std::convert::From<super::RouterRouteUpdate> for RouterRouteUpdate {
            fn from(value: super::RouterRouteUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    destination: Ok(value.destination),
                    name: Ok(value.name),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SamlIdentityProvider {
            acs_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            group_attribute_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            idp_entity_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            public_cert: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            slo_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            sp_client_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            technical_contact_email:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SamlIdentityProvider {
            fn default() -> Self {
                Self {
                    acs_url: Err("no value supplied for acs_url".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    group_attribute_name: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    idp_entity_id: Err("no value supplied for idp_entity_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_cert: Ok(Default::default()),
                    slo_url: Err("no value supplied for slo_url".to_string()),
                    sp_client_id: Err("no value supplied for sp_client_id".to_string()),
                    technical_contact_email: Err(
                        "no value supplied for technical_contact_email".to_string()
                    ),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SamlIdentityProvider {
            pub fn acs_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.acs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for acs_url: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn group_attribute_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_attribute_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for group_attribute_name: {}",
                        e
                    )
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn idp_entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.idp_entity_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idp_entity_id: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_cert<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.public_cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_cert: {}", e));
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {}", e));
                self
            }
            pub fn sp_client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sp_client_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sp_client_id: {}", e)
                });
                self
            }
            pub fn technical_contact_email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.technical_contact_email = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for technical_contact_email: {}",
                        e
                    )
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SamlIdentityProvider> for super::SamlIdentityProvider {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SamlIdentityProvider,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acs_url: value.acs_url?,
                    description: value.description?,
                    group_attribute_name: value.group_attribute_name?,
                    id: value.id?,
                    idp_entity_id: value.idp_entity_id?,
                    name: value.name?,
                    public_cert: value.public_cert?,
                    slo_url: value.slo_url?,
                    sp_client_id: value.sp_client_id?,
                    technical_contact_email: value.technical_contact_email?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::SamlIdentityProvider> for SamlIdentityProvider {
            fn from(value: super::SamlIdentityProvider) -> Self {
                Self {
                    acs_url: Ok(value.acs_url),
                    description: Ok(value.description),
                    group_attribute_name: Ok(value.group_attribute_name),
                    id: Ok(value.id),
                    idp_entity_id: Ok(value.idp_entity_id),
                    name: Ok(value.name),
                    public_cert: Ok(value.public_cert),
                    slo_url: Ok(value.slo_url),
                    sp_client_id: Ok(value.sp_client_id),
                    technical_contact_email: Ok(value.technical_contact_email),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SamlIdentityProviderCreate {
            acs_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            group_attribute_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            idp_entity_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            idp_metadata_source:
                ::std::result::Result<super::IdpMetadataSource, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            signing_keypair: ::std::result::Result<
                ::std::option::Option<super::DerEncodedKeyPair>,
                ::std::string::String,
            >,
            slo_url: ::std::result::Result<::std::string::String, ::std::string::String>,
            sp_client_id: ::std::result::Result<::std::string::String, ::std::string::String>,
            technical_contact_email:
                ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for SamlIdentityProviderCreate {
            fn default() -> Self {
                Self {
                    acs_url: Err("no value supplied for acs_url".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    group_attribute_name: Ok(Default::default()),
                    idp_entity_id: Err("no value supplied for idp_entity_id".to_string()),
                    idp_metadata_source: Err(
                        "no value supplied for idp_metadata_source".to_string()
                    ),
                    name: Err("no value supplied for name".to_string()),
                    signing_keypair: Ok(Default::default()),
                    slo_url: Err("no value supplied for slo_url".to_string()),
                    sp_client_id: Err("no value supplied for sp_client_id".to_string()),
                    technical_contact_email: Err(
                        "no value supplied for technical_contact_email".to_string()
                    ),
                }
            }
        }

        impl SamlIdentityProviderCreate {
            pub fn acs_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.acs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for acs_url: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn group_attribute_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.group_attribute_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for group_attribute_name: {}",
                        e
                    )
                });
                self
            }
            pub fn idp_entity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.idp_entity_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idp_entity_id: {}", e)
                });
                self
            }
            pub fn idp_metadata_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IdpMetadataSource>,
                T::Error: ::std::fmt::Display,
            {
                self.idp_metadata_source = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for idp_metadata_source: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn signing_keypair<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::DerEncodedKeyPair>>,
                T::Error: ::std::fmt::Display,
            {
                self.signing_keypair = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signing_keypair: {}", e)
                });
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {}", e));
                self
            }
            pub fn sp_client_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.sp_client_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sp_client_id: {}", e)
                });
                self
            }
            pub fn technical_contact_email<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.technical_contact_email = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for technical_contact_email: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SamlIdentityProviderCreate> for super::SamlIdentityProviderCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SamlIdentityProviderCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    acs_url: value.acs_url?,
                    description: value.description?,
                    group_attribute_name: value.group_attribute_name?,
                    idp_entity_id: value.idp_entity_id?,
                    idp_metadata_source: value.idp_metadata_source?,
                    name: value.name?,
                    signing_keypair: value.signing_keypair?,
                    slo_url: value.slo_url?,
                    sp_client_id: value.sp_client_id?,
                    technical_contact_email: value.technical_contact_email?,
                })
            }
        }

        impl ::std::convert::From<super::SamlIdentityProviderCreate> for SamlIdentityProviderCreate {
            fn from(value: super::SamlIdentityProviderCreate) -> Self {
                Self {
                    acs_url: Ok(value.acs_url),
                    description: Ok(value.description),
                    group_attribute_name: Ok(value.group_attribute_name),
                    idp_entity_id: Ok(value.idp_entity_id),
                    idp_metadata_source: Ok(value.idp_metadata_source),
                    name: Ok(value.name),
                    signing_keypair: Ok(value.signing_keypair),
                    slo_url: Ok(value.slo_url),
                    sp_client_id: Ok(value.sp_client_id),
                    technical_contact_email: Ok(value.technical_contact_email),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SetTargetReleaseParams {
            system_version: ::std::result::Result<
                super::SetTargetReleaseParamsSystemVersion,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SetTargetReleaseParams {
            fn default() -> Self {
                Self {
                    system_version: Err("no value supplied for system_version".to_string()),
                }
            }
        }

        impl SetTargetReleaseParams {
            pub fn system_version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SetTargetReleaseParamsSystemVersion>,
                T::Error: ::std::fmt::Display,
            {
                self.system_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for system_version: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SetTargetReleaseParams> for super::SetTargetReleaseParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SetTargetReleaseParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    system_version: value.system_version?,
                })
            }
        }

        impl ::std::convert::From<super::SetTargetReleaseParams> for SetTargetReleaseParams {
            fn from(value: super::SetTargetReleaseParams) -> Self {
                Self {
                    system_version: Ok(value.system_version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Silo {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            discoverable: ::std::result::Result<bool, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            identity_mode: ::std::result::Result<super::SiloIdentityMode, ::std::string::String>,
            mapped_fleet_roles: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, Vec<super::FleetRole>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Silo {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    discoverable: Err("no value supplied for discoverable".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    identity_mode: Err("no value supplied for identity_mode".to_string()),
                    mapped_fleet_roles: Err("no value supplied for mapped_fleet_roles".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Silo {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn discoverable<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.discoverable = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discoverable: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn identity_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SiloIdentityMode>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_mode: {}", e)
                });
                self
            }
            pub fn mapped_fleet_roles<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, Vec<super::FleetRole>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mapped_fleet_roles = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for mapped_fleet_roles: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Silo> for super::Silo {
            type Error = super::error::ConversionError;
            fn try_from(value: Silo) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    discoverable: value.discoverable?,
                    id: value.id?,
                    identity_mode: value.identity_mode?,
                    mapped_fleet_roles: value.mapped_fleet_roles?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Silo> for Silo {
            fn from(value: super::Silo) -> Self {
                Self {
                    description: Ok(value.description),
                    discoverable: Ok(value.discoverable),
                    id: Ok(value.id),
                    identity_mode: Ok(value.identity_mode),
                    mapped_fleet_roles: Ok(value.mapped_fleet_roles),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloCreate {
            admin_group_name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            discoverable: ::std::result::Result<bool, ::std::string::String>,
            identity_mode: ::std::result::Result<super::SiloIdentityMode, ::std::string::String>,
            mapped_fleet_roles: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, Vec<super::FleetRole>>,
                ::std::string::String,
            >,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            quotas: ::std::result::Result<super::SiloQuotasCreate, ::std::string::String>,
            tls_certificates: ::std::result::Result<
                ::std::vec::Vec<super::CertificateCreate>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloCreate {
            fn default() -> Self {
                Self {
                    admin_group_name: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    discoverable: Err("no value supplied for discoverable".to_string()),
                    identity_mode: Err("no value supplied for identity_mode".to_string()),
                    mapped_fleet_roles: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    quotas: Err("no value supplied for quotas".to_string()),
                    tls_certificates: Err("no value supplied for tls_certificates".to_string()),
                }
            }
        }

        impl SiloCreate {
            pub fn admin_group_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.admin_group_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for admin_group_name: {}",
                        e
                    )
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn discoverable<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.discoverable = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discoverable: {}", e)
                });
                self
            }
            pub fn identity_mode<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SiloIdentityMode>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_mode: {}", e)
                });
                self
            }
            pub fn mapped_fleet_roles<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, Vec<super::FleetRole>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.mapped_fleet_roles = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for mapped_fleet_roles: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn quotas<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SiloQuotasCreate>,
                T::Error: ::std::fmt::Display,
            {
                self.quotas = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for quotas: {}", e));
                self
            }
            pub fn tls_certificates<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::CertificateCreate>>,
                T::Error: ::std::fmt::Display,
            {
                self.tls_certificates = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for tls_certificates: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SiloCreate> for super::SiloCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    admin_group_name: value.admin_group_name?,
                    description: value.description?,
                    discoverable: value.discoverable?,
                    identity_mode: value.identity_mode?,
                    mapped_fleet_roles: value.mapped_fleet_roles?,
                    name: value.name?,
                    quotas: value.quotas?,
                    tls_certificates: value.tls_certificates?,
                })
            }
        }

        impl ::std::convert::From<super::SiloCreate> for SiloCreate {
            fn from(value: super::SiloCreate) -> Self {
                Self {
                    admin_group_name: Ok(value.admin_group_name),
                    description: Ok(value.description),
                    discoverable: Ok(value.discoverable),
                    identity_mode: Ok(value.identity_mode),
                    mapped_fleet_roles: Ok(value.mapped_fleet_roles),
                    name: Ok(value.name),
                    quotas: Ok(value.quotas),
                    tls_certificates: Ok(value.tls_certificates),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloIpPool {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            is_default: ::std::result::Result<bool, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloIpPool {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    is_default: Err("no value supplied for is_default".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SiloIpPool {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn is_default<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.is_default = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for is_default: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SiloIpPool> for super::SiloIpPool {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloIpPool,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    is_default: value.is_default?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::SiloIpPool> for SiloIpPool {
            fn from(value: super::SiloIpPool) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    is_default: Ok(value.is_default),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloIpPoolResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::SiloIpPool>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloIpPoolResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SiloIpPoolResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SiloIpPool>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloIpPoolResultsPage> for super::SiloIpPoolResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloIpPoolResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SiloIpPoolResultsPage> for SiloIpPoolResultsPage {
            fn from(value: super::SiloIpPoolResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloQuotas {
            cpus: ::std::result::Result<i64, ::std::string::String>,
            memory: ::std::result::Result<super::ByteCount, ::std::string::String>,
            silo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            storage: ::std::result::Result<super::ByteCount, ::std::string::String>,
        }

        impl ::std::default::Default for SiloQuotas {
            fn default() -> Self {
                Self {
                    cpus: Err("no value supplied for cpus".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                    storage: Err("no value supplied for storage".to_string()),
                }
            }
        }

        impl SiloQuotas {
            pub fn cpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.cpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cpus: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
            pub fn storage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.storage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloQuotas> for super::SiloQuotas {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloQuotas,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpus: value.cpus?,
                    memory: value.memory?,
                    silo_id: value.silo_id?,
                    storage: value.storage?,
                })
            }
        }

        impl ::std::convert::From<super::SiloQuotas> for SiloQuotas {
            fn from(value: super::SiloQuotas) -> Self {
                Self {
                    cpus: Ok(value.cpus),
                    memory: Ok(value.memory),
                    silo_id: Ok(value.silo_id),
                    storage: Ok(value.storage),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloQuotasCreate {
            cpus: ::std::result::Result<i64, ::std::string::String>,
            memory: ::std::result::Result<super::ByteCount, ::std::string::String>,
            storage: ::std::result::Result<super::ByteCount, ::std::string::String>,
        }

        impl ::std::default::Default for SiloQuotasCreate {
            fn default() -> Self {
                Self {
                    cpus: Err("no value supplied for cpus".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    storage: Err("no value supplied for storage".to_string()),
                }
            }
        }

        impl SiloQuotasCreate {
            pub fn cpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.cpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cpus: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn storage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.storage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloQuotasCreate> for super::SiloQuotasCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloQuotasCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpus: value.cpus?,
                    memory: value.memory?,
                    storage: value.storage?,
                })
            }
        }

        impl ::std::convert::From<super::SiloQuotasCreate> for SiloQuotasCreate {
            fn from(value: super::SiloQuotasCreate) -> Self {
                Self {
                    cpus: Ok(value.cpus),
                    memory: Ok(value.memory),
                    storage: Ok(value.storage),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloQuotasResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::SiloQuotas>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloQuotasResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SiloQuotasResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SiloQuotas>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloQuotasResultsPage> for super::SiloQuotasResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloQuotasResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SiloQuotasResultsPage> for SiloQuotasResultsPage {
            fn from(value: super::SiloQuotasResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloQuotasUpdate {
            cpus: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
            memory: ::std::result::Result<
                ::std::option::Option<super::ByteCount>,
                ::std::string::String,
            >,
            storage: ::std::result::Result<
                ::std::option::Option<super::ByteCount>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloQuotasUpdate {
            fn default() -> Self {
                Self {
                    cpus: Ok(Default::default()),
                    memory: Ok(Default::default()),
                    storage: Ok(Default::default()),
                }
            }
        }

        impl SiloQuotasUpdate {
            pub fn cpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i64>>,
                T::Error: ::std::fmt::Display,
            {
                self.cpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cpus: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::ByteCount>>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn storage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::ByteCount>>,
                T::Error: ::std::fmt::Display,
            {
                self.storage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloQuotasUpdate> for super::SiloQuotasUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloQuotasUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpus: value.cpus?,
                    memory: value.memory?,
                    storage: value.storage?,
                })
            }
        }

        impl ::std::convert::From<super::SiloQuotasUpdate> for SiloQuotasUpdate {
            fn from(value: super::SiloQuotasUpdate) -> Self {
                Self {
                    cpus: Ok(value.cpus),
                    memory: Ok(value.memory),
                    storage: Ok(value.storage),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Silo>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SiloResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Silo>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloResultsPage> for super::SiloResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SiloResultsPage> for SiloResultsPage {
            fn from(value: super::SiloResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloRolePolicy {
            role_assignments: ::std::result::Result<
                ::std::vec::Vec<super::SiloRoleRoleAssignment>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl SiloRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SiloRoleRoleAssignment>>,
                T::Error: ::std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SiloRolePolicy> for super::SiloRolePolicy {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloRolePolicy,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        impl ::std::convert::From<super::SiloRolePolicy> for SiloRolePolicy {
            fn from(value: super::SiloRolePolicy) -> Self {
                Self {
                    role_assignments: Ok(value.role_assignments),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloRoleRoleAssignment {
            identity_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            identity_type: ::std::result::Result<super::IdentityType, ::std::string::String>,
            role_name: ::std::result::Result<super::SiloRole, ::std::string::String>,
        }

        impl ::std::default::Default for SiloRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl SiloRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IdentityType>,
                T::Error: ::std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SiloRole>,
                T::Error: ::std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloRoleRoleAssignment> for super::SiloRoleRoleAssignment {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloRoleRoleAssignment,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        impl ::std::convert::From<super::SiloRoleRoleAssignment> for SiloRoleRoleAssignment {
            fn from(value: super::SiloRoleRoleAssignment) -> Self {
                Self {
                    identity_id: Ok(value.identity_id),
                    identity_type: Ok(value.identity_type),
                    role_name: Ok(value.role_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloUtilization {
            allocated: ::std::result::Result<super::VirtualResourceCounts, ::std::string::String>,
            provisioned: ::std::result::Result<super::VirtualResourceCounts, ::std::string::String>,
            silo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            silo_name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for SiloUtilization {
            fn default() -> Self {
                Self {
                    allocated: Err("no value supplied for allocated".to_string()),
                    provisioned: Err("no value supplied for provisioned".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                    silo_name: Err("no value supplied for silo_name".to_string()),
                }
            }
        }

        impl SiloUtilization {
            pub fn allocated<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VirtualResourceCounts>,
                T::Error: ::std::fmt::Display,
            {
                self.allocated = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for allocated: {}", e));
                self
            }
            pub fn provisioned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VirtualResourceCounts>,
                T::Error: ::std::fmt::Display,
            {
                self.provisioned = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for provisioned: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
            pub fn silo_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloUtilization> for super::SiloUtilization {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloUtilization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    allocated: value.allocated?,
                    provisioned: value.provisioned?,
                    silo_id: value.silo_id?,
                    silo_name: value.silo_name?,
                })
            }
        }

        impl ::std::convert::From<super::SiloUtilization> for SiloUtilization {
            fn from(value: super::SiloUtilization) -> Self {
                Self {
                    allocated: Ok(value.allocated),
                    provisioned: Ok(value.provisioned),
                    silo_id: Ok(value.silo_id),
                    silo_name: Ok(value.silo_name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SiloUtilizationResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::SiloUtilization>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SiloUtilizationResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SiloUtilizationResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SiloUtilization>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SiloUtilizationResultsPage> for super::SiloUtilizationResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SiloUtilizationResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SiloUtilizationResultsPage> for SiloUtilizationResultsPage {
            fn from(value: super::SiloUtilizationResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Sled {
            baseboard: ::std::result::Result<super::Baseboard, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            policy: ::std::result::Result<super::SledPolicy, ::std::string::String>,
            rack_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            state: ::std::result::Result<super::SledState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            usable_hardware_threads: ::std::result::Result<u32, ::std::string::String>,
            usable_physical_ram: ::std::result::Result<super::ByteCount, ::std::string::String>,
        }

        impl ::std::default::Default for Sled {
            fn default() -> Self {
                Self {
                    baseboard: Err("no value supplied for baseboard".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    policy: Err("no value supplied for policy".to_string()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    usable_hardware_threads: Err(
                        "no value supplied for usable_hardware_threads".to_string()
                    ),
                    usable_physical_ram: Err(
                        "no value supplied for usable_physical_ram".to_string()
                    ),
                }
            }
        }

        impl Sled {
            pub fn baseboard<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Baseboard>,
                T::Error: ::std::fmt::Display,
            {
                self.baseboard = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for baseboard: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn policy<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SledPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.policy = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for policy: {}", e));
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SledState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn usable_hardware_threads<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.usable_hardware_threads = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for usable_hardware_threads: {}",
                        e
                    )
                });
                self
            }
            pub fn usable_physical_ram<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.usable_physical_ram = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for usable_physical_ram: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Sled> for super::Sled {
            type Error = super::error::ConversionError;
            fn try_from(value: Sled) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    baseboard: value.baseboard?,
                    id: value.id?,
                    policy: value.policy?,
                    rack_id: value.rack_id?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    usable_hardware_threads: value.usable_hardware_threads?,
                    usable_physical_ram: value.usable_physical_ram?,
                })
            }
        }

        impl ::std::convert::From<super::Sled> for Sled {
            fn from(value: super::Sled) -> Self {
                Self {
                    baseboard: Ok(value.baseboard),
                    id: Ok(value.id),
                    policy: Ok(value.policy),
                    rack_id: Ok(value.rack_id),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    usable_hardware_threads: Ok(value.usable_hardware_threads),
                    usable_physical_ram: Ok(value.usable_physical_ram),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledId {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for SledId {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                }
            }
        }

        impl SledId {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SledId> for super::SledId {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SledId,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { id: value.id? })
            }
        }

        impl ::std::convert::From<super::SledId> for SledId {
            fn from(value: super::SledId) -> Self {
                Self { id: Ok(value.id) }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledInstance {
            active_sled_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            memory: ::std::result::Result<i64, ::std::string::String>,
            migration_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            ncpus: ::std::result::Result<i64, ::std::string::String>,
            project_name: ::std::result::Result<super::Name, ::std::string::String>,
            silo_name: ::std::result::Result<super::Name, ::std::string::String>,
            state: ::std::result::Result<super::InstanceState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SledInstance {
            fn default() -> Self {
                Self {
                    active_sled_id: Err("no value supplied for active_sled_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    migration_id: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    project_name: Err("no value supplied for project_name".to_string()),
                    silo_name: Err("no value supplied for silo_name".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SledInstance {
            pub fn active_sled_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.active_sled_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for active_sled_id: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn migration_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.migration_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for migration_id: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn project_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.project_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for project_name: {}", e)
                });
                self
            }
            pub fn silo_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_name: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::InstanceState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SledInstance> for super::SledInstance {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SledInstance,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    active_sled_id: value.active_sled_id?,
                    id: value.id?,
                    memory: value.memory?,
                    migration_id: value.migration_id?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    project_name: value.project_name?,
                    silo_name: value.silo_name?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::SledInstance> for SledInstance {
            fn from(value: super::SledInstance) -> Self {
                Self {
                    active_sled_id: Ok(value.active_sled_id),
                    id: Ok(value.id),
                    memory: Ok(value.memory),
                    migration_id: Ok(value.migration_id),
                    name: Ok(value.name),
                    ncpus: Ok(value.ncpus),
                    project_name: Ok(value.project_name),
                    silo_name: Ok(value.silo_name),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledInstanceResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::SledInstance>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SledInstanceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SledInstanceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SledInstance>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SledInstanceResultsPage> for super::SledInstanceResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SledInstanceResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SledInstanceResultsPage> for SledInstanceResultsPage {
            fn from(value: super::SledInstanceResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledProvisionPolicyParams {
            state: ::std::result::Result<super::SledProvisionPolicy, ::std::string::String>,
        }

        impl ::std::default::Default for SledProvisionPolicyParams {
            fn default() -> Self {
                Self {
                    state: Err("no value supplied for state".to_string()),
                }
            }
        }

        impl SledProvisionPolicyParams {
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SledProvisionPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SledProvisionPolicyParams> for super::SledProvisionPolicyParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SledProvisionPolicyParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    state: value.state?,
                })
            }
        }

        impl ::std::convert::From<super::SledProvisionPolicyParams> for SledProvisionPolicyParams {
            fn from(value: super::SledProvisionPolicyParams) -> Self {
                Self {
                    state: Ok(value.state),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledProvisionPolicyResponse {
            new_state: ::std::result::Result<super::SledProvisionPolicy, ::std::string::String>,
            old_state: ::std::result::Result<super::SledProvisionPolicy, ::std::string::String>,
        }

        impl ::std::default::Default for SledProvisionPolicyResponse {
            fn default() -> Self {
                Self {
                    new_state: Err("no value supplied for new_state".to_string()),
                    old_state: Err("no value supplied for old_state".to_string()),
                }
            }
        }

        impl SledProvisionPolicyResponse {
            pub fn new_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SledProvisionPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.new_state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for new_state: {}", e));
                self
            }
            pub fn old_state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SledProvisionPolicy>,
                T::Error: ::std::fmt::Display,
            {
                self.old_state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for old_state: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SledProvisionPolicyResponse> for super::SledProvisionPolicyResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SledProvisionPolicyResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    new_state: value.new_state?,
                    old_state: value.old_state?,
                })
            }
        }

        impl ::std::convert::From<super::SledProvisionPolicyResponse> for SledProvisionPolicyResponse {
            fn from(value: super::SledProvisionPolicyResponse) -> Self {
                Self {
                    new_state: Ok(value.new_state),
                    old_state: Ok(value.old_state),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SledResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Sled>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SledResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SledResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Sled>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SledResultsPage> for super::SledResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SledResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SledResultsPage> for SledResultsPage {
            fn from(value: super::SledResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Snapshot {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            disk_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            size: ::std::result::Result<super::ByteCount, ::std::string::String>,
            state: ::std::result::Result<super::SnapshotState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Snapshot {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk_id: Err("no value supplied for disk_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Snapshot {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.disk_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_id: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SnapshotState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Snapshot> for super::Snapshot {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Snapshot,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disk_id: value.disk_id?,
                    id: value.id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Snapshot> for Snapshot {
            fn from(value: super::Snapshot) -> Self {
                Self {
                    description: Ok(value.description),
                    disk_id: Ok(value.disk_id),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    size: Ok(value.size),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SnapshotCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            disk: ::std::result::Result<super::NameOrId, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for SnapshotCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk: Err("no value supplied for disk".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl SnapshotCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SnapshotCreate> for super::SnapshotCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SnapshotCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    disk: value.disk?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::SnapshotCreate> for SnapshotCreate {
            fn from(value: super::SnapshotCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    disk: Ok(value.disk),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SnapshotResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Snapshot>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SnapshotResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SnapshotResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Snapshot>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SnapshotResultsPage> for super::SnapshotResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SnapshotResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SnapshotResultsPage> for SnapshotResultsPage {
            fn from(value: super::SnapshotResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SshKey {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
            silo_user_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SshKey {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    silo_user_id: Err("no value supplied for silo_user_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SshKey {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn silo_user_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_user_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for silo_user_id: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SshKey> for super::SshKey {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SshKey,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    public_key: value.public_key?,
                    silo_user_id: value.silo_user_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::SshKey> for SshKey {
            fn from(value: super::SshKey) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    public_key: Ok(value.public_key),
                    silo_user_id: Ok(value.silo_user_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SshKeyCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            public_key: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for SshKeyCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                }
            }
        }

        impl SshKeyCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SshKeyCreate> for super::SshKeyCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SshKeyCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    public_key: value.public_key?,
                })
            }
        }

        impl ::std::convert::From<super::SshKeyCreate> for SshKeyCreate {
            fn from(value: super::SshKeyCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                    public_key: Ok(value.public_key),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SshKeyResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::SshKey>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SshKeyResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SshKeyResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SshKey>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SshKeyResultsPage> for super::SshKeyResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SshKeyResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SshKeyResultsPage> for SshKeyResultsPage {
            fn from(value: super::SshKeyResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SupportBundleInfo {
            id: ::std::result::Result<super::TypedUuidForSupportBundleKind, ::std::string::String>,
            reason_for_creation:
                ::std::result::Result<::std::string::String, ::std::string::String>,
            reason_for_failure: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            state: ::std::result::Result<super::SupportBundleState, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SupportBundleInfo {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    reason_for_creation: Err(
                        "no value supplied for reason_for_creation".to_string()
                    ),
                    reason_for_failure: Ok(Default::default()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                }
            }
        }

        impl SupportBundleInfo {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TypedUuidForSupportBundleKind>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn reason_for_creation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.reason_for_creation = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for reason_for_creation: {}",
                        e
                    )
                });
                self
            }
            pub fn reason_for_failure<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.reason_for_failure = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for reason_for_failure: {}",
                        e
                    )
                });
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SupportBundleState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SupportBundleInfo> for super::SupportBundleInfo {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SupportBundleInfo,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    reason_for_creation: value.reason_for_creation?,
                    reason_for_failure: value.reason_for_failure?,
                    state: value.state?,
                    time_created: value.time_created?,
                })
            }
        }

        impl ::std::convert::From<super::SupportBundleInfo> for SupportBundleInfo {
            fn from(value: super::SupportBundleInfo) -> Self {
                Self {
                    id: Ok(value.id),
                    reason_for_creation: Ok(value.reason_for_creation),
                    reason_for_failure: Ok(value.reason_for_failure),
                    state: Ok(value.state),
                    time_created: Ok(value.time_created),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SupportBundleInfoResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::SupportBundleInfo>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SupportBundleInfoResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SupportBundleInfoResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SupportBundleInfo>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SupportBundleInfoResultsPage> for super::SupportBundleInfoResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SupportBundleInfoResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SupportBundleInfoResultsPage> for SupportBundleInfoResultsPage {
            fn from(value: super::SupportBundleInfoResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Switch {
            baseboard: ::std::result::Result<super::Baseboard, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            rack_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Switch {
            fn default() -> Self {
                Self {
                    baseboard: Err("no value supplied for baseboard".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Switch {
            pub fn baseboard<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Baseboard>,
                T::Error: ::std::fmt::Display,
            {
                self.baseboard = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for baseboard: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Switch> for super::Switch {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Switch,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    baseboard: value.baseboard?,
                    id: value.id?,
                    rack_id: value.rack_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Switch> for Switch {
            fn from(value: super::Switch) -> Self {
                Self {
                    baseboard: Ok(value.baseboard),
                    id: Ok(value.id),
                    rack_id: Ok(value.rack_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchBgpHistory {
            history: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::BgpMessageHistory>,
                ::std::string::String,
            >,
            switch: ::std::result::Result<super::SwitchLocation, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchBgpHistory {
            fn default() -> Self {
                Self {
                    history: Err("no value supplied for history".to_string()),
                    switch: Err("no value supplied for switch".to_string()),
                }
            }
        }

        impl SwitchBgpHistory {
            pub fn history<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::BgpMessageHistory>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.history = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for history: {}", e));
                self
            }
            pub fn switch<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchLocation>,
                T::Error: ::std::fmt::Display,
            {
                self.switch = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for switch: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchBgpHistory> for super::SwitchBgpHistory {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchBgpHistory,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    history: value.history?,
                    switch: value.switch?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchBgpHistory> for SwitchBgpHistory {
            fn from(value: super::SwitchBgpHistory) -> Self {
                Self {
                    history: Ok(value.history),
                    switch: Ok(value.switch),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchInterfaceConfig {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            interface_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            kind: ::std::result::Result<super::SwitchInterfaceKind2, ::std::string::String>,
            port_settings_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            v6_enabled: ::std::result::Result<bool, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchInterfaceConfig {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    interface_name: Err("no value supplied for interface_name".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    port_settings_id: Err("no value supplied for port_settings_id".to_string()),
                    v6_enabled: Err("no value supplied for v6_enabled".to_string()),
                }
            }
        }

        impl SwitchInterfaceConfig {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn interface_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.interface_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for interface_name: {}", e)
                });
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchInterfaceKind2>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
            pub fn v6_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.v6_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for v6_enabled: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchInterfaceConfig> for super::SwitchInterfaceConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchInterfaceConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    interface_name: value.interface_name?,
                    kind: value.kind?,
                    port_settings_id: value.port_settings_id?,
                    v6_enabled: value.v6_enabled?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchInterfaceConfig> for SwitchInterfaceConfig {
            fn from(value: super::SwitchInterfaceConfig) -> Self {
                Self {
                    id: Ok(value.id),
                    interface_name: Ok(value.interface_name),
                    kind: Ok(value.kind),
                    port_settings_id: Ok(value.port_settings_id),
                    v6_enabled: Ok(value.v6_enabled),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchInterfaceConfigCreate {
            kind: ::std::result::Result<super::SwitchInterfaceKind, ::std::string::String>,
            v6_enabled: ::std::result::Result<bool, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchInterfaceConfigCreate {
            fn default() -> Self {
                Self {
                    kind: Err("no value supplied for kind".to_string()),
                    v6_enabled: Err("no value supplied for v6_enabled".to_string()),
                }
            }
        }

        impl SwitchInterfaceConfigCreate {
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchInterfaceKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn v6_enabled<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.v6_enabled = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for v6_enabled: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchInterfaceConfigCreate> for super::SwitchInterfaceConfigCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchInterfaceConfigCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    kind: value.kind?,
                    v6_enabled: value.v6_enabled?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchInterfaceConfigCreate> for SwitchInterfaceConfigCreate {
            fn from(value: super::SwitchInterfaceConfigCreate) -> Self {
                Self {
                    kind: Ok(value.kind),
                    v6_enabled: Ok(value.v6_enabled),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPort {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            port_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            port_settings_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            rack_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            switch_location: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPort {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    port_name: Err("no value supplied for port_name".to_string()),
                    port_settings_id: Ok(Default::default()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                    switch_location: Err("no value supplied for switch_location".to_string()),
                }
            }
        }

        impl SwitchPort {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn port_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.port_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for port_name: {}", e));
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
            pub fn switch_location<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.switch_location = value.try_into().map_err(|e| {
                    format!("error converting supplied value for switch_location: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPort> for super::SwitchPort {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPort,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    port_name: value.port_name?,
                    port_settings_id: value.port_settings_id?,
                    rack_id: value.rack_id?,
                    switch_location: value.switch_location?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPort> for SwitchPort {
            fn from(value: super::SwitchPort) -> Self {
                Self {
                    id: Ok(value.id),
                    port_name: Ok(value.port_name),
                    port_settings_id: Ok(value.port_settings_id),
                    rack_id: Ok(value.rack_id),
                    switch_location: Ok(value.switch_location),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortAddressConfig {
            address: ::std::result::Result<super::IpNet, ::std::string::String>,
            address_lot_block_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            interface_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            port_settings_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            vlan_id: ::std::result::Result<::std::option::Option<u16>, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortAddressConfig {
            fn default() -> Self {
                Self {
                    address: Err("no value supplied for address".to_string()),
                    address_lot_block_id: Err(
                        "no value supplied for address_lot_block_id".to_string()
                    ),
                    interface_name: Err("no value supplied for interface_name".to_string()),
                    port_settings_id: Err("no value supplied for port_settings_id".to_string()),
                    vlan_id: Ok(Default::default()),
                }
            }
        }

        impl SwitchPortAddressConfig {
            pub fn address<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.address = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for address: {}", e));
                self
            }
            pub fn address_lot_block_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.address_lot_block_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for address_lot_block_id: {}",
                        e
                    )
                });
                self
            }
            pub fn interface_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.interface_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for interface_name: {}", e)
                });
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
            pub fn vlan_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u16>>,
                T::Error: ::std::fmt::Display,
            {
                self.vlan_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vlan_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortAddressConfig> for super::SwitchPortAddressConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortAddressConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    address: value.address?,
                    address_lot_block_id: value.address_lot_block_id?,
                    interface_name: value.interface_name?,
                    port_settings_id: value.port_settings_id?,
                    vlan_id: value.vlan_id?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortAddressConfig> for SwitchPortAddressConfig {
            fn from(value: super::SwitchPortAddressConfig) -> Self {
                Self {
                    address: Ok(value.address),
                    address_lot_block_id: Ok(value.address_lot_block_id),
                    interface_name: Ok(value.interface_name),
                    port_settings_id: Ok(value.port_settings_id),
                    vlan_id: Ok(value.vlan_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortApplySettings {
            port_settings: ::std::result::Result<super::NameOrId, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortApplySettings {
            fn default() -> Self {
                Self {
                    port_settings: Err("no value supplied for port_settings".to_string()),
                }
            }
        }

        impl SwitchPortApplySettings {
            pub fn port_settings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::NameOrId>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings = value.try_into().map_err(|e| {
                    format!("error converting supplied value for port_settings: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortApplySettings> for super::SwitchPortApplySettings {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortApplySettings,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    port_settings: value.port_settings?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortApplySettings> for SwitchPortApplySettings {
            fn from(value: super::SwitchPortApplySettings) -> Self {
                Self {
                    port_settings: Ok(value.port_settings),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortConfig {
            geometry: ::std::result::Result<super::SwitchPortGeometry2, ::std::string::String>,
            port_settings_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortConfig {
            fn default() -> Self {
                Self {
                    geometry: Err("no value supplied for geometry".to_string()),
                    port_settings_id: Err("no value supplied for port_settings_id".to_string()),
                }
            }
        }

        impl SwitchPortConfig {
            pub fn geometry<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchPortGeometry2>,
                T::Error: ::std::fmt::Display,
            {
                self.geometry = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for geometry: {}", e));
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortConfig> for super::SwitchPortConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    geometry: value.geometry?,
                    port_settings_id: value.port_settings_id?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortConfig> for SwitchPortConfig {
            fn from(value: super::SwitchPortConfig) -> Self {
                Self {
                    geometry: Ok(value.geometry),
                    port_settings_id: Ok(value.port_settings_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortConfigCreate {
            geometry: ::std::result::Result<super::SwitchPortGeometry, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortConfigCreate {
            fn default() -> Self {
                Self {
                    geometry: Err("no value supplied for geometry".to_string()),
                }
            }
        }

        impl SwitchPortConfigCreate {
            pub fn geometry<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchPortGeometry>,
                T::Error: ::std::fmt::Display,
            {
                self.geometry = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for geometry: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortConfigCreate> for super::SwitchPortConfigCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortConfigCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    geometry: value.geometry?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortConfigCreate> for SwitchPortConfigCreate {
            fn from(value: super::SwitchPortConfigCreate) -> Self {
                Self {
                    geometry: Ok(value.geometry),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortLinkConfig {
            autoneg: ::std::result::Result<bool, ::std::string::String>,
            fec:
                ::std::result::Result<::std::option::Option<super::LinkFec>, ::std::string::String>,
            link_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            lldp_link_config_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            mtu: ::std::result::Result<u16, ::std::string::String>,
            port_settings_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            speed: ::std::result::Result<super::LinkSpeed, ::std::string::String>,
            tx_eq_config_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortLinkConfig {
            fn default() -> Self {
                Self {
                    autoneg: Err("no value supplied for autoneg".to_string()),
                    fec: Ok(Default::default()),
                    link_name: Err("no value supplied for link_name".to_string()),
                    lldp_link_config_id: Ok(Default::default()),
                    mtu: Err("no value supplied for mtu".to_string()),
                    port_settings_id: Err("no value supplied for port_settings_id".to_string()),
                    speed: Err("no value supplied for speed".to_string()),
                    tx_eq_config_id: Ok(Default::default()),
                }
            }
        }

        impl SwitchPortLinkConfig {
            pub fn autoneg<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<bool>,
                T::Error: ::std::fmt::Display,
            {
                self.autoneg = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for autoneg: {}", e));
                self
            }
            pub fn fec<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::LinkFec>>,
                T::Error: ::std::fmt::Display,
            {
                self.fec = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fec: {}", e));
                self
            }
            pub fn link_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.link_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for link_name: {}", e));
                self
            }
            pub fn lldp_link_config_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.lldp_link_config_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for lldp_link_config_id: {}",
                        e
                    )
                });
                self
            }
            pub fn mtu<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.mtu = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mtu: {}", e));
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
            pub fn speed<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::LinkSpeed>,
                T::Error: ::std::fmt::Display,
            {
                self.speed = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for speed: {}", e));
                self
            }
            pub fn tx_eq_config_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.tx_eq_config_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for tx_eq_config_id: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortLinkConfig> for super::SwitchPortLinkConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortLinkConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    autoneg: value.autoneg?,
                    fec: value.fec?,
                    link_name: value.link_name?,
                    lldp_link_config_id: value.lldp_link_config_id?,
                    mtu: value.mtu?,
                    port_settings_id: value.port_settings_id?,
                    speed: value.speed?,
                    tx_eq_config_id: value.tx_eq_config_id?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortLinkConfig> for SwitchPortLinkConfig {
            fn from(value: super::SwitchPortLinkConfig) -> Self {
                Self {
                    autoneg: Ok(value.autoneg),
                    fec: Ok(value.fec),
                    link_name: Ok(value.link_name),
                    lldp_link_config_id: Ok(value.lldp_link_config_id),
                    mtu: Ok(value.mtu),
                    port_settings_id: Ok(value.port_settings_id),
                    speed: Ok(value.speed),
                    tx_eq_config_id: Ok(value.tx_eq_config_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::SwitchPort>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SwitchPortResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SwitchPortResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchPort>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortResultsPage> for super::SwitchPortResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortResultsPage> for SwitchPortResultsPage {
            fn from(value: super::SwitchPortResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortRouteConfig {
            dst: ::std::result::Result<super::IpNet, ::std::string::String>,
            gw: ::std::result::Result<super::IpNet, ::std::string::String>,
            interface_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            port_settings_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            rib_priority: ::std::result::Result<::std::option::Option<u8>, ::std::string::String>,
            vlan_id: ::std::result::Result<::std::option::Option<u16>, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortRouteConfig {
            fn default() -> Self {
                Self {
                    dst: Err("no value supplied for dst".to_string()),
                    gw: Err("no value supplied for gw".to_string()),
                    interface_name: Err("no value supplied for interface_name".to_string()),
                    port_settings_id: Err("no value supplied for port_settings_id".to_string()),
                    rib_priority: Ok(Default::default()),
                    vlan_id: Ok(Default::default()),
                }
            }
        }

        impl SwitchPortRouteConfig {
            pub fn dst<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.dst = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dst: {}", e));
                self
            }
            pub fn gw<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::IpNet>,
                T::Error: ::std::fmt::Display,
            {
                self.gw = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for gw: {}", e));
                self
            }
            pub fn interface_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.interface_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for interface_name: {}", e)
                });
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
            pub fn rib_priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u8>>,
                T::Error: ::std::fmt::Display,
            {
                self.rib_priority = value.try_into().map_err(|e| {
                    format!("error converting supplied value for rib_priority: {}", e)
                });
                self
            }
            pub fn vlan_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u16>>,
                T::Error: ::std::fmt::Display,
            {
                self.vlan_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vlan_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortRouteConfig> for super::SwitchPortRouteConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortRouteConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    dst: value.dst?,
                    gw: value.gw?,
                    interface_name: value.interface_name?,
                    port_settings_id: value.port_settings_id?,
                    rib_priority: value.rib_priority?,
                    vlan_id: value.vlan_id?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortRouteConfig> for SwitchPortRouteConfig {
            fn from(value: super::SwitchPortRouteConfig) -> Self {
                Self {
                    dst: Ok(value.dst),
                    gw: Ok(value.gw),
                    interface_name: Ok(value.interface_name),
                    port_settings_id: Ok(value.port_settings_id),
                    rib_priority: Ok(value.rib_priority),
                    vlan_id: Ok(value.vlan_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortSettings {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SwitchPortSettings {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SwitchPortSettings {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortSettings> for super::SwitchPortSettings {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortSettings,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortSettings> for SwitchPortSettings {
            fn from(value: super::SwitchPortSettings) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortSettingsCreate {
            addresses: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::AddressConfig>,
                ::std::string::String,
            >,
            bgp_peers: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::BgpPeerConfig>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            groups: ::std::result::Result<::std::vec::Vec<super::NameOrId>, ::std::string::String>,
            interfaces: ::std::result::Result<
                ::std::collections::HashMap<
                    ::std::string::String,
                    super::SwitchInterfaceConfigCreate,
                >,
                ::std::string::String,
            >,
            links: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::LinkConfigCreate>,
                ::std::string::String,
            >,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            port_config:
                ::std::result::Result<super::SwitchPortConfigCreate, ::std::string::String>,
            routes: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::RouteConfig>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SwitchPortSettingsCreate {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    bgp_peers: Err("no value supplied for bgp_peers".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    groups: Err("no value supplied for groups".to_string()),
                    interfaces: Err("no value supplied for interfaces".to_string()),
                    links: Err("no value supplied for links".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    port_config: Err("no value supplied for port_config".to_string()),
                    routes: Err("no value supplied for routes".to_string()),
                }
            }
        }

        impl SwitchPortSettingsCreate {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::AddressConfig>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn bgp_peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::BgpPeerConfig>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.bgp_peers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bgp_peers: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn groups<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.groups = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for groups: {}", e));
                self
            }
            pub fn interfaces<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<
                        ::std::string::String,
                        super::SwitchInterfaceConfigCreate,
                    >,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.interfaces = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for interfaces: {}", e));
                self
            }
            pub fn links<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::LinkConfigCreate>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.links = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for links: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn port_config<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchPortConfigCreate>,
                T::Error: ::std::fmt::Display,
            {
                self.port_config = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for port_config: {}", e));
                self
            }
            pub fn routes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::RouteConfig>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.routes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for routes: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortSettingsCreate> for super::SwitchPortSettingsCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortSettingsCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    bgp_peers: value.bgp_peers?,
                    description: value.description?,
                    groups: value.groups?,
                    interfaces: value.interfaces?,
                    links: value.links?,
                    name: value.name?,
                    port_config: value.port_config?,
                    routes: value.routes?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortSettingsCreate> for SwitchPortSettingsCreate {
            fn from(value: super::SwitchPortSettingsCreate) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    bgp_peers: Ok(value.bgp_peers),
                    description: Ok(value.description),
                    groups: Ok(value.groups),
                    interfaces: Ok(value.interfaces),
                    links: Ok(value.links),
                    name: Ok(value.name),
                    port_config: Ok(value.port_config),
                    routes: Ok(value.routes),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortSettingsGroups {
            port_settings_group_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            port_settings_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchPortSettingsGroups {
            fn default() -> Self {
                Self {
                    port_settings_group_id: Err(
                        "no value supplied for port_settings_group_id".to_string()
                    ),
                    port_settings_id: Err("no value supplied for port_settings_id".to_string()),
                }
            }
        }

        impl SwitchPortSettingsGroups {
            pub fn port_settings_group_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_group_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_group_id: {}",
                        e
                    )
                });
                self
            }
            pub fn port_settings_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.port_settings_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for port_settings_id: {}",
                        e
                    )
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortSettingsGroups> for super::SwitchPortSettingsGroups {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortSettingsGroups,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    port_settings_group_id: value.port_settings_group_id?,
                    port_settings_id: value.port_settings_id?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortSettingsGroups> for SwitchPortSettingsGroups {
            fn from(value: super::SwitchPortSettingsGroups) -> Self {
                Self {
                    port_settings_group_id: Ok(value.port_settings_group_id),
                    port_settings_id: Ok(value.port_settings_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortSettingsResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::SwitchPortSettings>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SwitchPortSettingsResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SwitchPortSettingsResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchPortSettings>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortSettingsResultsPage>
            for super::SwitchPortSettingsResultsPage
        {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortSettingsResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortSettingsResultsPage> for SwitchPortSettingsResultsPage {
            fn from(value: super::SwitchPortSettingsResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchPortSettingsView {
            addresses: ::std::result::Result<
                ::std::vec::Vec<super::SwitchPortAddressConfig>,
                ::std::string::String,
            >,
            bgp_peers:
                ::std::result::Result<::std::vec::Vec<super::BgpPeer>, ::std::string::String>,
            groups: ::std::result::Result<
                ::std::vec::Vec<super::SwitchPortSettingsGroups>,
                ::std::string::String,
            >,
            interfaces: ::std::result::Result<
                ::std::vec::Vec<super::SwitchInterfaceConfig>,
                ::std::string::String,
            >,
            link_lldp: ::std::result::Result<
                ::std::vec::Vec<super::LldpLinkConfig>,
                ::std::string::String,
            >,
            links: ::std::result::Result<
                ::std::vec::Vec<super::SwitchPortLinkConfig>,
                ::std::string::String,
            >,
            port: ::std::result::Result<super::SwitchPortConfig, ::std::string::String>,
            routes: ::std::result::Result<
                ::std::vec::Vec<super::SwitchPortRouteConfig>,
                ::std::string::String,
            >,
            settings: ::std::result::Result<super::SwitchPortSettings, ::std::string::String>,
            tx_eq: ::std::result::Result<
                ::std::vec::Vec<::std::option::Option<super::TxEqConfig>>,
                ::std::string::String,
            >,
            vlan_interfaces: ::std::result::Result<
                ::std::vec::Vec<super::SwitchVlanInterfaceConfig>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SwitchPortSettingsView {
            fn default() -> Self {
                Self {
                    addresses: Err("no value supplied for addresses".to_string()),
                    bgp_peers: Err("no value supplied for bgp_peers".to_string()),
                    groups: Err("no value supplied for groups".to_string()),
                    interfaces: Err("no value supplied for interfaces".to_string()),
                    link_lldp: Err("no value supplied for link_lldp".to_string()),
                    links: Err("no value supplied for links".to_string()),
                    port: Err("no value supplied for port".to_string()),
                    routes: Err("no value supplied for routes".to_string()),
                    settings: Err("no value supplied for settings".to_string()),
                    tx_eq: Err("no value supplied for tx_eq".to_string()),
                    vlan_interfaces: Err("no value supplied for vlan_interfaces".to_string()),
                }
            }
        }

        impl SwitchPortSettingsView {
            pub fn addresses<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchPortAddressConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.addresses = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for addresses: {}", e));
                self
            }
            pub fn bgp_peers<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::BgpPeer>>,
                T::Error: ::std::fmt::Display,
            {
                self.bgp_peers = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bgp_peers: {}", e));
                self
            }
            pub fn groups<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchPortSettingsGroups>>,
                T::Error: ::std::fmt::Display,
            {
                self.groups = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for groups: {}", e));
                self
            }
            pub fn interfaces<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchInterfaceConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.interfaces = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for interfaces: {}", e));
                self
            }
            pub fn link_lldp<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::LldpLinkConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.link_lldp = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for link_lldp: {}", e));
                self
            }
            pub fn links<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchPortLinkConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.links = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for links: {}", e));
                self
            }
            pub fn port<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchPortConfig>,
                T::Error: ::std::fmt::Display,
            {
                self.port = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for port: {}", e));
                self
            }
            pub fn routes<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchPortRouteConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.routes = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for routes: {}", e));
                self
            }
            pub fn settings<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::SwitchPortSettings>,
                T::Error: ::std::fmt::Display,
            {
                self.settings = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for settings: {}", e));
                self
            }
            pub fn tx_eq<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::vec::Vec<::std::option::Option<super::TxEqConfig>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.tx_eq = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tx_eq: {}", e));
                self
            }
            pub fn vlan_interfaces<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::SwitchVlanInterfaceConfig>>,
                T::Error: ::std::fmt::Display,
            {
                self.vlan_interfaces = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vlan_interfaces: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchPortSettingsView> for super::SwitchPortSettingsView {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchPortSettingsView,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    addresses: value.addresses?,
                    bgp_peers: value.bgp_peers?,
                    groups: value.groups?,
                    interfaces: value.interfaces?,
                    link_lldp: value.link_lldp?,
                    links: value.links?,
                    port: value.port?,
                    routes: value.routes?,
                    settings: value.settings?,
                    tx_eq: value.tx_eq?,
                    vlan_interfaces: value.vlan_interfaces?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchPortSettingsView> for SwitchPortSettingsView {
            fn from(value: super::SwitchPortSettingsView) -> Self {
                Self {
                    addresses: Ok(value.addresses),
                    bgp_peers: Ok(value.bgp_peers),
                    groups: Ok(value.groups),
                    interfaces: Ok(value.interfaces),
                    link_lldp: Ok(value.link_lldp),
                    links: Ok(value.links),
                    port: Ok(value.port),
                    routes: Ok(value.routes),
                    settings: Ok(value.settings),
                    tx_eq: Ok(value.tx_eq),
                    vlan_interfaces: Ok(value.vlan_interfaces),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Switch>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for SwitchResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SwitchResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Switch>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchResultsPage> for super::SwitchResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchResultsPage> for SwitchResultsPage {
            fn from(value: super::SwitchResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct SwitchVlanInterfaceConfig {
            interface_config_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            vlan_id: ::std::result::Result<u16, ::std::string::String>,
        }

        impl ::std::default::Default for SwitchVlanInterfaceConfig {
            fn default() -> Self {
                Self {
                    interface_config_id: Err(
                        "no value supplied for interface_config_id".to_string()
                    ),
                    vlan_id: Err("no value supplied for vlan_id".to_string()),
                }
            }
        }

        impl SwitchVlanInterfaceConfig {
            pub fn interface_config_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.interface_config_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for interface_config_id: {}",
                        e
                    )
                });
                self
            }
            pub fn vlan_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.vlan_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vlan_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<SwitchVlanInterfaceConfig> for super::SwitchVlanInterfaceConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: SwitchVlanInterfaceConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    interface_config_id: value.interface_config_id?,
                    vlan_id: value.vlan_id?,
                })
            }
        }

        impl ::std::convert::From<super::SwitchVlanInterfaceConfig> for SwitchVlanInterfaceConfig {
            fn from(value: super::SwitchVlanInterfaceConfig) -> Self {
                Self {
                    interface_config_id: Ok(value.interface_config_id),
                    vlan_id: Ok(value.vlan_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Table {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            timeseries: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::Timeseries>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Table {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    timeseries: Err("no value supplied for timeseries".to_string()),
                }
            }
        }

        impl Table {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn timeseries<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::Timeseries>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.timeseries = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for timeseries: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Table> for super::Table {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Table,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    name: value.name?,
                    timeseries: value.timeseries?,
                })
            }
        }

        impl ::std::convert::From<super::Table> for Table {
            fn from(value: super::Table) -> Self {
                Self {
                    name: Ok(value.name),
                    timeseries: Ok(value.timeseries),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TargetRelease {
            generation: ::std::result::Result<i64, ::std::string::String>,
            release_source:
                ::std::result::Result<super::TargetReleaseSource, ::std::string::String>,
            time_requested: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for TargetRelease {
            fn default() -> Self {
                Self {
                    generation: Err("no value supplied for generation".to_string()),
                    release_source: Err("no value supplied for release_source".to_string()),
                    time_requested: Err("no value supplied for time_requested".to_string()),
                }
            }
        }

        impl TargetRelease {
            pub fn generation<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.generation = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for generation: {}", e));
                self
            }
            pub fn release_source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TargetReleaseSource>,
                T::Error: ::std::fmt::Display,
            {
                self.release_source = value.try_into().map_err(|e| {
                    format!("error converting supplied value for release_source: {}", e)
                });
                self
            }
            pub fn time_requested<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_requested = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_requested: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<TargetRelease> for super::TargetRelease {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TargetRelease,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    generation: value.generation?,
                    release_source: value.release_source?,
                    time_requested: value.time_requested?,
                })
            }
        }

        impl ::std::convert::From<super::TargetRelease> for TargetRelease {
            fn from(value: super::TargetRelease) -> Self {
                Self {
                    generation: Ok(value.generation),
                    release_source: Ok(value.release_source),
                    time_requested: Ok(value.time_requested),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Timeseries {
            fields: ::std::result::Result<
                ::std::collections::HashMap<::std::string::String, super::FieldValue>,
                ::std::string::String,
            >,
            points: ::std::result::Result<super::Points, ::std::string::String>,
        }

        impl ::std::default::Default for Timeseries {
            fn default() -> Self {
                Self {
                    fields: Err("no value supplied for fields".to_string()),
                    points: Err("no value supplied for points".to_string()),
                }
            }
        }

        impl Timeseries {
            pub fn fields<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::collections::HashMap<::std::string::String, super::FieldValue>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.fields = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for fields: {}", e));
                self
            }
            pub fn points<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Points>,
                T::Error: ::std::fmt::Display,
            {
                self.points = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for points: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Timeseries> for super::Timeseries {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Timeseries,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    fields: value.fields?,
                    points: value.points?,
                })
            }
        }

        impl ::std::convert::From<super::Timeseries> for Timeseries {
            fn from(value: super::Timeseries) -> Self {
                Self {
                    fields: Ok(value.fields),
                    points: Ok(value.points),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TimeseriesDescription {
            metric: ::std::result::Result<::std::string::String, ::std::string::String>,
            target: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for TimeseriesDescription {
            fn default() -> Self {
                Self {
                    metric: Err("no value supplied for metric".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl TimeseriesDescription {
            pub fn metric<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.metric = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metric: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<TimeseriesDescription> for super::TimeseriesDescription {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TimeseriesDescription,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    metric: value.metric?,
                    target: value.target?,
                })
            }
        }

        impl ::std::convert::From<super::TimeseriesDescription> for TimeseriesDescription {
            fn from(value: super::TimeseriesDescription) -> Self {
                Self {
                    metric: Ok(value.metric),
                    target: Ok(value.target),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TimeseriesQuery {
            query: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for TimeseriesQuery {
            fn default() -> Self {
                Self {
                    query: Err("no value supplied for query".to_string()),
                }
            }
        }

        impl TimeseriesQuery {
            pub fn query<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.query = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for query: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<TimeseriesQuery> for super::TimeseriesQuery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TimeseriesQuery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    query: value.query?,
                })
            }
        }

        impl ::std::convert::From<super::TimeseriesQuery> for TimeseriesQuery {
            fn from(value: super::TimeseriesQuery) -> Self {
                Self {
                    query: Ok(value.query),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TimeseriesSchema {
            authz_scope: ::std::result::Result<super::AuthzScope, ::std::string::String>,
            created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            datum_type: ::std::result::Result<super::DatumType, ::std::string::String>,
            description: ::std::result::Result<super::TimeseriesDescription, ::std::string::String>,
            field_schema: ::std::result::Result<Vec<super::FieldSchema>, ::std::string::String>,
            timeseries_name: ::std::result::Result<super::TimeseriesName, ::std::string::String>,
            units: ::std::result::Result<super::Units, ::std::string::String>,
            version: ::std::result::Result<::std::num::NonZeroU8, ::std::string::String>,
        }

        impl ::std::default::Default for TimeseriesSchema {
            fn default() -> Self {
                Self {
                    authz_scope: Err("no value supplied for authz_scope".to_string()),
                    created: Err("no value supplied for created".to_string()),
                    datum_type: Err("no value supplied for datum_type".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    field_schema: Err("no value supplied for field_schema".to_string()),
                    timeseries_name: Err("no value supplied for timeseries_name".to_string()),
                    units: Err("no value supplied for units".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl TimeseriesSchema {
            pub fn authz_scope<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::AuthzScope>,
                T::Error: ::std::fmt::Display,
            {
                self.authz_scope = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for authz_scope: {}", e));
                self
            }
            pub fn created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.created = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created: {}", e));
                self
            }
            pub fn datum_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::DatumType>,
                T::Error: ::std::fmt::Display,
            {
                self.datum_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum_type: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TimeseriesDescription>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn field_schema<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<Vec<super::FieldSchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.field_schema = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_schema: {}", e)
                });
                self
            }
            pub fn timeseries_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TimeseriesName>,
                T::Error: ::std::fmt::Display,
            {
                self.timeseries_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for timeseries_name: {}", e)
                });
                self
            }
            pub fn units<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Units>,
                T::Error: ::std::fmt::Display,
            {
                self.units = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for units: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::num::NonZeroU8>,
                T::Error: ::std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<TimeseriesSchema> for super::TimeseriesSchema {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TimeseriesSchema,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    authz_scope: value.authz_scope?,
                    created: value.created?,
                    datum_type: value.datum_type?,
                    description: value.description?,
                    field_schema: value.field_schema?,
                    timeseries_name: value.timeseries_name?,
                    units: value.units?,
                    version: value.version?,
                })
            }
        }

        impl ::std::convert::From<super::TimeseriesSchema> for TimeseriesSchema {
            fn from(value: super::TimeseriesSchema) -> Self {
                Self {
                    authz_scope: Ok(value.authz_scope),
                    created: Ok(value.created),
                    datum_type: Ok(value.datum_type),
                    description: Ok(value.description),
                    field_schema: Ok(value.field_schema),
                    timeseries_name: Ok(value.timeseries_name),
                    units: Ok(value.units),
                    version: Ok(value.version),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TimeseriesSchemaResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::TimeseriesSchema>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for TimeseriesSchemaResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl TimeseriesSchemaResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TimeseriesSchema>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<TimeseriesSchemaResultsPage> for super::TimeseriesSchemaResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TimeseriesSchemaResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::TimeseriesSchemaResultsPage> for TimeseriesSchemaResultsPage {
            fn from(value: super::TimeseriesSchemaResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct TxEqConfig {
            main: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            post1: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            post2: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            pre1: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
            pre2: ::std::result::Result<::std::option::Option<i32>, ::std::string::String>,
        }

        impl ::std::default::Default for TxEqConfig {
            fn default() -> Self {
                Self {
                    main: Ok(Default::default()),
                    post1: Ok(Default::default()),
                    post2: Ok(Default::default()),
                    pre1: Ok(Default::default()),
                    pre2: Ok(Default::default()),
                }
            }
        }

        impl TxEqConfig {
            pub fn main<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.main = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for main: {}", e));
                self
            }
            pub fn post1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.post1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for post1: {}", e));
                self
            }
            pub fn post2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.post2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for post2: {}", e));
                self
            }
            pub fn pre1<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.pre1 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pre1: {}", e));
                self
            }
            pub fn pre2<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<i32>>,
                T::Error: ::std::fmt::Display,
            {
                self.pre2 = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for pre2: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<TxEqConfig> for super::TxEqConfig {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TxEqConfig,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    main: value.main?,
                    post1: value.post1?,
                    post2: value.post2?,
                    pre1: value.pre1?,
                    pre2: value.pre2?,
                })
            }
        }

        impl ::std::convert::From<super::TxEqConfig> for TxEqConfig {
            fn from(value: super::TxEqConfig) -> Self {
                Self {
                    main: Ok(value.main),
                    post1: Ok(value.post1),
                    post2: Ok(value.post2),
                    pre1: Ok(value.pre1),
                    pre2: Ok(value.pre2),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UninitializedSled {
            baseboard: ::std::result::Result<super::Baseboard, ::std::string::String>,
            cubby: ::std::result::Result<u16, ::std::string::String>,
            rack_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for UninitializedSled {
            fn default() -> Self {
                Self {
                    baseboard: Err("no value supplied for baseboard".to_string()),
                    cubby: Err("no value supplied for cubby".to_string()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                }
            }
        }

        impl UninitializedSled {
            pub fn baseboard<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Baseboard>,
                T::Error: ::std::fmt::Display,
            {
                self.baseboard = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for baseboard: {}", e));
                self
            }
            pub fn cubby<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.cubby = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cubby: {}", e));
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UninitializedSled> for super::UninitializedSled {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UninitializedSled,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    baseboard: value.baseboard?,
                    cubby: value.cubby?,
                    rack_id: value.rack_id?,
                })
            }
        }

        impl ::std::convert::From<super::UninitializedSled> for UninitializedSled {
            fn from(value: super::UninitializedSled) -> Self {
                Self {
                    baseboard: Ok(value.baseboard),
                    cubby: Ok(value.cubby),
                    rack_id: Ok(value.rack_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UninitializedSledId {
            part: ::std::result::Result<::std::string::String, ::std::string::String>,
            serial: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for UninitializedSledId {
            fn default() -> Self {
                Self {
                    part: Err("no value supplied for part".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                }
            }
        }

        impl UninitializedSledId {
            pub fn part<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.part = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for part: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UninitializedSledId> for super::UninitializedSledId {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UninitializedSledId,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    part: value.part?,
                    serial: value.serial?,
                })
            }
        }

        impl ::std::convert::From<super::UninitializedSledId> for UninitializedSledId {
            fn from(value: super::UninitializedSledId) -> Self {
                Self {
                    part: Ok(value.part),
                    serial: Ok(value.serial),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UninitializedSledResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::UninitializedSled>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for UninitializedSledResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UninitializedSledResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::UninitializedSled>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UninitializedSledResultsPage> for super::UninitializedSledResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UninitializedSledResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::UninitializedSledResultsPage> for UninitializedSledResultsPage {
            fn from(value: super::UninitializedSledResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct User {
            display_name: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            silo_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for User {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl User {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<User> for super::User {
            type Error = super::error::ConversionError;
            fn try_from(value: User) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                })
            }
        }

        impl ::std::convert::From<super::User> for User {
            fn from(value: super::User) -> Self {
                Self {
                    display_name: Ok(value.display_name),
                    id: Ok(value.id),
                    silo_id: Ok(value.silo_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserBuiltin {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for UserBuiltin {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl UserBuiltin {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<UserBuiltin> for super::UserBuiltin {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserBuiltin,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::UserBuiltin> for UserBuiltin {
            fn from(value: super::UserBuiltin) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserBuiltinResultsPage {
            items:
                ::std::result::Result<::std::vec::Vec<super::UserBuiltin>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for UserBuiltinResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UserBuiltinResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::UserBuiltin>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UserBuiltinResultsPage> for super::UserBuiltinResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserBuiltinResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::UserBuiltinResultsPage> for UserBuiltinResultsPage {
            fn from(value: super::UserBuiltinResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserCreate {
            external_id: ::std::result::Result<super::UserId, ::std::string::String>,
            password: ::std::result::Result<super::UserPassword, ::std::string::String>,
        }

        impl ::std::default::Default for UserCreate {
            fn default() -> Self {
                Self {
                    external_id: Err("no value supplied for external_id".to_string()),
                    password: Err("no value supplied for password".to_string()),
                }
            }
        }

        impl UserCreate {
            pub fn external_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UserId>,
                T::Error: ::std::fmt::Display,
            {
                self.external_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for external_id: {}", e));
                self
            }
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UserPassword>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UserCreate> for super::UserCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    external_id: value.external_id?,
                    password: value.password?,
                })
            }
        }

        impl ::std::convert::From<super::UserCreate> for UserCreate {
            fn from(value: super::UserCreate) -> Self {
                Self {
                    external_id: Ok(value.external_id),
                    password: Ok(value.password),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UserResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::User>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for UserResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UserResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::User>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UserResultsPage> for super::UserResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UserResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::UserResultsPage> for UserResultsPage {
            fn from(value: super::UserResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct UsernamePasswordCredentials {
            password: ::std::result::Result<super::Password, ::std::string::String>,
            username: ::std::result::Result<super::UserId, ::std::string::String>,
        }

        impl ::std::default::Default for UsernamePasswordCredentials {
            fn default() -> Self {
                Self {
                    password: Err("no value supplied for password".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }

        impl UsernamePasswordCredentials {
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Password>,
                T::Error: ::std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::UserId>,
                T::Error: ::std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<UsernamePasswordCredentials> for super::UsernamePasswordCredentials {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UsernamePasswordCredentials,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    password: value.password?,
                    username: value.username?,
                })
            }
        }

        impl ::std::convert::From<super::UsernamePasswordCredentials> for UsernamePasswordCredentials {
            fn from(value: super::UsernamePasswordCredentials) -> Self {
                Self {
                    password: Ok(value.password),
                    username: Ok(value.username),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Utilization {
            capacity: ::std::result::Result<super::VirtualResourceCounts, ::std::string::String>,
            provisioned: ::std::result::Result<super::VirtualResourceCounts, ::std::string::String>,
        }

        impl ::std::default::Default for Utilization {
            fn default() -> Self {
                Self {
                    capacity: Err("no value supplied for capacity".to_string()),
                    provisioned: Err("no value supplied for provisioned".to_string()),
                }
            }
        }

        impl Utilization {
            pub fn capacity<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VirtualResourceCounts>,
                T::Error: ::std::fmt::Display,
            {
                self.capacity = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for capacity: {}", e));
                self
            }
            pub fn provisioned<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VirtualResourceCounts>,
                T::Error: ::std::fmt::Display,
            {
                self.provisioned = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for provisioned: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Utilization> for super::Utilization {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Utilization,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    capacity: value.capacity?,
                    provisioned: value.provisioned?,
                })
            }
        }

        impl ::std::convert::From<super::Utilization> for Utilization {
            fn from(value: super::Utilization) -> Self {
                Self {
                    capacity: Ok(value.capacity),
                    provisioned: Ok(value.provisioned),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Values {
            metric_type: ::std::result::Result<super::MetricType, ::std::string::String>,
            values: ::std::result::Result<super::ValueArray, ::std::string::String>,
        }

        impl ::std::default::Default for Values {
            fn default() -> Self {
                Self {
                    metric_type: Err("no value supplied for metric_type".to_string()),
                    values: Err("no value supplied for values".to_string()),
                }
            }
        }

        impl Values {
            pub fn metric_type<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::MetricType>,
                T::Error: ::std::fmt::Display,
            {
                self.metric_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for metric_type: {}", e));
                self
            }
            pub fn values<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ValueArray>,
                T::Error: ::std::fmt::Display,
            {
                self.values = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for values: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<Values> for super::Values {
            type Error = super::error::ConversionError;
            fn try_from(
                value: Values,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    metric_type: value.metric_type?,
                    values: value.values?,
                })
            }
        }

        impl ::std::convert::From<super::Values> for Values {
            fn from(value: super::Values) -> Self {
                Self {
                    metric_type: Ok(value.metric_type),
                    values: Ok(value.values),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VirtualResourceCounts {
            cpus: ::std::result::Result<i64, ::std::string::String>,
            memory: ::std::result::Result<super::ByteCount, ::std::string::String>,
            storage: ::std::result::Result<super::ByteCount, ::std::string::String>,
        }

        impl ::std::default::Default for VirtualResourceCounts {
            fn default() -> Self {
                Self {
                    cpus: Err("no value supplied for cpus".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    storage: Err("no value supplied for storage".to_string()),
                }
            }
        }

        impl VirtualResourceCounts {
            pub fn cpus<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<i64>,
                T::Error: ::std::fmt::Display,
            {
                self.cpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cpus: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn storage<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::ByteCount>,
                T::Error: ::std::fmt::Display,
            {
                self.storage = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for storage: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VirtualResourceCounts> for super::VirtualResourceCounts {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VirtualResourceCounts,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    cpus: value.cpus?,
                    memory: value.memory?,
                    storage: value.storage?,
                })
            }
        }

        impl ::std::convert::From<super::VirtualResourceCounts> for VirtualResourceCounts {
            fn from(value: super::VirtualResourceCounts) -> Self {
                Self {
                    cpus: Ok(value.cpus),
                    memory: Ok(value.memory),
                    storage: Ok(value.storage),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct Vpc {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            dns_name: ::std::result::Result<super::Name, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            ipv6_prefix: ::std::result::Result<super::Ipv6Net, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            project_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            system_router_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for Vpc {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    dns_name: Err("no value supplied for dns_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    ipv6_prefix: Err("no value supplied for ipv6_prefix".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    system_router_id: Err("no value supplied for system_router_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Vpc {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ipv6_prefix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv6Net>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv6_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_prefix: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn system_router_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.system_router_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for system_router_id: {}",
                        e
                    )
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<Vpc> for super::Vpc {
            type Error = super::error::ConversionError;
            fn try_from(value: Vpc) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    id: value.id?,
                    ipv6_prefix: value.ipv6_prefix?,
                    name: value.name?,
                    project_id: value.project_id?,
                    system_router_id: value.system_router_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::Vpc> for Vpc {
            fn from(value: super::Vpc) -> Self {
                Self {
                    description: Ok(value.description),
                    dns_name: Ok(value.dns_name),
                    id: Ok(value.id),
                    ipv6_prefix: Ok(value.ipv6_prefix),
                    name: Ok(value.name),
                    project_id: Ok(value.project_id),
                    system_router_id: Ok(value.system_router_id),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            dns_name: ::std::result::Result<super::Name, ::std::string::String>,
            ipv6_prefix:
                ::std::result::Result<::std::option::Option<super::Ipv6Net>, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for VpcCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    dns_name: Err("no value supplied for dns_name".to_string()),
                    ipv6_prefix: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn ipv6_prefix<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Ipv6Net>>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv6_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_prefix: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcCreate> for super::VpcCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    ipv6_prefix: value.ipv6_prefix?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::VpcCreate> for VpcCreate {
            fn from(value: super::VpcCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    dns_name: Ok(value.dns_name),
                    ipv6_prefix: Ok(value.ipv6_prefix),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRule {
            action: ::std::result::Result<super::VpcFirewallRuleAction, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            direction:
                ::std::result::Result<super::VpcFirewallRuleDirection, ::std::string::String>,
            filters: ::std::result::Result<super::VpcFirewallRuleFilter, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            priority: ::std::result::Result<u16, ::std::string::String>,
            status: ::std::result::Result<super::VpcFirewallRuleStatus, ::std::string::String>,
            targets: ::std::result::Result<
                ::std::vec::Vec<super::VpcFirewallRuleTarget>,
                ::std::string::String,
            >,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vpc_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for VpcFirewallRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    direction: Err("no value supplied for direction".to_string()),
                    filters: Err("no value supplied for filters".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    targets: Err("no value supplied for targets".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcFirewallRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn direction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleDirection>,
                T::Error: ::std::fmt::Display,
            {
                self.direction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for direction: {}", e));
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleFilter>,
                T::Error: ::std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for filters: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn targets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VpcFirewallRuleTarget>>,
                T::Error: ::std::fmt::Display,
            {
                self.targets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for targets: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcFirewallRule> for super::VpcFirewallRule {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRule,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    direction: value.direction?,
                    filters: value.filters?,
                    id: value.id?,
                    name: value.name?,
                    priority: value.priority?,
                    status: value.status?,
                    targets: value.targets?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl ::std::convert::From<super::VpcFirewallRule> for VpcFirewallRule {
            fn from(value: super::VpcFirewallRule) -> Self {
                Self {
                    action: Ok(value.action),
                    description: Ok(value.description),
                    direction: Ok(value.direction),
                    filters: Ok(value.filters),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    status: Ok(value.status),
                    targets: Ok(value.targets),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRuleFilter {
            hosts: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::VpcFirewallRuleHostFilter>>,
                ::std::string::String,
            >,
            ports: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::L4PortRange>>,
                ::std::string::String,
            >,
            protocols: ::std::result::Result<
                ::std::option::Option<::std::vec::Vec<super::VpcFirewallRuleProtocol>>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcFirewallRuleFilter {
            fn default() -> Self {
                Self {
                    hosts: Ok(Default::default()),
                    ports: Ok(Default::default()),
                    protocols: Ok(Default::default()),
                }
            }
        }

        impl VpcFirewallRuleFilter {
            pub fn hosts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::VpcFirewallRuleHostFilter>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.hosts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hosts: {}", e));
                self
            }
            pub fn ports<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::L4PortRange>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.ports = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ports: {}", e));
                self
            }
            pub fn protocols<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<
                    ::std::option::Option<::std::vec::Vec<super::VpcFirewallRuleProtocol>>,
                >,
                T::Error: ::std::fmt::Display,
            {
                self.protocols = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for protocols: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcFirewallRuleFilter> for super::VpcFirewallRuleFilter {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRuleFilter,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    hosts: value.hosts?,
                    ports: value.ports?,
                    protocols: value.protocols?,
                })
            }
        }

        impl ::std::convert::From<super::VpcFirewallRuleFilter> for VpcFirewallRuleFilter {
            fn from(value: super::VpcFirewallRuleFilter) -> Self {
                Self {
                    hosts: Ok(value.hosts),
                    ports: Ok(value.ports),
                    protocols: Ok(value.protocols),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRuleUpdate {
            action: ::std::result::Result<super::VpcFirewallRuleAction, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            direction:
                ::std::result::Result<super::VpcFirewallRuleDirection, ::std::string::String>,
            filters: ::std::result::Result<super::VpcFirewallRuleFilter, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            priority: ::std::result::Result<u16, ::std::string::String>,
            status: ::std::result::Result<super::VpcFirewallRuleStatus, ::std::string::String>,
            targets: ::std::result::Result<
                ::std::vec::Vec<super::VpcFirewallRuleTarget>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcFirewallRuleUpdate {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    direction: Err("no value supplied for direction".to_string()),
                    filters: Err("no value supplied for filters".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    targets: Err("no value supplied for targets".to_string()),
                }
            }
        }

        impl VpcFirewallRuleUpdate {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleAction>,
                T::Error: ::std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn direction<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleDirection>,
                T::Error: ::std::fmt::Display,
            {
                self.direction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for direction: {}", e));
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleFilter>,
                T::Error: ::std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for filters: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcFirewallRuleStatus>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn targets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VpcFirewallRuleTarget>>,
                T::Error: ::std::fmt::Display,
            {
                self.targets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for targets: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcFirewallRuleUpdate> for super::VpcFirewallRuleUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRuleUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    direction: value.direction?,
                    filters: value.filters?,
                    name: value.name?,
                    priority: value.priority?,
                    status: value.status?,
                    targets: value.targets?,
                })
            }
        }

        impl ::std::convert::From<super::VpcFirewallRuleUpdate> for VpcFirewallRuleUpdate {
            fn from(value: super::VpcFirewallRuleUpdate) -> Self {
                Self {
                    action: Ok(value.action),
                    description: Ok(value.description),
                    direction: Ok(value.direction),
                    filters: Ok(value.filters),
                    name: Ok(value.name),
                    priority: Ok(value.priority),
                    status: Ok(value.status),
                    targets: Ok(value.targets),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRuleUpdateParams {
            rules: ::std::result::Result<
                ::std::vec::Vec<super::VpcFirewallRuleUpdate>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcFirewallRuleUpdateParams {
            fn default() -> Self {
                Self {
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }

        impl VpcFirewallRuleUpdateParams {
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VpcFirewallRuleUpdate>>,
                T::Error: ::std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcFirewallRuleUpdateParams> for super::VpcFirewallRuleUpdateParams {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRuleUpdateParams,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    rules: value.rules?,
                })
            }
        }

        impl ::std::convert::From<super::VpcFirewallRuleUpdateParams> for VpcFirewallRuleUpdateParams {
            fn from(value: super::VpcFirewallRuleUpdateParams) -> Self {
                Self {
                    rules: Ok(value.rules),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcFirewallRules {
            rules: ::std::result::Result<
                ::std::vec::Vec<super::VpcFirewallRule>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcFirewallRules {
            fn default() -> Self {
                Self {
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }

        impl VpcFirewallRules {
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VpcFirewallRule>>,
                T::Error: ::std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcFirewallRules> for super::VpcFirewallRules {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcFirewallRules,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    rules: value.rules?,
                })
            }
        }

        impl ::std::convert::From<super::VpcFirewallRules> for VpcFirewallRules {
            fn from(value: super::VpcFirewallRules) -> Self {
                Self {
                    rules: Ok(value.rules),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::Vpc>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::Vpc>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcResultsPage> for super::VpcResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::VpcResultsPage> for VpcResultsPage {
            fn from(value: super::VpcResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouter {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            kind: ::std::result::Result<super::VpcRouterKind, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vpc_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for VpcRouter {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcRouter {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::VpcRouterKind>,
                T::Error: ::std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcRouter> for super::VpcRouter {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcRouter,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl ::std::convert::From<super::VpcRouter> for VpcRouter {
            fn from(value: super::VpcRouter) -> Self {
                Self {
                    description: Ok(value.description),
                    id: Ok(value.id),
                    kind: Ok(value.kind),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouterCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for VpcRouterCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcRouterCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcRouterCreate> for super::VpcRouterCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcRouterCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::VpcRouterCreate> for VpcRouterCreate {
            fn from(value: super::VpcRouterCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouterResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::VpcRouter>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcRouterResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcRouterResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VpcRouter>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcRouterResultsPage> for super::VpcRouterResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcRouterResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::VpcRouterResultsPage> for VpcRouterResultsPage {
            fn from(value: super::VpcRouterResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcRouterUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for VpcRouterUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcRouterUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcRouterUpdate> for super::VpcRouterUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcRouterUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::VpcRouterUpdate> for VpcRouterUpdate {
            fn from(value: super::VpcRouterUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnet {
            custom_router_id:
                ::std::result::Result<::std::option::Option<::uuid::Uuid>, ::std::string::String>,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            ipv4_block: ::std::result::Result<super::Ipv4Net, ::std::string::String>,
            ipv6_block: ::std::result::Result<super::Ipv6Net, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            vpc_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for VpcSubnet {
            fn default() -> Self {
                Self {
                    custom_router_id: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    ipv4_block: Err("no value supplied for ipv4_block".to_string()),
                    ipv6_block: Err("no value supplied for ipv6_block".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcSubnet {
            pub fn custom_router_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::uuid::Uuid>>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_router_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for custom_router_id: {}",
                        e
                    )
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ipv4_block<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv4Net>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv4_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4_block: {}", e));
                self
            }
            pub fn ipv6_block<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv6Net>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv6_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_block: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcSubnet> for super::VpcSubnet {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcSubnet,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    custom_router_id: value.custom_router_id?,
                    description: value.description?,
                    id: value.id?,
                    ipv4_block: value.ipv4_block?,
                    ipv6_block: value.ipv6_block?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        impl ::std::convert::From<super::VpcSubnet> for VpcSubnet {
            fn from(value: super::VpcSubnet) -> Self {
                Self {
                    custom_router_id: Ok(value.custom_router_id),
                    description: Ok(value.description),
                    id: Ok(value.id),
                    ipv4_block: Ok(value.ipv4_block),
                    ipv6_block: Ok(value.ipv6_block),
                    name: Ok(value.name),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                    vpc_id: Ok(value.vpc_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnetCreate {
            custom_router: ::std::result::Result<
                ::std::option::Option<super::NameOrId>,
                ::std::string::String,
            >,
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            ipv4_block: ::std::result::Result<super::Ipv4Net, ::std::string::String>,
            ipv6_block:
                ::std::result::Result<::std::option::Option<super::Ipv6Net>, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
        }

        impl ::std::default::Default for VpcSubnetCreate {
            fn default() -> Self {
                Self {
                    custom_router: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    ipv4_block: Err("no value supplied for ipv4_block".to_string()),
                    ipv6_block: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcSubnetCreate {
            pub fn custom_router<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_router = value.try_into().map_err(|e| {
                    format!("error converting supplied value for custom_router: {}", e)
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ipv4_block<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Ipv4Net>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv4_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4_block: {}", e));
                self
            }
            pub fn ipv6_block<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Ipv6Net>>,
                T::Error: ::std::fmt::Display,
            {
                self.ipv6_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_block: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcSubnetCreate> for super::VpcSubnetCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcSubnetCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    custom_router: value.custom_router?,
                    description: value.description?,
                    ipv4_block: value.ipv4_block?,
                    ipv6_block: value.ipv6_block?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::VpcSubnetCreate> for VpcSubnetCreate {
            fn from(value: super::VpcSubnetCreate) -> Self {
                Self {
                    custom_router: Ok(value.custom_router),
                    description: Ok(value.description),
                    ipv4_block: Ok(value.ipv4_block),
                    ipv6_block: Ok(value.ipv6_block),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnetResultsPage {
            items: ::std::result::Result<::std::vec::Vec<super::VpcSubnet>, ::std::string::String>,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for VpcSubnetResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcSubnetResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::VpcSubnet>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcSubnetResultsPage> for super::VpcSubnetResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcSubnetResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::VpcSubnetResultsPage> for VpcSubnetResultsPage {
            fn from(value: super::VpcSubnetResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcSubnetUpdate {
            custom_router: ::std::result::Result<
                ::std::option::Option<super::NameOrId>,
                ::std::string::String,
            >,
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for VpcSubnetUpdate {
            fn default() -> Self {
                Self {
                    custom_router: Ok(Default::default()),
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcSubnetUpdate {
            pub fn custom_router<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::NameOrId>>,
                T::Error: ::std::fmt::Display,
            {
                self.custom_router = value.try_into().map_err(|e| {
                    format!("error converting supplied value for custom_router: {}", e)
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcSubnetUpdate> for super::VpcSubnetUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcSubnetUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    custom_router: value.custom_router?,
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::VpcSubnetUpdate> for VpcSubnetUpdate {
            fn from(value: super::VpcSubnetUpdate) -> Self {
                Self {
                    custom_router: Ok(value.custom_router),
                    description: Ok(value.description),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct VpcUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            dns_name:
                ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for VpcUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    dns_name: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<VpcUpdate> for super::VpcUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: VpcUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::VpcUpdate> for VpcUpdate {
            fn from(value: super::VpcUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    dns_name: Ok(value.dns_name),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookCreate {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            endpoint: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            secrets: ::std::result::Result<
                ::std::vec::Vec<::std::string::String>,
                ::std::string::String,
            >,
            subscriptions: ::std::result::Result<
                ::std::vec::Vec<super::WebhookSubscription>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    endpoint: Err("no value supplied for endpoint".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    secrets: Err("no value supplied for secrets".to_string()),
                    subscriptions: Ok(Default::default()),
                }
            }
        }

        impl WebhookCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn endpoint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn secrets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.secrets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secrets: {}", e));
                self
            }
            pub fn subscriptions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookSubscription>>,
                T::Error: ::std::fmt::Display,
            {
                self.subscriptions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscriptions: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookCreate> for super::WebhookCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    endpoint: value.endpoint?,
                    name: value.name?,
                    secrets: value.secrets?,
                    subscriptions: value.subscriptions?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookCreate> for WebhookCreate {
            fn from(value: super::WebhookCreate) -> Self {
                Self {
                    description: Ok(value.description),
                    endpoint: Ok(value.endpoint),
                    name: Ok(value.name),
                    secrets: Ok(value.secrets),
                    subscriptions: Ok(value.subscriptions),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookDelivery {
            attempts: ::std::result::Result<
                ::std::vec::Vec<super::WebhookDeliveryAttempt>,
                ::std::string::String,
            >,
            event_class: ::std::result::Result<::std::string::String, ::std::string::String>,
            event_id:
                ::std::result::Result<super::TypedUuidForWebhookEventKind, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            state: ::std::result::Result<super::WebhookDeliveryState, ::std::string::String>,
            time_started: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            trigger: ::std::result::Result<super::WebhookDeliveryTrigger, ::std::string::String>,
            webhook_id: ::std::result::Result<
                super::TypedUuidForWebhookReceiverKind,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookDelivery {
            fn default() -> Self {
                Self {
                    attempts: Err("no value supplied for attempts".to_string()),
                    event_class: Err("no value supplied for event_class".to_string()),
                    event_id: Err("no value supplied for event_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    time_started: Err("no value supplied for time_started".to_string()),
                    trigger: Err("no value supplied for trigger".to_string()),
                    webhook_id: Err("no value supplied for webhook_id".to_string()),
                }
            }
        }

        impl WebhookDelivery {
            pub fn attempts<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookDeliveryAttempt>>,
                T::Error: ::std::fmt::Display,
            {
                self.attempts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for attempts: {}", e));
                self
            }
            pub fn event_class<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.event_class = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for event_class: {}", e));
                self
            }
            pub fn event_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TypedUuidForWebhookEventKind>,
                T::Error: ::std::fmt::Display,
            {
                self.event_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for event_id: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookDeliveryState>,
                T::Error: ::std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_started<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_started = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_started: {}", e)
                });
                self
            }
            pub fn trigger<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookDeliveryTrigger>,
                T::Error: ::std::fmt::Display,
            {
                self.trigger = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for trigger: {}", e));
                self
            }
            pub fn webhook_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::TypedUuidForWebhookReceiverKind>,
                T::Error: ::std::fmt::Display,
            {
                self.webhook_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for webhook_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookDelivery> for super::WebhookDelivery {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookDelivery,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    attempts: value.attempts?,
                    event_class: value.event_class?,
                    event_id: value.event_id?,
                    id: value.id?,
                    state: value.state?,
                    time_started: value.time_started?,
                    trigger: value.trigger?,
                    webhook_id: value.webhook_id?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookDelivery> for WebhookDelivery {
            fn from(value: super::WebhookDelivery) -> Self {
                Self {
                    attempts: Ok(value.attempts),
                    event_class: Ok(value.event_class),
                    event_id: Ok(value.event_id),
                    id: Ok(value.id),
                    state: Ok(value.state),
                    time_started: Ok(value.time_started),
                    trigger: Ok(value.trigger),
                    webhook_id: Ok(value.webhook_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookDeliveryAttempt {
            attempt: ::std::result::Result<u32, ::std::string::String>,
            response: ::std::result::Result<
                ::std::option::Option<super::WebhookDeliveryResponse>,
                ::std::string::String,
            >,
            result:
                ::std::result::Result<super::WebhookDeliveryAttemptResult, ::std::string::String>,
            time_sent: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookDeliveryAttempt {
            fn default() -> Self {
                Self {
                    attempt: Err("no value supplied for attempt".to_string()),
                    response: Ok(Default::default()),
                    result: Err("no value supplied for result".to_string()),
                    time_sent: Err("no value supplied for time_sent".to_string()),
                }
            }
        }

        impl WebhookDeliveryAttempt {
            pub fn attempt<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.attempt = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for attempt: {}", e));
                self
            }
            pub fn response<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::WebhookDeliveryResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.response = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for response: {}", e));
                self
            }
            pub fn result<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookDeliveryAttemptResult>,
                T::Error: ::std::fmt::Display,
            {
                self.result = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for result: {}", e));
                self
            }
            pub fn time_sent<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_sent = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for time_sent: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookDeliveryAttempt> for super::WebhookDeliveryAttempt {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookDeliveryAttempt,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    attempt: value.attempt?,
                    response: value.response?,
                    result: value.result?,
                    time_sent: value.time_sent?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookDeliveryAttempt> for WebhookDeliveryAttempt {
            fn from(value: super::WebhookDeliveryAttempt) -> Self {
                Self {
                    attempt: Ok(value.attempt),
                    response: Ok(value.response),
                    result: Ok(value.result),
                    time_sent: Ok(value.time_sent),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookDeliveryId {
            delivery_id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookDeliveryId {
            fn default() -> Self {
                Self {
                    delivery_id: Err("no value supplied for delivery_id".to_string()),
                }
            }
        }

        impl WebhookDeliveryId {
            pub fn delivery_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.delivery_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for delivery_id: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookDeliveryId> for super::WebhookDeliveryId {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookDeliveryId,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    delivery_id: value.delivery_id?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookDeliveryId> for WebhookDeliveryId {
            fn from(value: super::WebhookDeliveryId) -> Self {
                Self {
                    delivery_id: Ok(value.delivery_id),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookDeliveryResponse {
            duration_ms: ::std::result::Result<u32, ::std::string::String>,
            status: ::std::result::Result<u16, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookDeliveryResponse {
            fn default() -> Self {
                Self {
                    duration_ms: Err("no value supplied for duration_ms".to_string()),
                    status: Err("no value supplied for status".to_string()),
                }
            }
        }

        impl WebhookDeliveryResponse {
            pub fn duration_ms<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u32>,
                T::Error: ::std::fmt::Display,
            {
                self.duration_ms = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for duration_ms: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<u16>,
                T::Error: ::std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookDeliveryResponse> for super::WebhookDeliveryResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookDeliveryResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    duration_ms: value.duration_ms?,
                    status: value.status?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookDeliveryResponse> for WebhookDeliveryResponse {
            fn from(value: super::WebhookDeliveryResponse) -> Self {
                Self {
                    duration_ms: Ok(value.duration_ms),
                    status: Ok(value.status),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookDeliveryResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::WebhookDelivery>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookDeliveryResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl WebhookDeliveryResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookDelivery>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookDeliveryResultsPage> for super::WebhookDeliveryResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookDeliveryResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookDeliveryResultsPage> for WebhookDeliveryResultsPage {
            fn from(value: super::WebhookDeliveryResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookProbeResult {
            probe: ::std::result::Result<super::WebhookDelivery, ::std::string::String>,
            resends_started:
                ::std::result::Result<::std::option::Option<u32>, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookProbeResult {
            fn default() -> Self {
                Self {
                    probe: Err("no value supplied for probe".to_string()),
                    resends_started: Ok(Default::default()),
                }
            }
        }

        impl WebhookProbeResult {
            pub fn probe<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookDelivery>,
                T::Error: ::std::fmt::Display,
            {
                self.probe = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for probe: {}", e));
                self
            }
            pub fn resends_started<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<u32>>,
                T::Error: ::std::fmt::Display,
            {
                self.resends_started = value.try_into().map_err(|e| {
                    format!("error converting supplied value for resends_started: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookProbeResult> for super::WebhookProbeResult {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookProbeResult,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    probe: value.probe?,
                    resends_started: value.resends_started?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookProbeResult> for WebhookProbeResult {
            fn from(value: super::WebhookProbeResult) -> Self {
                Self {
                    probe: Ok(value.probe),
                    resends_started: Ok(value.resends_started),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookReceiver {
            description: ::std::result::Result<::std::string::String, ::std::string::String>,
            endpoint: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            name: ::std::result::Result<super::Name, ::std::string::String>,
            secrets:
                ::std::result::Result<::std::vec::Vec<super::WebhookSecret>, ::std::string::String>,
            subscriptions: ::std::result::Result<
                ::std::vec::Vec<super::WebhookSubscription>,
                ::std::string::String,
            >,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
            time_modified: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookReceiver {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    endpoint: Err("no value supplied for endpoint".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    secrets: Err("no value supplied for secrets".to_string()),
                    subscriptions: Err("no value supplied for subscriptions".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl WebhookReceiver {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn endpoint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::Name>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn secrets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookSecret>>,
                T::Error: ::std::fmt::Display,
            {
                self.secrets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secrets: {}", e));
                self
            }
            pub fn subscriptions<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookSubscription>>,
                T::Error: ::std::fmt::Display,
            {
                self.subscriptions = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscriptions: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookReceiver> for super::WebhookReceiver {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookReceiver,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    endpoint: value.endpoint?,
                    id: value.id?,
                    name: value.name?,
                    secrets: value.secrets?,
                    subscriptions: value.subscriptions?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookReceiver> for WebhookReceiver {
            fn from(value: super::WebhookReceiver) -> Self {
                Self {
                    description: Ok(value.description),
                    endpoint: Ok(value.endpoint),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    secrets: Ok(value.secrets),
                    subscriptions: Ok(value.subscriptions),
                    time_created: Ok(value.time_created),
                    time_modified: Ok(value.time_modified),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookReceiverResultsPage {
            items: ::std::result::Result<
                ::std::vec::Vec<super::WebhookReceiver>,
                ::std::string::String,
            >,
            next_page: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookReceiverResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl WebhookReceiverResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookReceiver>>,
                T::Error: ::std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookReceiverResultsPage> for super::WebhookReceiverResultsPage {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookReceiverResultsPage,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookReceiverResultsPage> for WebhookReceiverResultsPage {
            fn from(value: super::WebhookReceiverResultsPage) -> Self {
                Self {
                    items: Ok(value.items),
                    next_page: Ok(value.next_page),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookReceiverUpdate {
            description: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            endpoint: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<::std::option::Option<super::Name>, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookReceiverUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    endpoint: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl WebhookReceiverUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn endpoint<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.endpoint = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for endpoint: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<super::Name>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookReceiverUpdate> for super::WebhookReceiverUpdate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookReceiverUpdate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    description: value.description?,
                    endpoint: value.endpoint?,
                    name: value.name?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookReceiverUpdate> for WebhookReceiverUpdate {
            fn from(value: super::WebhookReceiverUpdate) -> Self {
                Self {
                    description: Ok(value.description),
                    endpoint: Ok(value.endpoint),
                    name: Ok(value.name),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookSecret {
            id: ::std::result::Result<::uuid::Uuid, ::std::string::String>,
            time_created: ::std::result::Result<
                ::chrono::DateTime<::chrono::offset::Utc>,
                ::std::string::String,
            >,
        }

        impl ::std::default::Default for WebhookSecret {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                }
            }
        }

        impl WebhookSecret {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::uuid::Uuid>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
                T::Error: ::std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookSecret> for super::WebhookSecret {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSecret,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    id: value.id?,
                    time_created: value.time_created?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookSecret> for WebhookSecret {
            fn from(value: super::WebhookSecret) -> Self {
                Self {
                    id: Ok(value.id),
                    time_created: Ok(value.time_created),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookSecretCreate {
            secret: ::std::result::Result<::std::string::String, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookSecretCreate {
            fn default() -> Self {
                Self {
                    secret: Err("no value supplied for secret".to_string()),
                }
            }
        }

        impl WebhookSecretCreate {
            pub fn secret<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.secret = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secret: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookSecretCreate> for super::WebhookSecretCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSecretCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    secret: value.secret?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookSecretCreate> for WebhookSecretCreate {
            fn from(value: super::WebhookSecretCreate) -> Self {
                Self {
                    secret: Ok(value.secret),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookSecrets {
            secrets:
                ::std::result::Result<::std::vec::Vec<super::WebhookSecret>, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookSecrets {
            fn default() -> Self {
                Self {
                    secrets: Err("no value supplied for secrets".to_string()),
                }
            }
        }

        impl WebhookSecrets {
            pub fn secrets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::WebhookSecret>>,
                T::Error: ::std::fmt::Display,
            {
                self.secrets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for secrets: {}", e));
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookSecrets> for super::WebhookSecrets {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSecrets,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    secrets: value.secrets?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookSecrets> for WebhookSecrets {
            fn from(value: super::WebhookSecrets) -> Self {
                Self {
                    secrets: Ok(value.secrets),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookSubscriptionCreate {
            subscription: ::std::result::Result<super::WebhookSubscription, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookSubscriptionCreate {
            fn default() -> Self {
                Self {
                    subscription: Err("no value supplied for subscription".to_string()),
                }
            }
        }

        impl WebhookSubscriptionCreate {
            pub fn subscription<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookSubscription>,
                T::Error: ::std::fmt::Display,
            {
                self.subscription = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscription: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookSubscriptionCreate> for super::WebhookSubscriptionCreate {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSubscriptionCreate,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subscription: value.subscription?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookSubscriptionCreate> for WebhookSubscriptionCreate {
            fn from(value: super::WebhookSubscriptionCreate) -> Self {
                Self {
                    subscription: Ok(value.subscription),
                }
            }
        }

        #[derive(Clone, Debug)]
        pub struct WebhookSubscriptionCreated {
            subscription: ::std::result::Result<super::WebhookSubscription, ::std::string::String>,
        }

        impl ::std::default::Default for WebhookSubscriptionCreated {
            fn default() -> Self {
                Self {
                    subscription: Err("no value supplied for subscription".to_string()),
                }
            }
        }

        impl WebhookSubscriptionCreated {
            pub fn subscription<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<super::WebhookSubscription>,
                T::Error: ::std::fmt::Display,
            {
                self.subscription = value.try_into().map_err(|e| {
                    format!("error converting supplied value for subscription: {}", e)
                });
                self
            }
        }

        impl ::std::convert::TryFrom<WebhookSubscriptionCreated> for super::WebhookSubscriptionCreated {
            type Error = super::error::ConversionError;
            fn try_from(
                value: WebhookSubscriptionCreated,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    subscription: value.subscription?,
                })
            }
        }

        impl ::std::convert::From<super::WebhookSubscriptionCreated> for WebhookSubscriptionCreated {
            fn from(value: super::WebhookSubscriptionCreated) -> Self {
                Self {
                    subscription: Ok(value.subscription),
                }
            }
        }
    }

    /// Generation of default values for serde.
    pub mod defaults {
        pub(super) fn default_bool<const V: bool>() -> bool {
            V
        }

        pub(super) fn instance_create_network_interfaces(
        ) -> super::InstanceNetworkInterfaceAttachment {
            super::InstanceNetworkInterfaceAttachment::Default
        }
    }
}

#[derive(Clone, Debug)]
/// Client for Oxide Region API
///
/// API for interacting with the Oxide control plane
///
/// Version: 20250604.0.0
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = std::time::Duration::from_secs(15);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }

    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}

impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "20250604.0.0"
    }

    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }

    fn client(&self) -> &reqwest::Client {
        &self.client
    }

    fn inner(&self) -> &() {
        &()
    }
}

impl ClientHooks<()> for &Client {}
/// Anti-affinity groups give control over instance placement.
pub trait ClientAffinityExt {
    /// List anti-affinity groups
    ///
    /// Sends a `GET` request to `/v1/anti-affinity-groups`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.anti_affinity_group_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_list(&self) -> builder::AntiAffinityGroupList;
    /// Create anti-affinity group
    ///
    /// Sends a `POST` request to `/v1/anti-affinity-groups`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.anti_affinity_group_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_create(&self) -> builder::AntiAffinityGroupCreate;
    /// Fetch anti-affinity group
    ///
    /// Sends a `GET` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}`
    ///
    /// Arguments:
    /// - `anti_affinity_group`: Name or ID of the anti affinity group
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.anti_affinity_group_view()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_view(&self) -> builder::AntiAffinityGroupView;
    /// Update anti-affinity group
    ///
    /// Sends a `PUT` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}`
    ///
    /// Arguments:
    /// - `anti_affinity_group`: Name or ID of the anti affinity group
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.anti_affinity_group_update()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_update(&self) -> builder::AntiAffinityGroupUpdate;
    /// Delete anti-affinity group
    ///
    /// Sends a `DELETE` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}`
    ///
    /// Arguments:
    /// - `anti_affinity_group`: Name or ID of the anti affinity group
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.anti_affinity_group_delete()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_delete(&self) -> builder::AntiAffinityGroupDelete;
    /// List anti-affinity group members
    ///
    /// Sends a `GET` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}/members`
    ///
    /// Arguments:
    /// - `anti_affinity_group`: Name or ID of the anti affinity group
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.anti_affinity_group_member_list()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_member_list(&self) -> builder::AntiAffinityGroupMemberList;
    /// Fetch anti-affinity group member
    ///
    /// Sends a `GET` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}/members/instance/
    /// {instance}`
    ///
    /// Arguments:
    /// - `anti_affinity_group`
    /// - `instance`
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.anti_affinity_group_member_instance_view()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_member_instance_view(
        &self,
    ) -> builder::AntiAffinityGroupMemberInstanceView;
    /// Add member to anti-affinity group
    ///
    /// Sends a `POST` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}/members/instance/
    /// {instance}`
    ///
    /// Arguments:
    /// - `anti_affinity_group`
    /// - `instance`
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.anti_affinity_group_member_instance_add()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_member_instance_add(
        &self,
    ) -> builder::AntiAffinityGroupMemberInstanceAdd;
    /// Remove member from anti-affinity group
    ///
    /// Sends a `DELETE` request to
    /// `/v1/anti-affinity-groups/{anti_affinity_group}/members/instance/
    /// {instance}`
    ///
    /// Arguments:
    /// - `anti_affinity_group`
    /// - `instance`
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.anti_affinity_group_member_instance_delete()
    ///    .anti_affinity_group(anti_affinity_group)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn anti_affinity_group_member_instance_delete(
        &self,
    ) -> builder::AntiAffinityGroupMemberInstanceDelete;
}

impl ClientAffinityExt for Client {
    fn anti_affinity_group_list(&self) -> builder::AntiAffinityGroupList {
        builder::AntiAffinityGroupList::new(self)
    }

    fn anti_affinity_group_create(&self) -> builder::AntiAffinityGroupCreate {
        builder::AntiAffinityGroupCreate::new(self)
    }

    fn anti_affinity_group_view(&self) -> builder::AntiAffinityGroupView {
        builder::AntiAffinityGroupView::new(self)
    }

    fn anti_affinity_group_update(&self) -> builder::AntiAffinityGroupUpdate {
        builder::AntiAffinityGroupUpdate::new(self)
    }

    fn anti_affinity_group_delete(&self) -> builder::AntiAffinityGroupDelete {
        builder::AntiAffinityGroupDelete::new(self)
    }

    fn anti_affinity_group_member_list(&self) -> builder::AntiAffinityGroupMemberList {
        builder::AntiAffinityGroupMemberList::new(self)
    }

    fn anti_affinity_group_member_instance_view(
        &self,
    ) -> builder::AntiAffinityGroupMemberInstanceView {
        builder::AntiAffinityGroupMemberInstanceView::new(self)
    }

    fn anti_affinity_group_member_instance_add(
        &self,
    ) -> builder::AntiAffinityGroupMemberInstanceAdd {
        builder::AntiAffinityGroupMemberInstanceAdd::new(self)
    }

    fn anti_affinity_group_member_instance_delete(
        &self,
    ) -> builder::AntiAffinityGroupMemberInstanceDelete {
        builder::AntiAffinityGroupMemberInstanceDelete::new(self)
    }
}

/// Virtual disks are used to store instance-local data which includes the
/// operating system.
pub trait ClientDisksExt {
    /// List disks
    ///
    /// Sends a `GET` request to `/v1/disks`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.disk_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_list(&self) -> builder::DiskList;
    /// Create a disk
    ///
    /// Sends a `POST` request to `/v1/disks`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.disk_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_create(&self) -> builder::DiskCreate;
    /// Fetch disk
    ///
    /// Sends a `GET` request to `/v1/disks/{disk}`
    ///
    /// Arguments:
    /// - `disk`: Name or ID of the disk
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.disk_view()
    ///    .disk(disk)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_view(&self) -> builder::DiskView;
    /// Delete disk
    ///
    /// Sends a `DELETE` request to `/v1/disks/{disk}`
    ///
    /// Arguments:
    /// - `disk`: Name or ID of the disk
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.disk_delete()
    ///    .disk(disk)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_delete(&self) -> builder::DiskDelete;
    /// Import blocks into disk
    ///
    /// Sends a `POST` request to `/v1/disks/{disk}/bulk-write`
    ///
    /// Arguments:
    /// - `disk`: Name or ID of the disk
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.disk_bulk_write_import()
    ///    .disk(disk)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_bulk_write_import(&self) -> builder::DiskBulkWriteImport;
    /// Start importing blocks into disk
    ///
    /// Start the process of importing blocks into a disk
    ///
    /// Sends a `POST` request to `/v1/disks/{disk}/bulk-write-start`
    ///
    /// Arguments:
    /// - `disk`: Name or ID of the disk
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.disk_bulk_write_import_start()
    ///    .disk(disk)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_bulk_write_import_start(&self) -> builder::DiskBulkWriteImportStart;
    /// Stop importing blocks into disk
    ///
    /// Stop the process of importing blocks into a disk
    ///
    /// Sends a `POST` request to `/v1/disks/{disk}/bulk-write-stop`
    ///
    /// Arguments:
    /// - `disk`: Name or ID of the disk
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.disk_bulk_write_import_stop()
    ///    .disk(disk)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_bulk_write_import_stop(&self) -> builder::DiskBulkWriteImportStop;
    /// Confirm disk block import completion
    ///
    /// Sends a `POST` request to `/v1/disks/{disk}/finalize`
    ///
    /// Arguments:
    /// - `disk`: Name or ID of the disk
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.disk_finalize_import()
    ///    .disk(disk)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_finalize_import(&self) -> builder::DiskFinalizeImport;
    /// Fetch disk metrics
    ///
    /// Sends a `GET` request to `/v1/disks/{disk}/metrics/{metric}`
    ///
    /// Arguments:
    /// - `disk`
    /// - `metric`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `order`: Query result order
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `start_time`: An inclusive start time of metrics.
    /// ```ignore
    /// let response = client.disk_metrics_list()
    ///    .disk(disk)
    ///    .metric(metric)
    ///    .end_time(end_time)
    ///    .limit(limit)
    ///    .order(order)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .start_time(start_time)
    ///    .send()
    ///    .await;
    /// ```
    fn disk_metrics_list(&self) -> builder::DiskMetricsList;
}

impl ClientDisksExt for Client {
    fn disk_list(&self) -> builder::DiskList {
        builder::DiskList::new(self)
    }

    fn disk_create(&self) -> builder::DiskCreate {
        builder::DiskCreate::new(self)
    }

    fn disk_view(&self) -> builder::DiskView {
        builder::DiskView::new(self)
    }

    fn disk_delete(&self) -> builder::DiskDelete {
        builder::DiskDelete::new(self)
    }

    fn disk_bulk_write_import(&self) -> builder::DiskBulkWriteImport {
        builder::DiskBulkWriteImport::new(self)
    }

    fn disk_bulk_write_import_start(&self) -> builder::DiskBulkWriteImportStart {
        builder::DiskBulkWriteImportStart::new(self)
    }

    fn disk_bulk_write_import_stop(&self) -> builder::DiskBulkWriteImportStop {
        builder::DiskBulkWriteImportStop::new(self)
    }

    fn disk_finalize_import(&self) -> builder::DiskFinalizeImport {
        builder::DiskFinalizeImport::new(self)
    }

    fn disk_metrics_list(&self) -> builder::DiskMetricsList {
        builder::DiskMetricsList::new(self)
    }
}

/// Floating IPs allow a project to allocate well-known IPs to instances.
pub trait ClientFloatingIpsExt {
    /// List floating IPs
    ///
    /// Sends a `GET` request to `/v1/floating-ips`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.floating_ip_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_list(&self) -> builder::FloatingIpList;
    /// Create floating IP
    ///
    /// Sends a `POST` request to `/v1/floating-ips`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.floating_ip_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_create(&self) -> builder::FloatingIpCreate;
    /// Fetch floating IP
    ///
    /// Sends a `GET` request to `/v1/floating-ips/{floating_ip}`
    ///
    /// Arguments:
    /// - `floating_ip`: Name or ID of the floating IP
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.floating_ip_view()
    ///    .floating_ip(floating_ip)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_view(&self) -> builder::FloatingIpView;
    /// Update floating IP
    ///
    /// Sends a `PUT` request to `/v1/floating-ips/{floating_ip}`
    ///
    /// Arguments:
    /// - `floating_ip`: Name or ID of the floating IP
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.floating_ip_update()
    ///    .floating_ip(floating_ip)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_update(&self) -> builder::FloatingIpUpdate;
    /// Delete floating IP
    ///
    /// Sends a `DELETE` request to `/v1/floating-ips/{floating_ip}`
    ///
    /// Arguments:
    /// - `floating_ip`: Name or ID of the floating IP
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.floating_ip_delete()
    ///    .floating_ip(floating_ip)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_delete(&self) -> builder::FloatingIpDelete;
    /// Attach floating IP
    ///
    /// Attach floating IP to an instance or other resource.
    ///
    /// Sends a `POST` request to `/v1/floating-ips/{floating_ip}/attach`
    ///
    /// Arguments:
    /// - `floating_ip`: Name or ID of the floating IP
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.floating_ip_attach()
    ///    .floating_ip(floating_ip)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_attach(&self) -> builder::FloatingIpAttach;
    /// Detach floating IP
    ///
    /// Sends a `POST` request to `/v1/floating-ips/{floating_ip}/detach`
    ///
    /// Arguments:
    /// - `floating_ip`: Name or ID of the floating IP
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.floating_ip_detach()
    ///    .floating_ip(floating_ip)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn floating_ip_detach(&self) -> builder::FloatingIpDetach;
}

impl ClientFloatingIpsExt for Client {
    fn floating_ip_list(&self) -> builder::FloatingIpList {
        builder::FloatingIpList::new(self)
    }

    fn floating_ip_create(&self) -> builder::FloatingIpCreate {
        builder::FloatingIpCreate::new(self)
    }

    fn floating_ip_view(&self) -> builder::FloatingIpView {
        builder::FloatingIpView::new(self)
    }

    fn floating_ip_update(&self) -> builder::FloatingIpUpdate {
        builder::FloatingIpUpdate::new(self)
    }

    fn floating_ip_delete(&self) -> builder::FloatingIpDelete {
        builder::FloatingIpDelete::new(self)
    }

    fn floating_ip_attach(&self) -> builder::FloatingIpAttach {
        builder::FloatingIpAttach::new(self)
    }

    fn floating_ip_detach(&self) -> builder::FloatingIpDetach {
        builder::FloatingIpDetach::new(self)
    }
}

/// TODO operations that will not ship to customers
pub trait ClientHiddenExt {
    /// Start an OAuth 2.0 Device Authorization Grant
    ///
    /// This endpoint is designed to be accessed from an *unauthenticated* API
    /// client. It generates and records a `device_code` and `user_code` which
    /// must be verified and confirmed prior to a token being granted.
    ///
    /// Sends a `POST` request to `/device/auth`
    ///
    /// ```ignore
    /// let response = client.device_auth_request()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn device_auth_request(&self) -> builder::DeviceAuthRequest;
    /// Confirm an OAuth 2.0 Device Authorization Grant
    ///
    /// This endpoint is designed to be accessed by the user agent (browser),
    /// not the client requesting the token. So we do not actually return the
    /// token here; it will be returned in response to the poll on
    /// `/device/token`.
    ///
    /// Sends a `POST` request to `/device/confirm`
    ///
    /// ```ignore
    /// let response = client.device_auth_confirm()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn device_auth_confirm(&self) -> builder::DeviceAuthConfirm;
    /// Request a device access token
    ///
    /// This endpoint should be polled by the client until the user code is
    /// verified and the grant is confirmed.
    ///
    /// Sends a `POST` request to `/device/token`
    ///
    /// ```ignore
    /// let response = client.device_access_token()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn device_access_token(&self) -> builder::DeviceAccessToken;
    /// List instrumentation probes
    ///
    /// Sends a `GET` request to `/experimental/v1/probes`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.probe_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn probe_list(&self) -> builder::ProbeList;
    /// Create instrumentation probe
    ///
    /// Sends a `POST` request to `/experimental/v1/probes`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.probe_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn probe_create(&self) -> builder::ProbeCreate;
    /// View instrumentation probe
    ///
    /// Sends a `GET` request to `/experimental/v1/probes/{probe}`
    ///
    /// Arguments:
    /// - `probe`: Name or ID of the probe
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.probe_view()
    ///    .probe(probe)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn probe_view(&self) -> builder::ProbeView;
    /// Delete instrumentation probe
    ///
    /// Sends a `DELETE` request to `/experimental/v1/probes/{probe}`
    ///
    /// Arguments:
    /// - `probe`: Name or ID of the probe
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.probe_delete()
    ///    .probe(probe)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn probe_delete(&self) -> builder::ProbeDelete;
    /// List all support bundles
    ///
    /// Sends a `GET` request to `/experimental/v1/system/support-bundles`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.support_bundle_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_list(&self) -> builder::SupportBundleList;
    /// Create a new support bundle
    ///
    /// Sends a `POST` request to `/experimental/v1/system/support-bundles`
    ///
    /// ```ignore
    /// let response = client.support_bundle_create()
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_create(&self) -> builder::SupportBundleCreate;
    /// View a support bundle
    ///
    /// Sends a `GET` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// ```ignore
    /// let response = client.support_bundle_view()
    ///    .support_bundle(support_bundle)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_view(&self) -> builder::SupportBundleView;
    /// Delete an existing support bundle
    ///
    /// May also be used to cancel a support bundle which is currently being
    /// collected, or to remove metadata for a support bundle that has failed.
    ///
    /// Sends a `DELETE` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// ```ignore
    /// let response = client.support_bundle_delete()
    ///    .support_bundle(support_bundle)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_delete(&self) -> builder::SupportBundleDelete;
    /// Download the contents of a support bundle
    ///
    /// Sends a `GET` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}/download`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// ```ignore
    /// let response = client.support_bundle_download()
    ///    .support_bundle(support_bundle)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_download(&self) -> builder::SupportBundleDownload;
    /// Download the metadata of a support bundle
    ///
    /// Sends a `HEAD` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}/download`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// ```ignore
    /// let response = client.support_bundle_head()
    ///    .support_bundle(support_bundle)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_head(&self) -> builder::SupportBundleHead;
    /// Download a file within a support bundle
    ///
    /// Sends a `GET` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}/download/
    /// {file}`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// - `file`: The file within the bundle to download
    /// ```ignore
    /// let response = client.support_bundle_download_file()
    ///    .support_bundle(support_bundle)
    ///    .file(file)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_download_file(&self) -> builder::SupportBundleDownloadFile;
    /// Download the metadata of a file within the support bundle
    ///
    /// Sends a `HEAD` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}/download/
    /// {file}`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// - `file`: The file within the bundle to download
    /// ```ignore
    /// let response = client.support_bundle_head_file()
    ///    .support_bundle(support_bundle)
    ///    .file(file)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_head_file(&self) -> builder::SupportBundleHeadFile;
    /// Download the index of a support bundle
    ///
    /// Sends a `GET` request to
    /// `/experimental/v1/system/support-bundles/{support_bundle}/index`
    ///
    /// Arguments:
    /// - `support_bundle`: ID of the support bundle
    /// ```ignore
    /// let response = client.support_bundle_index()
    ///    .support_bundle(support_bundle)
    ///    .send()
    ///    .await;
    /// ```
    fn support_bundle_index(&self) -> builder::SupportBundleIndex;
    /// List affinity groups
    ///
    /// Sends a `GET` request to `/v1/affinity-groups`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.affinity_group_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_list(&self) -> builder::AffinityGroupList;
    /// Create affinity group
    ///
    /// Sends a `POST` request to `/v1/affinity-groups`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.affinity_group_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_create(&self) -> builder::AffinityGroupCreate;
    /// Fetch affinity group
    ///
    /// Sends a `GET` request to `/v1/affinity-groups/{affinity_group}`
    ///
    /// Arguments:
    /// - `affinity_group`: Name or ID of the affinity group
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.affinity_group_view()
    ///    .affinity_group(affinity_group)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_view(&self) -> builder::AffinityGroupView;
    /// Update affinity group
    ///
    /// Sends a `PUT` request to `/v1/affinity-groups/{affinity_group}`
    ///
    /// Arguments:
    /// - `affinity_group`: Name or ID of the affinity group
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.affinity_group_update()
    ///    .affinity_group(affinity_group)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_update(&self) -> builder::AffinityGroupUpdate;
    /// Delete affinity group
    ///
    /// Sends a `DELETE` request to `/v1/affinity-groups/{affinity_group}`
    ///
    /// Arguments:
    /// - `affinity_group`: Name or ID of the affinity group
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.affinity_group_delete()
    ///    .affinity_group(affinity_group)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_delete(&self) -> builder::AffinityGroupDelete;
    /// List affinity group members
    ///
    /// Sends a `GET` request to `/v1/affinity-groups/{affinity_group}/members`
    ///
    /// Arguments:
    /// - `affinity_group`: Name or ID of the affinity group
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.affinity_group_member_list()
    ///    .affinity_group(affinity_group)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_member_list(&self) -> builder::AffinityGroupMemberList;
    /// Fetch affinity group member
    ///
    /// Sends a `GET` request to
    /// `/v1/affinity-groups/{affinity_group}/members/instance/{instance}`
    ///
    /// Arguments:
    /// - `affinity_group`
    /// - `instance`
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.affinity_group_member_instance_view()
    ///    .affinity_group(affinity_group)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_member_instance_view(&self) -> builder::AffinityGroupMemberInstanceView;
    /// Add member to affinity group
    ///
    /// Sends a `POST` request to
    /// `/v1/affinity-groups/{affinity_group}/members/instance/{instance}`
    ///
    /// Arguments:
    /// - `affinity_group`
    /// - `instance`
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.affinity_group_member_instance_add()
    ///    .affinity_group(affinity_group)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_member_instance_add(&self) -> builder::AffinityGroupMemberInstanceAdd;
    /// Remove member from affinity group
    ///
    /// Sends a `DELETE` request to
    /// `/v1/affinity-groups/{affinity_group}/members/instance/{instance}`
    ///
    /// Arguments:
    /// - `affinity_group`
    /// - `instance`
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.affinity_group_member_instance_delete()
    ///    .affinity_group(affinity_group)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn affinity_group_member_instance_delete(&self) -> builder::AffinityGroupMemberInstanceDelete;
    /// List affinity groups containing instance
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}/affinity-groups`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.instance_affinity_group_list()
    ///    .instance(instance)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_affinity_group_list(&self) -> builder::InstanceAffinityGroupList;
    /// Log user out of web console by deleting session on client and server
    ///
    /// Sends a `POST` request to `/v1/logout`
    ///
    /// ```ignore
    /// let response = client.logout()
    ///    .send()
    ///    .await;
    /// ```
    fn logout(&self) -> builder::Logout;
    /// Get the current target release of the rack's system software
    ///
    /// This may not correspond to the actual software running on the rack at
    /// the time of request; it is instead the release that the rack
    /// reconfigurator should be moving towards as a goal state. After some
    /// number of planning and execution phases, the software running on the
    /// rack should eventually correspond to the release described here.
    ///
    /// Sends a `GET` request to `/v1/system/update/target-release`
    ///
    /// ```ignore
    /// let response = client.target_release_view()
    ///    .send()
    ///    .await;
    /// ```
    fn target_release_view(&self) -> builder::TargetReleaseView;
    /// Set the current target release of the rack's system software
    ///
    /// The rack reconfigurator will treat the software specified here as a goal
    /// state for the rack's software, and attempt to asynchronously update to
    /// that release.
    ///
    /// Sends a `PUT` request to `/v1/system/update/target-release`
    ///
    /// ```ignore
    /// let response = client.target_release_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn target_release_update(&self) -> builder::TargetReleaseUpdate;
    /// Run project-scoped timeseries query
    ///
    /// Queries are written in OxQL. Project must be specified by name or ID in
    /// URL query parameter. The OxQL query will only return timeseries data
    /// from the specified project.
    ///
    /// Sends a `POST` request to `/v1/timeseries/query`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.timeseries_query()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn timeseries_query(&self) -> builder::TimeseriesQuery;
}

impl ClientHiddenExt for Client {
    fn device_auth_request(&self) -> builder::DeviceAuthRequest {
        builder::DeviceAuthRequest::new(self)
    }

    fn device_auth_confirm(&self) -> builder::DeviceAuthConfirm {
        builder::DeviceAuthConfirm::new(self)
    }

    fn device_access_token(&self) -> builder::DeviceAccessToken {
        builder::DeviceAccessToken::new(self)
    }

    fn probe_list(&self) -> builder::ProbeList {
        builder::ProbeList::new(self)
    }

    fn probe_create(&self) -> builder::ProbeCreate {
        builder::ProbeCreate::new(self)
    }

    fn probe_view(&self) -> builder::ProbeView {
        builder::ProbeView::new(self)
    }

    fn probe_delete(&self) -> builder::ProbeDelete {
        builder::ProbeDelete::new(self)
    }

    fn support_bundle_list(&self) -> builder::SupportBundleList {
        builder::SupportBundleList::new(self)
    }

    fn support_bundle_create(&self) -> builder::SupportBundleCreate {
        builder::SupportBundleCreate::new(self)
    }

    fn support_bundle_view(&self) -> builder::SupportBundleView {
        builder::SupportBundleView::new(self)
    }

    fn support_bundle_delete(&self) -> builder::SupportBundleDelete {
        builder::SupportBundleDelete::new(self)
    }

    fn support_bundle_download(&self) -> builder::SupportBundleDownload {
        builder::SupportBundleDownload::new(self)
    }

    fn support_bundle_head(&self) -> builder::SupportBundleHead {
        builder::SupportBundleHead::new(self)
    }

    fn support_bundle_download_file(&self) -> builder::SupportBundleDownloadFile {
        builder::SupportBundleDownloadFile::new(self)
    }

    fn support_bundle_head_file(&self) -> builder::SupportBundleHeadFile {
        builder::SupportBundleHeadFile::new(self)
    }

    fn support_bundle_index(&self) -> builder::SupportBundleIndex {
        builder::SupportBundleIndex::new(self)
    }

    fn affinity_group_list(&self) -> builder::AffinityGroupList {
        builder::AffinityGroupList::new(self)
    }

    fn affinity_group_create(&self) -> builder::AffinityGroupCreate {
        builder::AffinityGroupCreate::new(self)
    }

    fn affinity_group_view(&self) -> builder::AffinityGroupView {
        builder::AffinityGroupView::new(self)
    }

    fn affinity_group_update(&self) -> builder::AffinityGroupUpdate {
        builder::AffinityGroupUpdate::new(self)
    }

    fn affinity_group_delete(&self) -> builder::AffinityGroupDelete {
        builder::AffinityGroupDelete::new(self)
    }

    fn affinity_group_member_list(&self) -> builder::AffinityGroupMemberList {
        builder::AffinityGroupMemberList::new(self)
    }

    fn affinity_group_member_instance_view(&self) -> builder::AffinityGroupMemberInstanceView {
        builder::AffinityGroupMemberInstanceView::new(self)
    }

    fn affinity_group_member_instance_add(&self) -> builder::AffinityGroupMemberInstanceAdd {
        builder::AffinityGroupMemberInstanceAdd::new(self)
    }

    fn affinity_group_member_instance_delete(&self) -> builder::AffinityGroupMemberInstanceDelete {
        builder::AffinityGroupMemberInstanceDelete::new(self)
    }

    fn instance_affinity_group_list(&self) -> builder::InstanceAffinityGroupList {
        builder::InstanceAffinityGroupList::new(self)
    }

    fn logout(&self) -> builder::Logout {
        builder::Logout::new(self)
    }

    fn target_release_view(&self) -> builder::TargetReleaseView {
        builder::TargetReleaseView::new(self)
    }

    fn target_release_update(&self) -> builder::TargetReleaseUpdate {
        builder::TargetReleaseUpdate::new(self)
    }

    fn timeseries_query(&self) -> builder::TimeseriesQuery {
        builder::TimeseriesQuery::new(self)
    }
}

/// Images are read-only virtual disks that may be used to boot virtual
/// machines.
pub trait ClientImagesExt {
    /// List images
    ///
    /// List images which are global or scoped to the specified project. The
    /// images are returned sorted by creation date, with the most recent images
    /// appearing first.
    ///
    /// Sends a `GET` request to `/v1/images`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.image_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn image_list(&self) -> builder::ImageList;
    /// Create image
    ///
    /// Create a new image in a project.
    ///
    /// Sends a `POST` request to `/v1/images`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.image_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn image_create(&self) -> builder::ImageCreate;
    /// Fetch image
    ///
    /// Fetch the details for a specific image in a project.
    ///
    /// Sends a `GET` request to `/v1/images/{image}`
    ///
    /// Arguments:
    /// - `image`: Name or ID of the image
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.image_view()
    ///    .image(image)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn image_view(&self) -> builder::ImageView;
    /// Delete image
    ///
    /// Permanently delete an image from a project. This operation cannot be
    /// undone. Any instances in the project using the image will continue to
    /// run, however new instances can not be created with this image.
    ///
    /// Sends a `DELETE` request to `/v1/images/{image}`
    ///
    /// Arguments:
    /// - `image`: Name or ID of the image
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.image_delete()
    ///    .image(image)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn image_delete(&self) -> builder::ImageDelete;
    /// Demote silo image
    ///
    /// Demote silo image to be visible only to a specified project
    ///
    /// Sends a `POST` request to `/v1/images/{image}/demote`
    ///
    /// Arguments:
    /// - `image`: Name or ID of the image
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.image_demote()
    ///    .image(image)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn image_demote(&self) -> builder::ImageDemote;
    /// Promote project image
    ///
    /// Promote project image to be visible to all projects in the silo
    ///
    /// Sends a `POST` request to `/v1/images/{image}/promote`
    ///
    /// Arguments:
    /// - `image`: Name or ID of the image
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.image_promote()
    ///    .image(image)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn image_promote(&self) -> builder::ImagePromote;
}

impl ClientImagesExt for Client {
    fn image_list(&self) -> builder::ImageList {
        builder::ImageList::new(self)
    }

    fn image_create(&self) -> builder::ImageCreate {
        builder::ImageCreate::new(self)
    }

    fn image_view(&self) -> builder::ImageView {
        builder::ImageView::new(self)
    }

    fn image_delete(&self) -> builder::ImageDelete {
        builder::ImageDelete::new(self)
    }

    fn image_demote(&self) -> builder::ImageDemote {
        builder::ImageDemote::new(self)
    }

    fn image_promote(&self) -> builder::ImagePromote {
        builder::ImagePromote::new(self)
    }
}

/// Virtual machine instances are the basic unit of computation. These
/// operations are used for provisioning, controlling, and destroying instances.
pub trait ClientInstancesExt {
    /// List instances
    ///
    /// Sends a `GET` request to `/v1/instances`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.instance_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_list(&self) -> builder::InstanceList;
    /// Create instance
    ///
    /// Sends a `POST` request to `/v1/instances`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.instance_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_create(&self) -> builder::InstanceCreate;
    /// Fetch instance
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_view()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_view(&self) -> builder::InstanceView;
    /// Update instance
    ///
    /// Sends a `PUT` request to `/v1/instances/{instance}`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.instance_update()
    ///    .instance(instance)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_update(&self) -> builder::InstanceUpdate;
    /// Delete instance
    ///
    /// Sends a `DELETE` request to `/v1/instances/{instance}`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_delete()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_delete(&self) -> builder::InstanceDelete;
    /// List anti-affinity groups containing instance
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}/anti-affinity-groups`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.instance_anti_affinity_group_list()
    ///    .instance(instance)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_anti_affinity_group_list(&self) -> builder::InstanceAntiAffinityGroupList;
    /// List disks for instance
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}/disks`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.instance_disk_list()
    ///    .instance(instance)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_list(&self) -> builder::InstanceDiskList;
    /// Attach disk to instance
    ///
    /// Sends a `POST` request to `/v1/instances/{instance}/disks/attach`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.instance_disk_attach()
    ///    .instance(instance)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_attach(&self) -> builder::InstanceDiskAttach;
    /// Detach disk from instance
    ///
    /// Sends a `POST` request to `/v1/instances/{instance}/disks/detach`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.instance_disk_detach()
    ///    .instance(instance)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_disk_detach(&self) -> builder::InstanceDiskDetach;
    /// List external IP addresses
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}/external-ips`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_external_ip_list()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_external_ip_list(&self) -> builder::InstanceExternalIpList;
    /// Allocate and attach ephemeral IP to instance
    ///
    /// Sends a `POST` request to
    /// `/v1/instances/{instance}/external-ips/ephemeral`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.instance_ephemeral_ip_attach()
    ///    .instance(instance)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_ephemeral_ip_attach(&self) -> builder::InstanceEphemeralIpAttach;
    /// Detach and deallocate ephemeral IP from instance
    ///
    /// Sends a `DELETE` request to
    /// `/v1/instances/{instance}/external-ips/ephemeral`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_ephemeral_ip_detach()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_ephemeral_ip_detach(&self) -> builder::InstanceEphemeralIpDetach;
    /// Reboot an instance
    ///
    /// Sends a `POST` request to `/v1/instances/{instance}/reboot`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_reboot()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_reboot(&self) -> builder::InstanceReboot;
    /// Fetch instance serial console
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}/serial-console`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `from_start`: Character index in the serial buffer from which to read,
    ///   counting the bytes output since instance start. If this is not
    ///   provided, `most_recent` must be provided, and if this *is* provided,
    ///   `most_recent` must *not* be provided.
    /// - `max_bytes`: Maximum number of bytes of buffered serial console
    ///   contents to return. If the requested range runs to the end of the
    ///   available buffer, the data returned will be shorter than `max_bytes`.
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance. (See note on `from_start` about mutual
    ///   exclusivity)
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// ```ignore
    /// let response = client.instance_serial_console()
    ///    .instance(instance)
    ///    .from_start(from_start)
    ///    .max_bytes(max_bytes)
    ///    .most_recent(most_recent)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_serial_console(&self) -> builder::InstanceSerialConsole;
    /// Stream instance serial console
    ///
    /// Sends a `GET` request to
    /// `/v1/instances/{instance}/serial-console/stream`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `most_recent`: Character index in the serial buffer from which to
    ///   read, counting *backward* from the most recently buffered data
    ///   retrieved from the instance.
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// ```ignore
    /// let response = client.instance_serial_console_stream()
    ///    .instance(instance)
    ///    .most_recent(most_recent)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_serial_console_stream(&self) -> builder::InstanceSerialConsoleStream;
    /// List SSH public keys for instance
    ///
    /// List SSH public keys injected via cloud-init during instance creation.
    /// Note that this list is a snapshot in time and will not reflect updates
    /// made after the instance is created.
    ///
    /// Sends a `GET` request to `/v1/instances/{instance}/ssh-public-keys`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.instance_ssh_public_key_list()
    ///    .instance(instance)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_ssh_public_key_list(&self) -> builder::InstanceSshPublicKeyList;
    /// Boot instance
    ///
    /// Sends a `POST` request to `/v1/instances/{instance}/start`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_start()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_start(&self) -> builder::InstanceStart;
    /// Stop instance
    ///
    /// Sends a `POST` request to `/v1/instances/{instance}/stop`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.instance_stop()
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_stop(&self) -> builder::InstanceStop;
    /// List network interfaces
    ///
    /// Sends a `GET` request to `/v1/network-interfaces`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// ```ignore
    /// let response = client.instance_network_interface_list()
    ///    .instance(instance)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_list(&self) -> builder::InstanceNetworkInterfaceList;
    /// Create network interface
    ///
    /// Sends a `POST` request to `/v1/network-interfaces`
    ///
    /// Arguments:
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// - `body`
    /// ```ignore
    /// let response = client.instance_network_interface_create()
    ///    .instance(instance)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_create(&self) -> builder::InstanceNetworkInterfaceCreate;
    /// Fetch network interface
    ///
    /// Sends a `GET` request to `/v1/network-interfaces/{interface}`
    ///
    /// Arguments:
    /// - `interface`: Name or ID of the network interface
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// ```ignore
    /// let response = client.instance_network_interface_view()
    ///    .interface(interface)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_view(&self) -> builder::InstanceNetworkInterfaceView;
    /// Update network interface
    ///
    /// Sends a `PUT` request to `/v1/network-interfaces/{interface}`
    ///
    /// Arguments:
    /// - `interface`: Name or ID of the network interface
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// - `body`
    /// ```ignore
    /// let response = client.instance_network_interface_update()
    ///    .interface(interface)
    ///    .instance(instance)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_update(&self) -> builder::InstanceNetworkInterfaceUpdate;
    /// Delete network interface
    ///
    /// Note that the primary interface for an instance cannot be deleted if
    /// there are any secondary interfaces. A new primary interface must be
    /// designated first. The primary interface can be deleted if there are no
    /// secondary interfaces.
    ///
    /// Sends a `DELETE` request to `/v1/network-interfaces/{interface}`
    ///
    /// Arguments:
    /// - `interface`: Name or ID of the network interface
    /// - `instance`: Name or ID of the instance
    /// - `project`: Name or ID of the project, only required if `instance` is
    ///   provided as a `Name`
    /// ```ignore
    /// let response = client.instance_network_interface_delete()
    ///    .interface(interface)
    ///    .instance(instance)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn instance_network_interface_delete(&self) -> builder::InstanceNetworkInterfaceDelete;
}

impl ClientInstancesExt for Client {
    fn instance_list(&self) -> builder::InstanceList {
        builder::InstanceList::new(self)
    }

    fn instance_create(&self) -> builder::InstanceCreate {
        builder::InstanceCreate::new(self)
    }

    fn instance_view(&self) -> builder::InstanceView {
        builder::InstanceView::new(self)
    }

    fn instance_update(&self) -> builder::InstanceUpdate {
        builder::InstanceUpdate::new(self)
    }

    fn instance_delete(&self) -> builder::InstanceDelete {
        builder::InstanceDelete::new(self)
    }

    fn instance_anti_affinity_group_list(&self) -> builder::InstanceAntiAffinityGroupList {
        builder::InstanceAntiAffinityGroupList::new(self)
    }

    fn instance_disk_list(&self) -> builder::InstanceDiskList {
        builder::InstanceDiskList::new(self)
    }

    fn instance_disk_attach(&self) -> builder::InstanceDiskAttach {
        builder::InstanceDiskAttach::new(self)
    }

    fn instance_disk_detach(&self) -> builder::InstanceDiskDetach {
        builder::InstanceDiskDetach::new(self)
    }

    fn instance_external_ip_list(&self) -> builder::InstanceExternalIpList {
        builder::InstanceExternalIpList::new(self)
    }

    fn instance_ephemeral_ip_attach(&self) -> builder::InstanceEphemeralIpAttach {
        builder::InstanceEphemeralIpAttach::new(self)
    }

    fn instance_ephemeral_ip_detach(&self) -> builder::InstanceEphemeralIpDetach {
        builder::InstanceEphemeralIpDetach::new(self)
    }

    fn instance_reboot(&self) -> builder::InstanceReboot {
        builder::InstanceReboot::new(self)
    }

    fn instance_serial_console(&self) -> builder::InstanceSerialConsole {
        builder::InstanceSerialConsole::new(self)
    }

    fn instance_serial_console_stream(&self) -> builder::InstanceSerialConsoleStream {
        builder::InstanceSerialConsoleStream::new(self)
    }

    fn instance_ssh_public_key_list(&self) -> builder::InstanceSshPublicKeyList {
        builder::InstanceSshPublicKeyList::new(self)
    }

    fn instance_start(&self) -> builder::InstanceStart {
        builder::InstanceStart::new(self)
    }

    fn instance_stop(&self) -> builder::InstanceStop {
        builder::InstanceStop::new(self)
    }

    fn instance_network_interface_list(&self) -> builder::InstanceNetworkInterfaceList {
        builder::InstanceNetworkInterfaceList::new(self)
    }

    fn instance_network_interface_create(&self) -> builder::InstanceNetworkInterfaceCreate {
        builder::InstanceNetworkInterfaceCreate::new(self)
    }

    fn instance_network_interface_view(&self) -> builder::InstanceNetworkInterfaceView {
        builder::InstanceNetworkInterfaceView::new(self)
    }

    fn instance_network_interface_update(&self) -> builder::InstanceNetworkInterfaceUpdate {
        builder::InstanceNetworkInterfaceUpdate::new(self)
    }

    fn instance_network_interface_delete(&self) -> builder::InstanceNetworkInterfaceDelete {
        builder::InstanceNetworkInterfaceDelete::new(self)
    }
}

/// Authentication endpoints
pub trait ClientLoginExt {
    /// Authenticate a user via SAML
    ///
    /// Sends a `POST` request to `/login/{silo_name}/saml/{provider_name}`
    ///
    /// ```ignore
    /// let response = client.login_saml()
    ///    .silo_name(silo_name)
    ///    .provider_name(provider_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn login_saml(&self) -> builder::LoginSaml;
    /// Authenticate a user via username and password
    ///
    /// Sends a `POST` request to `/v1/login/{silo_name}/local`
    ///
    /// ```ignore
    /// let response = client.login_local()
    ///    .silo_name(silo_name)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn login_local(&self) -> builder::LoginLocal;
}

impl ClientLoginExt for Client {
    fn login_saml(&self) -> builder::LoginSaml {
        builder::LoginSaml::new(self)
    }

    fn login_local(&self) -> builder::LoginLocal {
        builder::LoginLocal::new(self)
    }
}

/// Silo-scoped metrics
pub trait ClientMetricsExt {
    /// View metrics
    ///
    /// View CPU, memory, or storage utilization metrics at the silo or project
    /// level.
    ///
    /// Sends a `GET` request to `/v1/metrics/{metric_name}`
    ///
    /// Arguments:
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `order`: Query result order
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `start_time`: An inclusive start time of metrics.
    /// ```ignore
    /// let response = client.silo_metric()
    ///    .metric_name(metric_name)
    ///    .end_time(end_time)
    ///    .limit(limit)
    ///    .order(order)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .start_time(start_time)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_metric(&self) -> builder::SiloMetric;
}

impl ClientMetricsExt for Client {
    fn silo_metric(&self) -> builder::SiloMetric {
        builder::SiloMetric::new(self)
    }
}

/// System-wide IAM policy
pub trait ClientPolicyExt {
    /// Fetch top-level IAM policy
    ///
    /// Sends a `GET` request to `/v1/system/policy`
    ///
    /// ```ignore
    /// let response = client.system_policy_view()
    ///    .send()
    ///    .await;
    /// ```
    fn system_policy_view(&self) -> builder::SystemPolicyView;
    /// Update top-level IAM policy
    ///
    /// Sends a `PUT` request to `/v1/system/policy`
    ///
    /// ```ignore
    /// let response = client.system_policy_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn system_policy_update(&self) -> builder::SystemPolicyUpdate;
}

impl ClientPolicyExt for Client {
    fn system_policy_view(&self) -> builder::SystemPolicyView {
        builder::SystemPolicyView::new(self)
    }

    fn system_policy_update(&self) -> builder::SystemPolicyUpdate {
        builder::SystemPolicyUpdate::new(self)
    }
}

/// Projects are a grouping of associated resources such as instances and disks
/// within a silo for purposes of billing and access control.
pub trait ClientProjectsExt {
    /// List IP pools
    ///
    /// Sends a `GET` request to `/v1/ip-pools`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.project_ip_pool_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_ip_pool_list(&self) -> builder::ProjectIpPoolList;
    /// Fetch IP pool
    ///
    /// Sends a `GET` request to `/v1/ip-pools/{pool}`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// ```ignore
    /// let response = client.project_ip_pool_view()
    ///    .pool(pool)
    ///    .send()
    ///    .await;
    /// ```
    fn project_ip_pool_view(&self) -> builder::ProjectIpPoolView;
    /// List projects
    ///
    /// Sends a `GET` request to `/v1/projects`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.project_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn project_list(&self) -> builder::ProjectList;
    /// Create project
    ///
    /// Sends a `POST` request to `/v1/projects`
    ///
    /// ```ignore
    /// let response = client.project_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_create(&self) -> builder::ProjectCreate;
    /// Fetch project
    ///
    /// Sends a `GET` request to `/v1/projects/{project}`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.project_view()
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn project_view(&self) -> builder::ProjectView;
    /// Update a project
    ///
    /// Sends a `PUT` request to `/v1/projects/{project}`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.project_update()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_update(&self) -> builder::ProjectUpdate;
    /// Delete project
    ///
    /// Sends a `DELETE` request to `/v1/projects/{project}`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.project_delete()
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn project_delete(&self) -> builder::ProjectDelete;
    /// Fetch project's IAM policy
    ///
    /// Sends a `GET` request to `/v1/projects/{project}/policy`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.project_policy_view()
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn project_policy_view(&self) -> builder::ProjectPolicyView;
    /// Update project's IAM policy
    ///
    /// Sends a `PUT` request to `/v1/projects/{project}/policy`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.project_policy_update()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn project_policy_update(&self) -> builder::ProjectPolicyUpdate;
}

impl ClientProjectsExt for Client {
    fn project_ip_pool_list(&self) -> builder::ProjectIpPoolList {
        builder::ProjectIpPoolList::new(self)
    }

    fn project_ip_pool_view(&self) -> builder::ProjectIpPoolView {
        builder::ProjectIpPoolView::new(self)
    }

    fn project_list(&self) -> builder::ProjectList {
        builder::ProjectList::new(self)
    }

    fn project_create(&self) -> builder::ProjectCreate {
        builder::ProjectCreate::new(self)
    }

    fn project_view(&self) -> builder::ProjectView {
        builder::ProjectView::new(self)
    }

    fn project_update(&self) -> builder::ProjectUpdate {
        builder::ProjectUpdate::new(self)
    }

    fn project_delete(&self) -> builder::ProjectDelete {
        builder::ProjectDelete::new(self)
    }

    fn project_policy_view(&self) -> builder::ProjectPolicyView {
        builder::ProjectPolicyView::new(self)
    }

    fn project_policy_update(&self) -> builder::ProjectPolicyUpdate {
        builder::ProjectPolicyUpdate::new(self)
    }
}

/// Roles are a component of Identity and Access Management (IAM) that allow a
/// user or agent account access to additional permissions.
pub trait ClientRolesExt {
    /// List built-in roles
    ///
    /// Sends a `GET` request to `/v1/system/roles`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// ```ignore
    /// let response = client.role_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn role_list(&self) -> builder::RoleList;
    /// Fetch built-in role
    ///
    /// Sends a `GET` request to `/v1/system/roles/{role_name}`
    ///
    /// Arguments:
    /// - `role_name`: The built-in role's unique name.
    /// ```ignore
    /// let response = client.role_view()
    ///    .role_name(role_name)
    ///    .send()
    ///    .await;
    /// ```
    fn role_view(&self) -> builder::RoleView;
}

impl ClientRolesExt for Client {
    fn role_list(&self) -> builder::RoleList {
        builder::RoleList::new(self)
    }

    fn role_view(&self) -> builder::RoleView {
        builder::RoleView::new(self)
    }
}

/// Information pertaining to the current session.
pub trait ClientSessionExt {
    /// Fetch user for current session
    ///
    /// Sends a `GET` request to `/v1/me`
    ///
    /// ```ignore
    /// let response = client.current_user_view()
    ///    .send()
    ///    .await;
    /// ```
    fn current_user_view(&self) -> builder::CurrentUserView;
    /// Fetch current user's groups
    ///
    /// Sends a `GET` request to `/v1/me/groups`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.current_user_groups()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn current_user_groups(&self) -> builder::CurrentUserGroups;
    /// List SSH public keys
    ///
    /// Lists SSH public keys for the currently authenticated user.
    ///
    /// Sends a `GET` request to `/v1/me/ssh-keys`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.current_user_ssh_key_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn current_user_ssh_key_list(&self) -> builder::CurrentUserSshKeyList;
    /// Create SSH public key
    ///
    /// Create an SSH public key for the currently authenticated user.
    ///
    /// Sends a `POST` request to `/v1/me/ssh-keys`
    ///
    /// ```ignore
    /// let response = client.current_user_ssh_key_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn current_user_ssh_key_create(&self) -> builder::CurrentUserSshKeyCreate;
    /// Fetch SSH public key
    ///
    /// Fetch SSH public key associated with the currently authenticated user.
    ///
    /// Sends a `GET` request to `/v1/me/ssh-keys/{ssh_key}`
    ///
    /// Arguments:
    /// - `ssh_key`: Name or ID of the SSH key
    /// ```ignore
    /// let response = client.current_user_ssh_key_view()
    ///    .ssh_key(ssh_key)
    ///    .send()
    ///    .await;
    /// ```
    fn current_user_ssh_key_view(&self) -> builder::CurrentUserSshKeyView;
    /// Delete SSH public key
    ///
    /// Delete an SSH public key associated with the currently authenticated
    /// user.
    ///
    /// Sends a `DELETE` request to `/v1/me/ssh-keys/{ssh_key}`
    ///
    /// Arguments:
    /// - `ssh_key`: Name or ID of the SSH key
    /// ```ignore
    /// let response = client.current_user_ssh_key_delete()
    ///    .ssh_key(ssh_key)
    ///    .send()
    ///    .await;
    /// ```
    fn current_user_ssh_key_delete(&self) -> builder::CurrentUserSshKeyDelete;
}

impl ClientSessionExt for Client {
    fn current_user_view(&self) -> builder::CurrentUserView {
        builder::CurrentUserView::new(self)
    }

    fn current_user_groups(&self) -> builder::CurrentUserGroups {
        builder::CurrentUserGroups::new(self)
    }

    fn current_user_ssh_key_list(&self) -> builder::CurrentUserSshKeyList {
        builder::CurrentUserSshKeyList::new(self)
    }

    fn current_user_ssh_key_create(&self) -> builder::CurrentUserSshKeyCreate {
        builder::CurrentUserSshKeyCreate::new(self)
    }

    fn current_user_ssh_key_view(&self) -> builder::CurrentUserSshKeyView {
        builder::CurrentUserSshKeyView::new(self)
    }

    fn current_user_ssh_key_delete(&self) -> builder::CurrentUserSshKeyDelete {
        builder::CurrentUserSshKeyDelete::new(self)
    }
}

/// Silos represent a logical partition of users and resources.
pub trait ClientSilosExt {
    /// List certificates for external endpoints
    ///
    /// Returns a list of TLS certificates used for the external API (for the
    /// current Silo).  These are sorted by creation date, with the most recent
    /// certificates appearing first.
    ///
    /// Sends a `GET` request to `/v1/certificates`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.certificate_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_list(&self) -> builder::CertificateList;
    /// Create new system-wide x.509 certificate
    ///
    /// This certificate is automatically used by the Oxide Control plane to
    /// serve external connections.
    ///
    /// Sends a `POST` request to `/v1/certificates`
    ///
    /// ```ignore
    /// let response = client.certificate_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_create(&self) -> builder::CertificateCreate;
    /// Fetch certificate
    ///
    /// Returns the details of a specific certificate
    ///
    /// Sends a `GET` request to `/v1/certificates/{certificate}`
    ///
    /// Arguments:
    /// - `certificate`: Name or ID of the certificate
    /// ```ignore
    /// let response = client.certificate_view()
    ///    .certificate(certificate)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_view(&self) -> builder::CertificateView;
    /// Delete certificate
    ///
    /// Permanently delete a certificate. This operation cannot be undone.
    ///
    /// Sends a `DELETE` request to `/v1/certificates/{certificate}`
    ///
    /// Arguments:
    /// - `certificate`: Name or ID of the certificate
    /// ```ignore
    /// let response = client.certificate_delete()
    ///    .certificate(certificate)
    ///    .send()
    ///    .await;
    /// ```
    fn certificate_delete(&self) -> builder::CertificateDelete;
    /// List groups
    ///
    /// Sends a `GET` request to `/v1/groups`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.group_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn group_list(&self) -> builder::GroupList;
    /// Fetch group
    ///
    /// Sends a `GET` request to `/v1/groups/{group_id}`
    ///
    /// Arguments:
    /// - `group_id`: ID of the group
    /// ```ignore
    /// let response = client.group_view()
    ///    .group_id(group_id)
    ///    .send()
    ///    .await;
    /// ```
    fn group_view(&self) -> builder::GroupView;
    /// Fetch current silo's IAM policy
    ///
    /// Sends a `GET` request to `/v1/policy`
    ///
    /// ```ignore
    /// let response = client.policy_view()
    ///    .send()
    ///    .await;
    /// ```
    fn policy_view(&self) -> builder::PolicyView;
    /// Update current silo's IAM policy
    ///
    /// Sends a `PUT` request to `/v1/policy`
    ///
    /// ```ignore
    /// let response = client.policy_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn policy_update(&self) -> builder::PolicyUpdate;
    /// List users
    ///
    /// Sends a `GET` request to `/v1/users`
    ///
    /// Arguments:
    /// - `group`
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.user_list()
    ///    .group(group)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn user_list(&self) -> builder::UserList;
    /// Fetch resource utilization for user's current silo
    ///
    /// Sends a `GET` request to `/v1/utilization`
    ///
    /// ```ignore
    /// let response = client.utilization_view()
    ///    .send()
    ///    .await;
    /// ```
    fn utilization_view(&self) -> builder::UtilizationView;
}

impl ClientSilosExt for Client {
    fn certificate_list(&self) -> builder::CertificateList {
        builder::CertificateList::new(self)
    }

    fn certificate_create(&self) -> builder::CertificateCreate {
        builder::CertificateCreate::new(self)
    }

    fn certificate_view(&self) -> builder::CertificateView {
        builder::CertificateView::new(self)
    }

    fn certificate_delete(&self) -> builder::CertificateDelete {
        builder::CertificateDelete::new(self)
    }

    fn group_list(&self) -> builder::GroupList {
        builder::GroupList::new(self)
    }

    fn group_view(&self) -> builder::GroupView {
        builder::GroupView::new(self)
    }

    fn policy_view(&self) -> builder::PolicyView {
        builder::PolicyView::new(self)
    }

    fn policy_update(&self) -> builder::PolicyUpdate {
        builder::PolicyUpdate::new(self)
    }

    fn user_list(&self) -> builder::UserList {
        builder::UserList::new(self)
    }

    fn utilization_view(&self) -> builder::UtilizationView {
        builder::UtilizationView::new(self)
    }
}

/// Snapshots of virtual disks at a particular point in time.
pub trait ClientSnapshotsExt {
    /// List snapshots
    ///
    /// Sends a `GET` request to `/v1/snapshots`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.snapshot_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_list(&self) -> builder::SnapshotList;
    /// Create snapshot
    ///
    /// Creates a point-in-time snapshot from a disk.
    ///
    /// Sends a `POST` request to `/v1/snapshots`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.snapshot_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_create(&self) -> builder::SnapshotCreate;
    /// Fetch snapshot
    ///
    /// Sends a `GET` request to `/v1/snapshots/{snapshot}`
    ///
    /// Arguments:
    /// - `snapshot`: Name or ID of the snapshot
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.snapshot_view()
    ///    .snapshot(snapshot)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_view(&self) -> builder::SnapshotView;
    /// Delete snapshot
    ///
    /// Sends a `DELETE` request to `/v1/snapshots/{snapshot}`
    ///
    /// Arguments:
    /// - `snapshot`: Name or ID of the snapshot
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.snapshot_delete()
    ///    .snapshot(snapshot)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn snapshot_delete(&self) -> builder::SnapshotDelete;
}

impl ClientSnapshotsExt for Client {
    fn snapshot_list(&self) -> builder::SnapshotList {
        builder::SnapshotList::new(self)
    }

    fn snapshot_create(&self) -> builder::SnapshotCreate {
        builder::SnapshotCreate::new(self)
    }

    fn snapshot_view(&self) -> builder::SnapshotView {
        builder::SnapshotView::new(self)
    }

    fn snapshot_delete(&self) -> builder::SnapshotDelete {
        builder::SnapshotDelete::new(self)
    }
}

/// These operations pertain to hardware inventory and management. Racks are the
/// unit of expansion of an Oxide deployment. Racks are in turn composed of
/// sleds, switches, power supplies, and a cabled backplane.
pub trait ClientSystemHardwareExt {
    /// List physical disks
    ///
    /// Sends a `GET` request to `/v1/system/hardware/disks`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.physical_disk_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn physical_disk_list(&self) -> builder::PhysicalDiskList;
    /// Get a physical disk
    ///
    /// Sends a `GET` request to `/v1/system/hardware/disks/{disk_id}`
    ///
    /// Arguments:
    /// - `disk_id`: ID of the physical disk
    /// ```ignore
    /// let response = client.physical_disk_view()
    ///    .disk_id(disk_id)
    ///    .send()
    ///    .await;
    /// ```
    fn physical_disk_view(&self) -> builder::PhysicalDiskView;
    /// List racks
    ///
    /// Sends a `GET` request to `/v1/system/hardware/racks`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.rack_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn rack_list(&self) -> builder::RackList;
    /// Fetch rack
    ///
    /// Sends a `GET` request to `/v1/system/hardware/racks/{rack_id}`
    ///
    /// Arguments:
    /// - `rack_id`: ID of the rack
    /// ```ignore
    /// let response = client.rack_view()
    ///    .rack_id(rack_id)
    ///    .send()
    ///    .await;
    /// ```
    fn rack_view(&self) -> builder::RackView;
    /// List sleds
    ///
    /// Sends a `GET` request to `/v1/system/hardware/sleds`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.sled_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_list(&self) -> builder::SledList;
    /// Add sled to initialized rack
    ///
    /// Sends a `POST` request to `/v1/system/hardware/sleds`
    ///
    /// ```ignore
    /// let response = client.sled_add()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_add(&self) -> builder::SledAdd;
    /// Fetch sled
    ///
    /// Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}`
    ///
    /// Arguments:
    /// - `sled_id`: ID of the sled
    /// ```ignore
    /// let response = client.sled_view()
    ///    .sled_id(sled_id)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_view(&self) -> builder::SledView;
    /// List physical disks attached to sleds
    ///
    /// Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}/disks`
    ///
    /// Arguments:
    /// - `sled_id`: ID of the sled
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.sled_physical_disk_list()
    ///    .sled_id(sled_id)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_physical_disk_list(&self) -> builder::SledPhysicalDiskList;
    /// List instances running on given sled
    ///
    /// Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}/instances`
    ///
    /// Arguments:
    /// - `sled_id`: ID of the sled
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.sled_instance_list()
    ///    .sled_id(sled_id)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_instance_list(&self) -> builder::SledInstanceList;
    /// Set sled provision policy
    ///
    /// Sends a `PUT` request to
    /// `/v1/system/hardware/sleds/{sled_id}/provision-policy`
    ///
    /// Arguments:
    /// - `sled_id`: ID of the sled
    /// - `body`
    /// ```ignore
    /// let response = client.sled_set_provision_policy()
    ///    .sled_id(sled_id)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_set_provision_policy(&self) -> builder::SledSetProvisionPolicy;
    /// List uninitialized sleds
    ///
    /// Sends a `GET` request to `/v1/system/hardware/sleds-uninitialized`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// ```ignore
    /// let response = client.sled_list_uninitialized()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn sled_list_uninitialized(&self) -> builder::SledListUninitialized;
    /// List switch ports
    ///
    /// Sends a `GET` request to `/v1/system/hardware/switch-port`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// - `switch_port_id`: An optional switch port id to use when listing
    ///   switch ports.
    /// ```ignore
    /// let response = client.networking_switch_port_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .switch_port_id(switch_port_id)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_list(&self) -> builder::NetworkingSwitchPortList;
    /// Apply switch port settings
    ///
    /// Sends a `POST` request to
    /// `/v1/system/hardware/switch-port/{port}/settings`
    ///
    /// Arguments:
    /// - `port`: A name to use when selecting switch ports.
    /// - `rack_id`: A rack id to use when selecting switch ports.
    /// - `switch_location`: A switch location to use when selecting switch
    ///   ports.
    /// - `body`
    /// ```ignore
    /// let response = client.networking_switch_port_apply_settings()
    ///    .port(port)
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_apply_settings(&self) -> builder::NetworkingSwitchPortApplySettings;
    /// Clear switch port settings
    ///
    /// Sends a `DELETE` request to
    /// `/v1/system/hardware/switch-port/{port}/settings`
    ///
    /// Arguments:
    /// - `port`: A name to use when selecting switch ports.
    /// - `rack_id`: A rack id to use when selecting switch ports.
    /// - `switch_location`: A switch location to use when selecting switch
    ///   ports.
    /// ```ignore
    /// let response = client.networking_switch_port_clear_settings()
    ///    .port(port)
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_clear_settings(&self) -> builder::NetworkingSwitchPortClearSettings;
    /// Get switch port status
    ///
    /// Sends a `GET` request to `/v1/system/hardware/switch-port/{port}/status`
    ///
    /// Arguments:
    /// - `port`: A name to use when selecting switch ports.
    /// - `rack_id`: A rack id to use when selecting switch ports.
    /// - `switch_location`: A switch location to use when selecting switch
    ///   ports.
    /// ```ignore
    /// let response = client.networking_switch_port_status()
    ///    .port(port)
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_status(&self) -> builder::NetworkingSwitchPortStatus;
    /// List switches
    ///
    /// Sends a `GET` request to `/v1/system/hardware/switches`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.switch_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn switch_list(&self) -> builder::SwitchList;
    /// Fetch switch
    ///
    /// Sends a `GET` request to `/v1/system/hardware/switches/{switch_id}`
    ///
    /// Arguments:
    /// - `switch_id`: ID of the switch
    /// ```ignore
    /// let response = client.switch_view()
    ///    .switch_id(switch_id)
    ///    .send()
    ///    .await;
    /// ```
    fn switch_view(&self) -> builder::SwitchView;
}

impl ClientSystemHardwareExt for Client {
    fn physical_disk_list(&self) -> builder::PhysicalDiskList {
        builder::PhysicalDiskList::new(self)
    }

    fn physical_disk_view(&self) -> builder::PhysicalDiskView {
        builder::PhysicalDiskView::new(self)
    }

    fn rack_list(&self) -> builder::RackList {
        builder::RackList::new(self)
    }

    fn rack_view(&self) -> builder::RackView {
        builder::RackView::new(self)
    }

    fn sled_list(&self) -> builder::SledList {
        builder::SledList::new(self)
    }

    fn sled_add(&self) -> builder::SledAdd {
        builder::SledAdd::new(self)
    }

    fn sled_view(&self) -> builder::SledView {
        builder::SledView::new(self)
    }

    fn sled_physical_disk_list(&self) -> builder::SledPhysicalDiskList {
        builder::SledPhysicalDiskList::new(self)
    }

    fn sled_instance_list(&self) -> builder::SledInstanceList {
        builder::SledInstanceList::new(self)
    }

    fn sled_set_provision_policy(&self) -> builder::SledSetProvisionPolicy {
        builder::SledSetProvisionPolicy::new(self)
    }

    fn sled_list_uninitialized(&self) -> builder::SledListUninitialized {
        builder::SledListUninitialized::new(self)
    }

    fn networking_switch_port_list(&self) -> builder::NetworkingSwitchPortList {
        builder::NetworkingSwitchPortList::new(self)
    }

    fn networking_switch_port_apply_settings(&self) -> builder::NetworkingSwitchPortApplySettings {
        builder::NetworkingSwitchPortApplySettings::new(self)
    }

    fn networking_switch_port_clear_settings(&self) -> builder::NetworkingSwitchPortClearSettings {
        builder::NetworkingSwitchPortClearSettings::new(self)
    }

    fn networking_switch_port_status(&self) -> builder::NetworkingSwitchPortStatus {
        builder::NetworkingSwitchPortStatus::new(self)
    }

    fn switch_list(&self) -> builder::SwitchList {
        builder::SwitchList::new(self)
    }

    fn switch_view(&self) -> builder::SwitchView {
        builder::SwitchView::new(self)
    }
}

/// IP pools are collections of external IPs that can be assigned to silos. When
/// a pool is linked to a silo, users in that silo can allocate IPs from the
/// pool for their instances.
pub trait ClientSystemIpPoolsExt {
    /// List IP pools
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.ip_pool_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_list(&self) -> builder::IpPoolList;
    /// Create IP pool
    ///
    /// Sends a `POST` request to `/v1/system/ip-pools`
    ///
    /// ```ignore
    /// let response = client.ip_pool_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_create(&self) -> builder::IpPoolCreate;
    /// Fetch IP pool
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools/{pool}`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// ```ignore
    /// let response = client.ip_pool_view()
    ///    .pool(pool)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_view(&self) -> builder::IpPoolView;
    /// Update IP pool
    ///
    /// Sends a `PUT` request to `/v1/system/ip-pools/{pool}`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `body`
    /// ```ignore
    /// let response = client.ip_pool_update()
    ///    .pool(pool)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_update(&self) -> builder::IpPoolUpdate;
    /// Delete IP pool
    ///
    /// Sends a `DELETE` request to `/v1/system/ip-pools/{pool}`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// ```ignore
    /// let response = client.ip_pool_delete()
    ///    .pool(pool)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_delete(&self) -> builder::IpPoolDelete;
    /// List ranges for IP pool
    ///
    /// Ranges are ordered by their first address.
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools/{pool}/ranges`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// ```ignore
    /// let response = client.ip_pool_range_list()
    ///    .pool(pool)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_range_list(&self) -> builder::IpPoolRangeList;
    /// Add range to IP pool
    ///
    /// IPv6 ranges are not allowed yet.
    ///
    /// Sends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/add`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `body`
    /// ```ignore
    /// let response = client.ip_pool_range_add()
    ///    .pool(pool)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_range_add(&self) -> builder::IpPoolRangeAdd;
    /// Remove range from IP pool
    ///
    /// Sends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/remove`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `body`
    /// ```ignore
    /// let response = client.ip_pool_range_remove()
    ///    .pool(pool)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_range_remove(&self) -> builder::IpPoolRangeRemove;
    /// List IP pool's linked silos
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools/{pool}/silos`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.ip_pool_silo_list()
    ///    .pool(pool)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_silo_list(&self) -> builder::IpPoolSiloList;
    /// Link IP pool to silo
    ///
    /// Users in linked silos can allocate external IPs from this pool for their
    /// instances. A silo can have at most one default pool. IPs are allocated
    /// from the default pool when users ask for one without specifying a pool.
    ///
    /// Sends a `POST` request to `/v1/system/ip-pools/{pool}/silos`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `body`
    /// ```ignore
    /// let response = client.ip_pool_silo_link()
    ///    .pool(pool)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_silo_link(&self) -> builder::IpPoolSiloLink;
    /// Make IP pool default for silo
    ///
    /// When a user asks for an IP (e.g., at instance create time) without
    /// specifying a pool, the IP comes from the default pool if a default is
    /// configured. When a pool is made the default for a silo, any existing
    /// default will remain linked to the silo, but will no longer be the
    /// default.
    ///
    /// Sends a `PUT` request to `/v1/system/ip-pools/{pool}/silos/{silo}`
    ///
    /// ```ignore
    /// let response = client.ip_pool_silo_update()
    ///    .pool(pool)
    ///    .silo(silo)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_silo_update(&self) -> builder::IpPoolSiloUpdate;
    /// Unlink IP pool from silo
    ///
    /// Will fail if there are any outstanding IPs allocated in the silo.
    ///
    /// Sends a `DELETE` request to `/v1/system/ip-pools/{pool}/silos/{silo}`
    ///
    /// ```ignore
    /// let response = client.ip_pool_silo_unlink()
    ///    .pool(pool)
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_silo_unlink(&self) -> builder::IpPoolSiloUnlink;
    /// Fetch IP pool utilization
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools/{pool}/utilization`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// ```ignore
    /// let response = client.ip_pool_utilization_view()
    ///    .pool(pool)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_utilization_view(&self) -> builder::IpPoolUtilizationView;
    /// Fetch Oxide service IP pool
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools-service`
    ///
    /// ```ignore
    /// let response = client.ip_pool_service_view()
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_view(&self) -> builder::IpPoolServiceView;
    /// List IP ranges for the Oxide service pool
    ///
    /// Ranges are ordered by their first address.
    ///
    /// Sends a `GET` request to `/v1/system/ip-pools-service/ranges`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// ```ignore
    /// let response = client.ip_pool_service_range_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_range_list(&self) -> builder::IpPoolServiceRangeList;
    /// Add IP range to Oxide service pool
    ///
    /// IPv6 ranges are not allowed yet.
    ///
    /// Sends a `POST` request to `/v1/system/ip-pools-service/ranges/add`
    ///
    /// ```ignore
    /// let response = client.ip_pool_service_range_add()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_range_add(&self) -> builder::IpPoolServiceRangeAdd;
    /// Remove IP range from Oxide service pool
    ///
    /// Sends a `POST` request to `/v1/system/ip-pools-service/ranges/remove`
    ///
    /// ```ignore
    /// let response = client.ip_pool_service_range_remove()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn ip_pool_service_range_remove(&self) -> builder::IpPoolServiceRangeRemove;
}

impl ClientSystemIpPoolsExt for Client {
    fn ip_pool_list(&self) -> builder::IpPoolList {
        builder::IpPoolList::new(self)
    }

    fn ip_pool_create(&self) -> builder::IpPoolCreate {
        builder::IpPoolCreate::new(self)
    }

    fn ip_pool_view(&self) -> builder::IpPoolView {
        builder::IpPoolView::new(self)
    }

    fn ip_pool_update(&self) -> builder::IpPoolUpdate {
        builder::IpPoolUpdate::new(self)
    }

    fn ip_pool_delete(&self) -> builder::IpPoolDelete {
        builder::IpPoolDelete::new(self)
    }

    fn ip_pool_range_list(&self) -> builder::IpPoolRangeList {
        builder::IpPoolRangeList::new(self)
    }

    fn ip_pool_range_add(&self) -> builder::IpPoolRangeAdd {
        builder::IpPoolRangeAdd::new(self)
    }

    fn ip_pool_range_remove(&self) -> builder::IpPoolRangeRemove {
        builder::IpPoolRangeRemove::new(self)
    }

    fn ip_pool_silo_list(&self) -> builder::IpPoolSiloList {
        builder::IpPoolSiloList::new(self)
    }

    fn ip_pool_silo_link(&self) -> builder::IpPoolSiloLink {
        builder::IpPoolSiloLink::new(self)
    }

    fn ip_pool_silo_update(&self) -> builder::IpPoolSiloUpdate {
        builder::IpPoolSiloUpdate::new(self)
    }

    fn ip_pool_silo_unlink(&self) -> builder::IpPoolSiloUnlink {
        builder::IpPoolSiloUnlink::new(self)
    }

    fn ip_pool_utilization_view(&self) -> builder::IpPoolUtilizationView {
        builder::IpPoolUtilizationView::new(self)
    }

    fn ip_pool_service_view(&self) -> builder::IpPoolServiceView {
        builder::IpPoolServiceView::new(self)
    }

    fn ip_pool_service_range_list(&self) -> builder::IpPoolServiceRangeList {
        builder::IpPoolServiceRangeList::new(self)
    }

    fn ip_pool_service_range_add(&self) -> builder::IpPoolServiceRangeAdd {
        builder::IpPoolServiceRangeAdd::new(self)
    }

    fn ip_pool_service_range_remove(&self) -> builder::IpPoolServiceRangeRemove {
        builder::IpPoolServiceRangeRemove::new(self)
    }
}

/// Metrics provide insight into the operation of the Oxide deployment. These
/// include telemetry on hardware and software components that can be used to
/// understand the current state as well as to diagnose issues.
pub trait ClientSystemMetricsExt {
    /// View metrics
    ///
    /// View CPU, memory, or storage utilization metrics at the fleet or silo
    /// level.
    ///
    /// Sends a `GET` request to `/v1/system/metrics/{metric_name}`
    ///
    /// Arguments:
    /// - `metric_name`
    /// - `end_time`: An exclusive end time of metrics.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `order`: Query result order
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `silo`: Name or ID of the silo
    /// - `start_time`: An inclusive start time of metrics.
    /// ```ignore
    /// let response = client.system_metric()
    ///    .metric_name(metric_name)
    ///    .end_time(end_time)
    ///    .limit(limit)
    ///    .order(order)
    ///    .page_token(page_token)
    ///    .silo(silo)
    ///    .start_time(start_time)
    ///    .send()
    ///    .await;
    /// ```
    fn system_metric(&self) -> builder::SystemMetric;
    /// Run timeseries query
    ///
    /// Queries are written in OxQL.
    ///
    /// Sends a `POST` request to `/v1/system/timeseries/query`
    ///
    /// ```ignore
    /// let response = client.system_timeseries_query()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn system_timeseries_query(&self) -> builder::SystemTimeseriesQuery;
    /// List timeseries schemas
    ///
    /// Sends a `GET` request to `/v1/system/timeseries/schemas`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// ```ignore
    /// let response = client.system_timeseries_schema_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn system_timeseries_schema_list(&self) -> builder::SystemTimeseriesSchemaList;
}

impl ClientSystemMetricsExt for Client {
    fn system_metric(&self) -> builder::SystemMetric {
        builder::SystemMetric::new(self)
    }

    fn system_timeseries_query(&self) -> builder::SystemTimeseriesQuery {
        builder::SystemTimeseriesQuery::new(self)
    }

    fn system_timeseries_schema_list(&self) -> builder::SystemTimeseriesSchemaList {
        builder::SystemTimeseriesSchemaList::new(self)
    }
}

/// This provides rack-level network configuration.
pub trait ClientSystemNetworkingExt {
    /// Fetch the LLDP neighbors seen on a switch port
    ///
    /// Sends a `GET` request to
    /// `/v1/system/hardware/rack-switch-port/{rack_id}/{switch_location}/
    /// {port}/lldp/neighbors`
    ///
    /// Arguments:
    /// - `rack_id`: A rack id to use when selecting switch ports.
    /// - `switch_location`: A switch location to use when selecting switch
    ///   ports.
    /// - `port`: A name to use when selecting switch ports.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_switch_port_lldp_neighbors()
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .port(port)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_lldp_neighbors(&self) -> builder::NetworkingSwitchPortLldpNeighbors;
    /// Fetch the LLDP configuration for a switch port
    ///
    /// Sends a `GET` request to
    /// `/v1/system/hardware/switch-port/{port}/lldp/config`
    ///
    /// Arguments:
    /// - `port`: A name to use when selecting switch ports.
    /// - `rack_id`: A rack id to use when selecting switch ports.
    /// - `switch_location`: A switch location to use when selecting switch
    ///   ports.
    /// ```ignore
    /// let response = client.networking_switch_port_lldp_config_view()
    ///    .port(port)
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_lldp_config_view(
        &self,
    ) -> builder::NetworkingSwitchPortLldpConfigView;
    /// Update the LLDP configuration for a switch port
    ///
    /// Sends a `POST` request to
    /// `/v1/system/hardware/switch-port/{port}/lldp/config`
    ///
    /// Arguments:
    /// - `port`: A name to use when selecting switch ports.
    /// - `rack_id`: A rack id to use when selecting switch ports.
    /// - `switch_location`: A switch location to use when selecting switch
    ///   ports.
    /// - `body`
    /// ```ignore
    /// let response = client.networking_switch_port_lldp_config_update()
    ///    .port(port)
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_lldp_config_update(
        &self,
    ) -> builder::NetworkingSwitchPortLldpConfigUpdate;
    /// List address lots
    ///
    /// Sends a `GET` request to `/v1/system/networking/address-lot`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_address_lot_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_address_lot_list(&self) -> builder::NetworkingAddressLotList;
    /// Create address lot
    ///
    /// Sends a `POST` request to `/v1/system/networking/address-lot`
    ///
    /// ```ignore
    /// let response = client.networking_address_lot_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_address_lot_create(&self) -> builder::NetworkingAddressLotCreate;
    /// Delete address lot
    ///
    /// Sends a `DELETE` request to
    /// `/v1/system/networking/address-lot/{address_lot}`
    ///
    /// Arguments:
    /// - `address_lot`: Name or ID of the address lot
    /// ```ignore
    /// let response = client.networking_address_lot_delete()
    ///    .address_lot(address_lot)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_address_lot_delete(&self) -> builder::NetworkingAddressLotDelete;
    /// List blocks in address lot
    ///
    /// Sends a `GET` request to
    /// `/v1/system/networking/address-lot/{address_lot}/blocks`
    ///
    /// Arguments:
    /// - `address_lot`: Name or ID of the address lot
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_address_lot_block_list()
    ///    .address_lot(address_lot)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_address_lot_block_list(&self) -> builder::NetworkingAddressLotBlockList;
    /// Get user-facing services IP allowlist
    ///
    /// Sends a `GET` request to `/v1/system/networking/allow-list`
    ///
    /// ```ignore
    /// let response = client.networking_allow_list_view()
    ///    .send()
    ///    .await;
    /// ```
    fn networking_allow_list_view(&self) -> builder::NetworkingAllowListView;
    /// Update user-facing services IP allowlist
    ///
    /// Sends a `PUT` request to `/v1/system/networking/allow-list`
    ///
    /// ```ignore
    /// let response = client.networking_allow_list_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_allow_list_update(&self) -> builder::NetworkingAllowListUpdate;
    /// Disable a BFD session
    ///
    /// Sends a `POST` request to `/v1/system/networking/bfd-disable`
    ///
    /// ```ignore
    /// let response = client.networking_bfd_disable()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bfd_disable(&self) -> builder::NetworkingBfdDisable;
    /// Enable a BFD session
    ///
    /// Sends a `POST` request to `/v1/system/networking/bfd-enable`
    ///
    /// ```ignore
    /// let response = client.networking_bfd_enable()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bfd_enable(&self) -> builder::NetworkingBfdEnable;
    /// Get BFD status
    ///
    /// Sends a `GET` request to `/v1/system/networking/bfd-status`
    ///
    /// ```ignore
    /// let response = client.networking_bfd_status()
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bfd_status(&self) -> builder::NetworkingBfdStatus;
    /// List BGP configurations
    ///
    /// Sends a `GET` request to `/v1/system/networking/bgp`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_bgp_config_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_config_list(&self) -> builder::NetworkingBgpConfigList;
    /// Create new BGP configuration
    ///
    /// Sends a `POST` request to `/v1/system/networking/bgp`
    ///
    /// ```ignore
    /// let response = client.networking_bgp_config_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_config_create(&self) -> builder::NetworkingBgpConfigCreate;
    /// Delete BGP configuration
    ///
    /// Sends a `DELETE` request to `/v1/system/networking/bgp`
    ///
    /// Arguments:
    /// - `name_or_id`: A name or id to use when selecting BGP config.
    /// ```ignore
    /// let response = client.networking_bgp_config_delete()
    ///    .name_or_id(name_or_id)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_config_delete(&self) -> builder::NetworkingBgpConfigDelete;
    /// List BGP announce sets
    ///
    /// Sends a `GET` request to `/v1/system/networking/bgp-announce-set`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_bgp_announce_set_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_announce_set_list(&self) -> builder::NetworkingBgpAnnounceSetList;
    /// Update BGP announce set
    ///
    /// If the announce set exists, this endpoint replaces the existing announce
    /// set with the one specified.
    ///
    /// Sends a `PUT` request to `/v1/system/networking/bgp-announce-set`
    ///
    /// ```ignore
    /// let response = client.networking_bgp_announce_set_update()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_announce_set_update(&self) -> builder::NetworkingBgpAnnounceSetUpdate;
    /// Delete BGP announce set
    ///
    /// Sends a `DELETE` request to
    /// `/v1/system/networking/bgp-announce-set/{announce_set}`
    ///
    /// Arguments:
    /// - `announce_set`: Name or ID of the announce set
    /// ```ignore
    /// let response = client.networking_bgp_announce_set_delete()
    ///    .announce_set(announce_set)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_announce_set_delete(&self) -> builder::NetworkingBgpAnnounceSetDelete;
    /// Get originated routes for a specified BGP announce set
    ///
    /// Sends a `GET` request to
    /// `/v1/system/networking/bgp-announce-set/{announce_set}/announcement`
    ///
    /// Arguments:
    /// - `announce_set`: Name or ID of the announce set
    /// ```ignore
    /// let response = client.networking_bgp_announcement_list()
    ///    .announce_set(announce_set)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_announcement_list(&self) -> builder::NetworkingBgpAnnouncementList;
    /// Get BGP exported routes
    ///
    /// Sends a `GET` request to `/v1/system/networking/bgp-exported`
    ///
    /// ```ignore
    /// let response = client.networking_bgp_exported()
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_exported(&self) -> builder::NetworkingBgpExported;
    /// Get BGP router message history
    ///
    /// Sends a `GET` request to `/v1/system/networking/bgp-message-history`
    ///
    /// Arguments:
    /// - `asn`: The ASN to filter on. Required.
    /// ```ignore
    /// let response = client.networking_bgp_message_history()
    ///    .asn(asn)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_message_history(&self) -> builder::NetworkingBgpMessageHistory;
    /// Get imported IPv4 BGP routes
    ///
    /// Sends a `GET` request to `/v1/system/networking/bgp-routes-ipv4`
    ///
    /// Arguments:
    /// - `asn`: The ASN to filter on. Required.
    /// ```ignore
    /// let response = client.networking_bgp_imported_routes_ipv4()
    ///    .asn(asn)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_imported_routes_ipv4(&self) -> builder::NetworkingBgpImportedRoutesIpv4;
    /// Get BGP peer status
    ///
    /// Sends a `GET` request to `/v1/system/networking/bgp-status`
    ///
    /// ```ignore
    /// let response = client.networking_bgp_status()
    ///    .send()
    ///    .await;
    /// ```
    fn networking_bgp_status(&self) -> builder::NetworkingBgpStatus;
    /// List loopback addresses
    ///
    /// Sends a `GET` request to `/v1/system/networking/loopback-address`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_loopback_address_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_loopback_address_list(&self) -> builder::NetworkingLoopbackAddressList;
    /// Create loopback address
    ///
    /// Sends a `POST` request to `/v1/system/networking/loopback-address`
    ///
    /// ```ignore
    /// let response = client.networking_loopback_address_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_loopback_address_create(&self) -> builder::NetworkingLoopbackAddressCreate;
    /// Delete loopback address
    ///
    /// Sends a `DELETE` request to
    /// `/v1/system/networking/loopback-address/{rack_id}/{switch_location}/
    /// {address}/{subnet_mask}`
    ///
    /// Arguments:
    /// - `rack_id`: The rack to use when selecting the loopback address.
    /// - `switch_location`: The switch location to use when selecting the
    ///   loopback address.
    /// - `address`: The IP address and subnet mask to use when selecting the
    ///   loopback address.
    /// - `subnet_mask`: The IP address and subnet mask to use when selecting
    ///   the loopback address.
    /// ```ignore
    /// let response = client.networking_loopback_address_delete()
    ///    .rack_id(rack_id)
    ///    .switch_location(switch_location)
    ///    .address(address)
    ///    .subnet_mask(subnet_mask)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_loopback_address_delete(&self) -> builder::NetworkingLoopbackAddressDelete;
    /// List switch port settings
    ///
    /// Sends a `GET` request to `/v1/system/networking/switch-port-settings`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `port_settings`: An optional name or id to use when selecting port
    ///   settings.
    /// - `sort_by`
    /// ```ignore
    /// let response = client.networking_switch_port_settings_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .port_settings(port_settings)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_settings_list(&self) -> builder::NetworkingSwitchPortSettingsList;
    /// Create switch port settings
    ///
    /// Sends a `POST` request to `/v1/system/networking/switch-port-settings`
    ///
    /// ```ignore
    /// let response = client.networking_switch_port_settings_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_settings_create(&self)
        -> builder::NetworkingSwitchPortSettingsCreate;
    /// Delete switch port settings
    ///
    /// Sends a `DELETE` request to `/v1/system/networking/switch-port-settings`
    ///
    /// Arguments:
    /// - `port_settings`: An optional name or id to use when selecting port
    ///   settings.
    /// ```ignore
    /// let response = client.networking_switch_port_settings_delete()
    ///    .port_settings(port_settings)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_settings_delete(&self)
        -> builder::NetworkingSwitchPortSettingsDelete;
    /// Get information about switch port
    ///
    /// Sends a `GET` request to
    /// `/v1/system/networking/switch-port-settings/{port}`
    ///
    /// Arguments:
    /// - `port`: A name or id to use when selecting switch port settings info
    ///   objects.
    /// ```ignore
    /// let response = client.networking_switch_port_settings_view()
    ///    .port(port)
    ///    .send()
    ///    .await;
    /// ```
    fn networking_switch_port_settings_view(&self) -> builder::NetworkingSwitchPortSettingsView;
}

impl ClientSystemNetworkingExt for Client {
    fn networking_switch_port_lldp_neighbors(&self) -> builder::NetworkingSwitchPortLldpNeighbors {
        builder::NetworkingSwitchPortLldpNeighbors::new(self)
    }

    fn networking_switch_port_lldp_config_view(
        &self,
    ) -> builder::NetworkingSwitchPortLldpConfigView {
        builder::NetworkingSwitchPortLldpConfigView::new(self)
    }

    fn networking_switch_port_lldp_config_update(
        &self,
    ) -> builder::NetworkingSwitchPortLldpConfigUpdate {
        builder::NetworkingSwitchPortLldpConfigUpdate::new(self)
    }

    fn networking_address_lot_list(&self) -> builder::NetworkingAddressLotList {
        builder::NetworkingAddressLotList::new(self)
    }

    fn networking_address_lot_create(&self) -> builder::NetworkingAddressLotCreate {
        builder::NetworkingAddressLotCreate::new(self)
    }

    fn networking_address_lot_delete(&self) -> builder::NetworkingAddressLotDelete {
        builder::NetworkingAddressLotDelete::new(self)
    }

    fn networking_address_lot_block_list(&self) -> builder::NetworkingAddressLotBlockList {
        builder::NetworkingAddressLotBlockList::new(self)
    }

    fn networking_allow_list_view(&self) -> builder::NetworkingAllowListView {
        builder::NetworkingAllowListView::new(self)
    }

    fn networking_allow_list_update(&self) -> builder::NetworkingAllowListUpdate {
        builder::NetworkingAllowListUpdate::new(self)
    }

    fn networking_bfd_disable(&self) -> builder::NetworkingBfdDisable {
        builder::NetworkingBfdDisable::new(self)
    }

    fn networking_bfd_enable(&self) -> builder::NetworkingBfdEnable {
        builder::NetworkingBfdEnable::new(self)
    }

    fn networking_bfd_status(&self) -> builder::NetworkingBfdStatus {
        builder::NetworkingBfdStatus::new(self)
    }

    fn networking_bgp_config_list(&self) -> builder::NetworkingBgpConfigList {
        builder::NetworkingBgpConfigList::new(self)
    }

    fn networking_bgp_config_create(&self) -> builder::NetworkingBgpConfigCreate {
        builder::NetworkingBgpConfigCreate::new(self)
    }

    fn networking_bgp_config_delete(&self) -> builder::NetworkingBgpConfigDelete {
        builder::NetworkingBgpConfigDelete::new(self)
    }

    fn networking_bgp_announce_set_list(&self) -> builder::NetworkingBgpAnnounceSetList {
        builder::NetworkingBgpAnnounceSetList::new(self)
    }

    fn networking_bgp_announce_set_update(&self) -> builder::NetworkingBgpAnnounceSetUpdate {
        builder::NetworkingBgpAnnounceSetUpdate::new(self)
    }

    fn networking_bgp_announce_set_delete(&self) -> builder::NetworkingBgpAnnounceSetDelete {
        builder::NetworkingBgpAnnounceSetDelete::new(self)
    }

    fn networking_bgp_announcement_list(&self) -> builder::NetworkingBgpAnnouncementList {
        builder::NetworkingBgpAnnouncementList::new(self)
    }

    fn networking_bgp_exported(&self) -> builder::NetworkingBgpExported {
        builder::NetworkingBgpExported::new(self)
    }

    fn networking_bgp_message_history(&self) -> builder::NetworkingBgpMessageHistory {
        builder::NetworkingBgpMessageHistory::new(self)
    }

    fn networking_bgp_imported_routes_ipv4(&self) -> builder::NetworkingBgpImportedRoutesIpv4 {
        builder::NetworkingBgpImportedRoutesIpv4::new(self)
    }

    fn networking_bgp_status(&self) -> builder::NetworkingBgpStatus {
        builder::NetworkingBgpStatus::new(self)
    }

    fn networking_loopback_address_list(&self) -> builder::NetworkingLoopbackAddressList {
        builder::NetworkingLoopbackAddressList::new(self)
    }

    fn networking_loopback_address_create(&self) -> builder::NetworkingLoopbackAddressCreate {
        builder::NetworkingLoopbackAddressCreate::new(self)
    }

    fn networking_loopback_address_delete(&self) -> builder::NetworkingLoopbackAddressDelete {
        builder::NetworkingLoopbackAddressDelete::new(self)
    }

    fn networking_switch_port_settings_list(&self) -> builder::NetworkingSwitchPortSettingsList {
        builder::NetworkingSwitchPortSettingsList::new(self)
    }

    fn networking_switch_port_settings_create(
        &self,
    ) -> builder::NetworkingSwitchPortSettingsCreate {
        builder::NetworkingSwitchPortSettingsCreate::new(self)
    }

    fn networking_switch_port_settings_delete(
        &self,
    ) -> builder::NetworkingSwitchPortSettingsDelete {
        builder::NetworkingSwitchPortSettingsDelete::new(self)
    }

    fn networking_switch_port_settings_view(&self) -> builder::NetworkingSwitchPortSettingsView {
        builder::NetworkingSwitchPortSettingsView::new(self)
    }
}

/// Silos represent a logical partition of users and resources.
pub trait ClientSystemSilosExt {
    /// List identity providers for silo
    ///
    /// List identity providers for silo by silo name or ID.
    ///
    /// Sends a `GET` request to `/v1/system/identity-providers`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `silo`: Name or ID of the silo
    /// - `sort_by`
    /// ```ignore
    /// let response = client.silo_identity_provider_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .silo(silo)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_identity_provider_list(&self) -> builder::SiloIdentityProviderList;
    /// Create user
    ///
    /// Users can only be created in Silos with `provision_type` == `Fixed`.
    /// Otherwise, Silo users are just-in-time (JIT) provisioned when a user
    /// first logs in using an external Identity Provider.
    ///
    /// Sends a `POST` request to `/v1/system/identity-providers/local/users`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// - `body`
    /// ```ignore
    /// let response = client.local_idp_user_create()
    ///    .silo(silo)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn local_idp_user_create(&self) -> builder::LocalIdpUserCreate;
    /// Delete user
    ///
    /// Sends a `DELETE` request to
    /// `/v1/system/identity-providers/local/users/{user_id}`
    ///
    /// Arguments:
    /// - `user_id`: The user's internal ID
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.local_idp_user_delete()
    ///    .user_id(user_id)
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn local_idp_user_delete(&self) -> builder::LocalIdpUserDelete;
    /// Set or invalidate user's password
    ///
    /// Passwords can only be updated for users in Silos with identity mode
    /// `LocalOnly`.
    ///
    /// Sends a `POST` request to
    /// `/v1/system/identity-providers/local/users/{user_id}/set-password`
    ///
    /// Arguments:
    /// - `user_id`: The user's internal ID
    /// - `silo`: Name or ID of the silo
    /// - `body`
    /// ```ignore
    /// let response = client.local_idp_user_set_password()
    ///    .user_id(user_id)
    ///    .silo(silo)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn local_idp_user_set_password(&self) -> builder::LocalIdpUserSetPassword;
    /// Create SAML identity provider
    ///
    /// Sends a `POST` request to `/v1/system/identity-providers/saml`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// - `body`
    /// ```ignore
    /// let response = client.saml_identity_provider_create()
    ///    .silo(silo)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn saml_identity_provider_create(&self) -> builder::SamlIdentityProviderCreate;
    /// Fetch SAML identity provider
    ///
    /// Sends a `GET` request to `/v1/system/identity-providers/saml/{provider}`
    ///
    /// Arguments:
    /// - `provider`: Name or ID of the SAML identity provider
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.saml_identity_provider_view()
    ///    .provider(provider)
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn saml_identity_provider_view(&self) -> builder::SamlIdentityProviderView;
    /// Lists resource quotas for all silos
    ///
    /// Sends a `GET` request to `/v1/system/silo-quotas`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.system_quotas_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn system_quotas_list(&self) -> builder::SystemQuotasList;
    /// List silos
    ///
    /// Lists silos that are discoverable based on the current permissions.
    ///
    /// Sends a `GET` request to `/v1/system/silos`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.silo_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_list(&self) -> builder::SiloList;
    /// Create a silo
    ///
    /// Sends a `POST` request to `/v1/system/silos`
    ///
    /// ```ignore
    /// let response = client.silo_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_create(&self) -> builder::SiloCreate;
    /// Fetch silo
    ///
    /// Fetch silo by name or ID.
    ///
    /// Sends a `GET` request to `/v1/system/silos/{silo}`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.silo_view()
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_view(&self) -> builder::SiloView;
    /// Delete a silo
    ///
    /// Delete a silo by name or ID.
    ///
    /// Sends a `DELETE` request to `/v1/system/silos/{silo}`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.silo_delete()
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_delete(&self) -> builder::SiloDelete;
    /// List IP pools linked to silo
    ///
    /// Linked IP pools are available to users in the specified silo. A silo can
    /// have at most one default pool. IPs are allocated from the default pool
    /// when users ask for one without specifying a pool.
    ///
    /// Sends a `GET` request to `/v1/system/silos/{silo}/ip-pools`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.silo_ip_pool_list()
    ///    .silo(silo)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_ip_pool_list(&self) -> builder::SiloIpPoolList;
    /// Fetch silo IAM policy
    ///
    /// Sends a `GET` request to `/v1/system/silos/{silo}/policy`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.silo_policy_view()
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_policy_view(&self) -> builder::SiloPolicyView;
    /// Update silo IAM policy
    ///
    /// Sends a `PUT` request to `/v1/system/silos/{silo}/policy`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// - `body`
    /// ```ignore
    /// let response = client.silo_policy_update()
    ///    .silo(silo)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_policy_update(&self) -> builder::SiloPolicyUpdate;
    /// Fetch resource quotas for silo
    ///
    /// Sends a `GET` request to `/v1/system/silos/{silo}/quotas`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.silo_quotas_view()
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_quotas_view(&self) -> builder::SiloQuotasView;
    /// Update resource quotas for silo
    ///
    /// If a quota value is not specified, it will remain unchanged.
    ///
    /// Sends a `PUT` request to `/v1/system/silos/{silo}/quotas`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// - `body`
    /// ```ignore
    /// let response = client.silo_quotas_update()
    ///    .silo(silo)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_quotas_update(&self) -> builder::SiloQuotasUpdate;
    /// List built-in (system) users in silo
    ///
    /// Sends a `GET` request to `/v1/system/users`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `silo`: Name or ID of the silo
    /// - `sort_by`
    /// ```ignore
    /// let response = client.silo_user_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .silo(silo)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_user_list(&self) -> builder::SiloUserList;
    /// Fetch built-in (system) user
    ///
    /// Sends a `GET` request to `/v1/system/users/{user_id}`
    ///
    /// Arguments:
    /// - `user_id`: The user's internal ID
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.silo_user_view()
    ///    .user_id(user_id)
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_user_view(&self) -> builder::SiloUserView;
    /// List built-in users
    ///
    /// Sends a `GET` request to `/v1/system/users-builtin`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.user_builtin_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn user_builtin_list(&self) -> builder::UserBuiltinList;
    /// Fetch built-in user
    ///
    /// Sends a `GET` request to `/v1/system/users-builtin/{user}`
    ///
    /// ```ignore
    /// let response = client.user_builtin_view()
    ///    .user(user)
    ///    .send()
    ///    .await;
    /// ```
    fn user_builtin_view(&self) -> builder::UserBuiltinView;
    /// List current utilization state for all silos
    ///
    /// Sends a `GET` request to `/v1/system/utilization/silos`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.silo_utilization_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_utilization_list(&self) -> builder::SiloUtilizationList;
    /// Fetch current utilization for given silo
    ///
    /// Sends a `GET` request to `/v1/system/utilization/silos/{silo}`
    ///
    /// Arguments:
    /// - `silo`: Name or ID of the silo
    /// ```ignore
    /// let response = client.silo_utilization_view()
    ///    .silo(silo)
    ///    .send()
    ///    .await;
    /// ```
    fn silo_utilization_view(&self) -> builder::SiloUtilizationView;
}

impl ClientSystemSilosExt for Client {
    fn silo_identity_provider_list(&self) -> builder::SiloIdentityProviderList {
        builder::SiloIdentityProviderList::new(self)
    }

    fn local_idp_user_create(&self) -> builder::LocalIdpUserCreate {
        builder::LocalIdpUserCreate::new(self)
    }

    fn local_idp_user_delete(&self) -> builder::LocalIdpUserDelete {
        builder::LocalIdpUserDelete::new(self)
    }

    fn local_idp_user_set_password(&self) -> builder::LocalIdpUserSetPassword {
        builder::LocalIdpUserSetPassword::new(self)
    }

    fn saml_identity_provider_create(&self) -> builder::SamlIdentityProviderCreate {
        builder::SamlIdentityProviderCreate::new(self)
    }

    fn saml_identity_provider_view(&self) -> builder::SamlIdentityProviderView {
        builder::SamlIdentityProviderView::new(self)
    }

    fn system_quotas_list(&self) -> builder::SystemQuotasList {
        builder::SystemQuotasList::new(self)
    }

    fn silo_list(&self) -> builder::SiloList {
        builder::SiloList::new(self)
    }

    fn silo_create(&self) -> builder::SiloCreate {
        builder::SiloCreate::new(self)
    }

    fn silo_view(&self) -> builder::SiloView {
        builder::SiloView::new(self)
    }

    fn silo_delete(&self) -> builder::SiloDelete {
        builder::SiloDelete::new(self)
    }

    fn silo_ip_pool_list(&self) -> builder::SiloIpPoolList {
        builder::SiloIpPoolList::new(self)
    }

    fn silo_policy_view(&self) -> builder::SiloPolicyView {
        builder::SiloPolicyView::new(self)
    }

    fn silo_policy_update(&self) -> builder::SiloPolicyUpdate {
        builder::SiloPolicyUpdate::new(self)
    }

    fn silo_quotas_view(&self) -> builder::SiloQuotasView {
        builder::SiloQuotasView::new(self)
    }

    fn silo_quotas_update(&self) -> builder::SiloQuotasUpdate {
        builder::SiloQuotasUpdate::new(self)
    }

    fn silo_user_list(&self) -> builder::SiloUserList {
        builder::SiloUserList::new(self)
    }

    fn silo_user_view(&self) -> builder::SiloUserView {
        builder::SiloUserView::new(self)
    }

    fn user_builtin_list(&self) -> builder::UserBuiltinList {
        builder::UserBuiltinList::new(self)
    }

    fn user_builtin_view(&self) -> builder::UserBuiltinView {
        builder::UserBuiltinView::new(self)
    }

    fn silo_utilization_list(&self) -> builder::SiloUtilizationList {
        builder::SiloUtilizationList::new(self)
    }

    fn silo_utilization_view(&self) -> builder::SiloUtilizationView {
        builder::SiloUtilizationView::new(self)
    }
}

/// Endpoints related to system health
pub trait ClientSystemStatusExt {
    /// Ping API
    ///
    /// Always responds with Ok if it responds at all.
    ///
    /// Sends a `GET` request to `/v1/ping`
    ///
    /// ```ignore
    /// let response = client.ping()
    ///    .send()
    ///    .await;
    /// ```
    fn ping(&self) -> builder::Ping;
}

impl ClientSystemStatusExt for Client {
    fn ping(&self) -> builder::Ping {
        builder::Ping::new(self)
    }
}

/// Webhooks deliver notifications for audit log events and fault management
/// alerts.
pub trait ClientSystemWebhooksExt {
    /// List delivery attempts to webhook receiver
    ///
    /// Optional query parameters to this endpoint may be used to filter
    /// deliveries by state. If none of the `failed`, `pending` or `delivered`
    /// query parameters are present, all deliveries are returned. If one or
    /// more of these parameters are provided, only those which are set to
    /// "true" are included in the response.
    ///
    /// Sends a `GET` request to `/v1/webhooks/deliveries`
    ///
    /// Arguments:
    /// - `delivered`: If true, include deliveries which have succeeded.
    ///
    /// If any of the "pending", "failed", or "delivered" query parameters are
    /// set to true, only deliveries matching those state(s) will be included in
    /// the response. If NO state filter parameters are set, then all deliveries
    /// are included.
    /// - `failed`: If true, include deliveries which have failed permanently.
    ///
    /// If any of the "pending", "failed", or "delivered" query parameters are
    /// set to true, only deliveries matching those state(s) will be included in
    /// the response. If NO state filter parameters are set, then all deliveries
    /// are included.
    ///
    /// A delivery fails permanently when the retry limit of three total
    /// attempts is reached without a successful delivery.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `pending`: If true, include deliveries which are currently in
    ///   progress.
    ///
    /// If any of the "pending", "failed", or "delivered" query parameters are
    /// set to true, only deliveries matching those state(s) will be included in
    /// the response. If NO state filter parameters are set, then all deliveries
    /// are included.
    ///
    /// A delivery is considered "pending" if it has not yet been sent at all,
    /// or if a delivery attempt has failed but the delivery has retries
    /// remaining.
    /// - `receiver`: The name or ID of the webhook receiver.
    /// - `sort_by`
    /// ```ignore
    /// let response = client.webhook_delivery_list()
    ///    .delivered(delivered)
    ///    .failed(failed)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .pending(pending)
    ///    .receiver(receiver)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_delivery_list(&self) -> builder::WebhookDeliveryList;
    /// Request re-delivery of webhook event
    ///
    /// Sends a `POST` request to `/v1/webhooks/deliveries/{event_id}/resend`
    ///
    /// Arguments:
    /// - `event_id`: UUID of the event
    /// - `receiver`: The name or ID of the webhook receiver.
    /// ```ignore
    /// let response = client.webhook_delivery_resend()
    ///    .event_id(event_id)
    ///    .receiver(receiver)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_delivery_resend(&self) -> builder::WebhookDeliveryResend;
    /// List webhook event classes
    ///
    /// Sends a `GET` request to `/v1/webhooks/event-classes`
    ///
    /// Arguments:
    /// - `filter`: An optional glob pattern for filtering event class names.
    ///
    /// If provided, only event classes which match this glob pattern will be
    /// included in the response.
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// ```ignore
    /// let response = client.webhook_event_class_list()
    ///    .filter(filter)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_event_class_list(&self) -> builder::WebhookEventClassList;
    /// List webhook receivers
    ///
    /// Sends a `GET` request to `/v1/webhooks/receivers`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `sort_by`
    /// ```ignore
    /// let response = client.webhook_receiver_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_list(&self) -> builder::WebhookReceiverList;
    /// Create webhook receiver
    ///
    /// Sends a `POST` request to `/v1/webhooks/receivers`
    ///
    /// ```ignore
    /// let response = client.webhook_receiver_create()
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_create(&self) -> builder::WebhookReceiverCreate;
    /// Fetch webhook receiver
    ///
    /// Sends a `GET` request to `/v1/webhooks/receivers/{receiver}`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// ```ignore
    /// let response = client.webhook_receiver_view()
    ///    .receiver(receiver)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_view(&self) -> builder::WebhookReceiverView;
    /// Update webhook receiver
    ///
    /// Note that receiver secrets are NOT added or removed using this endpoint.
    /// Instead, use the `/v1/webhooks/{secrets}/?receiver={receiver}` endpoint
    /// to add and remove secrets.
    ///
    /// Sends a `PUT` request to `/v1/webhooks/receivers/{receiver}`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// - `body`
    /// ```ignore
    /// let response = client.webhook_receiver_update()
    ///    .receiver(receiver)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_update(&self) -> builder::WebhookReceiverUpdate;
    /// Delete webhook receiver
    ///
    /// Sends a `DELETE` request to `/v1/webhooks/receivers/{receiver}`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// ```ignore
    /// let response = client.webhook_receiver_delete()
    ///    .receiver(receiver)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_delete(&self) -> builder::WebhookReceiverDelete;
    /// Send liveness probe to webhook receiver
    ///
    /// This endpoint synchronously sends a liveness probe request to the
    /// selected webhook receiver. The response message describes the outcome of
    /// the probe request: either the response from the receiver endpoint, or an
    /// indication of why the probe failed.
    ///
    /// Note that the response status is `200 OK` as long as a probe request was
    /// able to be sent to the receiver endpoint. If the receiver responds with
    /// another status code, including an error, this will be indicated by the
    /// response body, *not* the status of the response.
    ///
    /// The `resend` query parameter can be used to request re-delivery of
    /// failed events if the liveness probe succeeds. If it is set to true and
    /// the webhook receiver responds to the probe request with a `2xx` status
    /// code, any events for which delivery to this receiver has failed will be
    /// queued for re-delivery.
    ///
    /// Sends a `POST` request to `/v1/webhooks/receivers/{receiver}/probe`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// - `resend`: If true, resend all events that have not been delivered
    ///   successfully if the probe request succeeds.
    /// ```ignore
    /// let response = client.webhook_receiver_probe()
    ///    .receiver(receiver)
    ///    .resend(resend)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_probe(&self) -> builder::WebhookReceiverProbe;
    /// Add webhook receiver subscription
    ///
    /// Sends a `POST` request to
    /// `/v1/webhooks/receivers/{receiver}/subscriptions`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// - `body`
    /// ```ignore
    /// let response = client.webhook_receiver_subscription_add()
    ///    .receiver(receiver)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_subscription_add(&self) -> builder::WebhookReceiverSubscriptionAdd;
    /// Remove webhook receiver subscription
    ///
    /// Sends a `DELETE` request to
    /// `/v1/webhooks/receivers/{receiver}/subscriptions/{subscription}`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// - `subscription`: The event class subscription itself.
    /// ```ignore
    /// let response = client.webhook_receiver_subscription_remove()
    ///    .receiver(receiver)
    ///    .subscription(subscription)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_receiver_subscription_remove(&self) -> builder::WebhookReceiverSubscriptionRemove;
    /// List webhook receiver secret IDs
    ///
    /// Sends a `GET` request to `/v1/webhooks/secrets`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// ```ignore
    /// let response = client.webhook_secrets_list()
    ///    .receiver(receiver)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_secrets_list(&self) -> builder::WebhookSecretsList;
    /// Add secret to webhook receiver
    ///
    /// Sends a `POST` request to `/v1/webhooks/secrets`
    ///
    /// Arguments:
    /// - `receiver`: The name or ID of the webhook receiver.
    /// - `body`
    /// ```ignore
    /// let response = client.webhook_secrets_add()
    ///    .receiver(receiver)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_secrets_add(&self) -> builder::WebhookSecretsAdd;
    /// Remove secret from webhook receiver
    ///
    /// Sends a `DELETE` request to `/v1/webhooks/secrets/{secret_id}`
    ///
    /// Arguments:
    /// - `secret_id`: ID of the secret.
    /// ```ignore
    /// let response = client.webhook_secrets_delete()
    ///    .secret_id(secret_id)
    ///    .send()
    ///    .await;
    /// ```
    fn webhook_secrets_delete(&self) -> builder::WebhookSecretsDelete;
}

impl ClientSystemWebhooksExt for Client {
    fn webhook_delivery_list(&self) -> builder::WebhookDeliveryList {
        builder::WebhookDeliveryList::new(self)
    }

    fn webhook_delivery_resend(&self) -> builder::WebhookDeliveryResend {
        builder::WebhookDeliveryResend::new(self)
    }

    fn webhook_event_class_list(&self) -> builder::WebhookEventClassList {
        builder::WebhookEventClassList::new(self)
    }

    fn webhook_receiver_list(&self) -> builder::WebhookReceiverList {
        builder::WebhookReceiverList::new(self)
    }

    fn webhook_receiver_create(&self) -> builder::WebhookReceiverCreate {
        builder::WebhookReceiverCreate::new(self)
    }

    fn webhook_receiver_view(&self) -> builder::WebhookReceiverView {
        builder::WebhookReceiverView::new(self)
    }

    fn webhook_receiver_update(&self) -> builder::WebhookReceiverUpdate {
        builder::WebhookReceiverUpdate::new(self)
    }

    fn webhook_receiver_delete(&self) -> builder::WebhookReceiverDelete {
        builder::WebhookReceiverDelete::new(self)
    }

    fn webhook_receiver_probe(&self) -> builder::WebhookReceiverProbe {
        builder::WebhookReceiverProbe::new(self)
    }

    fn webhook_receiver_subscription_add(&self) -> builder::WebhookReceiverSubscriptionAdd {
        builder::WebhookReceiverSubscriptionAdd::new(self)
    }

    fn webhook_receiver_subscription_remove(&self) -> builder::WebhookReceiverSubscriptionRemove {
        builder::WebhookReceiverSubscriptionRemove::new(self)
    }

    fn webhook_secrets_list(&self) -> builder::WebhookSecretsList {
        builder::WebhookSecretsList::new(self)
    }

    fn webhook_secrets_add(&self) -> builder::WebhookSecretsAdd {
        builder::WebhookSecretsAdd::new(self)
    }

    fn webhook_secrets_delete(&self) -> builder::WebhookSecretsDelete {
        builder::WebhookSecretsDelete::new(self)
    }
}

/// Virtual Private Clouds (VPCs) provide isolated network environments for
/// managing and deploying services.
pub trait ClientVpcsExt {
    /// List IP addresses attached to internet gateway
    ///
    /// Sends a `GET` request to `/v1/internet-gateway-ip-addresses`
    ///
    /// Arguments:
    /// - `gateway`: Name or ID of the internet gateway
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC, only required if `gateway` is provided
    ///   as a `Name`
    /// ```ignore
    /// let response = client.internet_gateway_ip_address_list()
    ///    .gateway(gateway)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_ip_address_list(&self) -> builder::InternetGatewayIpAddressList;
    /// Attach IP address to internet gateway
    ///
    /// Sends a `POST` request to `/v1/internet-gateway-ip-addresses`
    ///
    /// Arguments:
    /// - `gateway`: Name or ID of the internet gateway
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC, only required if `gateway` is provided
    ///   as a `Name`
    /// - `body`
    /// ```ignore
    /// let response = client.internet_gateway_ip_address_create()
    ///    .gateway(gateway)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_ip_address_create(&self) -> builder::InternetGatewayIpAddressCreate;
    /// Detach IP address from internet gateway
    ///
    /// Sends a `DELETE` request to
    /// `/v1/internet-gateway-ip-addresses/{address}`
    ///
    /// Arguments:
    /// - `address`: Name or ID of the IP address
    /// - `cascade`: Also delete routes targeting this gateway element.
    /// - `gateway`: Name or ID of the internet gateway
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC, only required if `gateway` is provided
    ///   as a `Name`
    /// ```ignore
    /// let response = client.internet_gateway_ip_address_delete()
    ///    .address(address)
    ///    .cascade(cascade)
    ///    .gateway(gateway)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_ip_address_delete(&self) -> builder::InternetGatewayIpAddressDelete;
    /// List IP pools attached to internet gateway
    ///
    /// Sends a `GET` request to `/v1/internet-gateway-ip-pools`
    ///
    /// Arguments:
    /// - `gateway`: Name or ID of the internet gateway
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC, only required if `gateway` is provided
    ///   as a `Name`
    /// ```ignore
    /// let response = client.internet_gateway_ip_pool_list()
    ///    .gateway(gateway)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_ip_pool_list(&self) -> builder::InternetGatewayIpPoolList;
    /// Attach IP pool to internet gateway
    ///
    /// Sends a `POST` request to `/v1/internet-gateway-ip-pools`
    ///
    /// Arguments:
    /// - `gateway`: Name or ID of the internet gateway
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC, only required if `gateway` is provided
    ///   as a `Name`
    /// - `body`
    /// ```ignore
    /// let response = client.internet_gateway_ip_pool_create()
    ///    .gateway(gateway)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_ip_pool_create(&self) -> builder::InternetGatewayIpPoolCreate;
    /// Detach IP pool from internet gateway
    ///
    /// Sends a `DELETE` request to `/v1/internet-gateway-ip-pools/{pool}`
    ///
    /// Arguments:
    /// - `pool`: Name or ID of the IP pool
    /// - `cascade`: Also delete routes targeting this gateway element.
    /// - `gateway`: Name or ID of the internet gateway
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC, only required if `gateway` is provided
    ///   as a `Name`
    /// ```ignore
    /// let response = client.internet_gateway_ip_pool_delete()
    ///    .pool(pool)
    ///    .cascade(cascade)
    ///    .gateway(gateway)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_ip_pool_delete(&self) -> builder::InternetGatewayIpPoolDelete;
    /// List internet gateways
    ///
    /// Sends a `GET` request to `/v1/internet-gateways`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.internet_gateway_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_list(&self) -> builder::InternetGatewayList;
    /// Create VPC internet gateway
    ///
    /// Sends a `POST` request to `/v1/internet-gateways`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// - `body`
    /// ```ignore
    /// let response = client.internet_gateway_create()
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_create(&self) -> builder::InternetGatewayCreate;
    /// Fetch internet gateway
    ///
    /// Sends a `GET` request to `/v1/internet-gateways/{gateway}`
    ///
    /// Arguments:
    /// - `gateway`: Name or ID of the gateway
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.internet_gateway_view()
    ///    .gateway(gateway)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_view(&self) -> builder::InternetGatewayView;
    /// Delete internet gateway
    ///
    /// Sends a `DELETE` request to `/v1/internet-gateways/{gateway}`
    ///
    /// Arguments:
    /// - `gateway`: Name or ID of the gateway
    /// - `cascade`: Also delete routes targeting this gateway.
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.internet_gateway_delete()
    ///    .gateway(gateway)
    ///    .cascade(cascade)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn internet_gateway_delete(&self) -> builder::InternetGatewayDelete;
    /// List firewall rules
    ///
    /// Sends a `GET` request to `/v1/vpc-firewall-rules`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_firewall_rules_view()
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_firewall_rules_view(&self) -> builder::VpcFirewallRulesView;
    /// Replace firewall rules
    ///
    /// The maximum number of rules per VPC is 1024.
    ///
    /// Targets are used to specify the set of instances to which a firewall
    /// rule applies. You can target instances directly by name, or specify a
    /// VPC, VPC subnet, IP, or IP subnet, which will apply the rule to traffic
    /// going to all matching instances. Targets are additive: the rule applies
    /// to instances matching ANY target. The maximum number of targets is 256.
    ///
    /// Filters reduce the scope of a firewall rule. Without filters, the rule
    /// applies to all packets to the targets (or from the targets, if it's an
    /// outbound rule). With multiple filters, the rule applies only to packets
    /// matching ALL filters. The maximum number of each type of filter is 256.
    ///
    /// Sends a `PUT` request to `/v1/vpc-firewall-rules`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_firewall_rules_update()
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_firewall_rules_update(&self) -> builder::VpcFirewallRulesUpdate;
    /// List routes
    ///
    /// List the routes associated with a router in a particular VPC.
    ///
    /// Sends a `GET` request to `/v1/vpc-router-routes`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `router`: Name or ID of the router
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC, only required if `router` is provided as
    ///   a `Name`
    /// ```ignore
    /// let response = client.vpc_router_route_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .router(router)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_list(&self) -> builder::VpcRouterRouteList;
    /// Create route
    ///
    /// Sends a `POST` request to `/v1/vpc-router-routes`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `router`: Name or ID of the router
    /// - `vpc`: Name or ID of the VPC, only required if `router` is provided as
    ///   a `Name`
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_router_route_create()
    ///    .project(project)
    ///    .router(router)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_create(&self) -> builder::VpcRouterRouteCreate;
    /// Fetch route
    ///
    /// Sends a `GET` request to `/v1/vpc-router-routes/{route}`
    ///
    /// Arguments:
    /// - `route`: Name or ID of the route
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `router`: Name or ID of the router
    /// - `vpc`: Name or ID of the VPC, only required if `router` is provided as
    ///   a `Name`
    /// ```ignore
    /// let response = client.vpc_router_route_view()
    ///    .route(route)
    ///    .project(project)
    ///    .router(router)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_view(&self) -> builder::VpcRouterRouteView;
    /// Update route
    ///
    /// Sends a `PUT` request to `/v1/vpc-router-routes/{route}`
    ///
    /// Arguments:
    /// - `route`: Name or ID of the route
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `router`: Name or ID of the router
    /// - `vpc`: Name or ID of the VPC, only required if `router` is provided as
    ///   a `Name`
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_router_route_update()
    ///    .route(route)
    ///    .project(project)
    ///    .router(router)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_update(&self) -> builder::VpcRouterRouteUpdate;
    /// Delete route
    ///
    /// Sends a `DELETE` request to `/v1/vpc-router-routes/{route}`
    ///
    /// Arguments:
    /// - `route`: Name or ID of the route
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `router`: Name or ID of the router
    /// - `vpc`: Name or ID of the VPC, only required if `router` is provided as
    ///   a `Name`
    /// ```ignore
    /// let response = client.vpc_router_route_delete()
    ///    .route(route)
    ///    .project(project)
    ///    .router(router)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_route_delete(&self) -> builder::VpcRouterRouteDelete;
    /// List routers
    ///
    /// Sends a `GET` request to `/v1/vpc-routers`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_router_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_list(&self) -> builder::VpcRouterList;
    /// Create VPC router
    ///
    /// Sends a `POST` request to `/v1/vpc-routers`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_router_create()
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_create(&self) -> builder::VpcRouterCreate;
    /// Fetch router
    ///
    /// Sends a `GET` request to `/v1/vpc-routers/{router}`
    ///
    /// Arguments:
    /// - `router`: Name or ID of the router
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_router_view()
    ///    .router(router)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_view(&self) -> builder::VpcRouterView;
    /// Update router
    ///
    /// Sends a `PUT` request to `/v1/vpc-routers/{router}`
    ///
    /// Arguments:
    /// - `router`: Name or ID of the router
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_router_update()
    ///    .router(router)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_update(&self) -> builder::VpcRouterUpdate;
    /// Delete router
    ///
    /// Sends a `DELETE` request to `/v1/vpc-routers/{router}`
    ///
    /// Arguments:
    /// - `router`: Name or ID of the router
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_router_delete()
    ///    .router(router)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_router_delete(&self) -> builder::VpcRouterDelete;
    /// List subnets
    ///
    /// Sends a `GET` request to `/v1/vpc-subnets`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_subnet_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_list(&self) -> builder::VpcSubnetList;
    /// Create subnet
    ///
    /// Sends a `POST` request to `/v1/vpc-subnets`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_subnet_create()
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_create(&self) -> builder::VpcSubnetCreate;
    /// Fetch subnet
    ///
    /// Sends a `GET` request to `/v1/vpc-subnets/{subnet}`
    ///
    /// Arguments:
    /// - `subnet`: Name or ID of the subnet
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_subnet_view()
    ///    .subnet(subnet)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_view(&self) -> builder::VpcSubnetView;
    /// Update subnet
    ///
    /// Sends a `PUT` request to `/v1/vpc-subnets/{subnet}`
    ///
    /// Arguments:
    /// - `subnet`: Name or ID of the subnet
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_subnet_update()
    ///    .subnet(subnet)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_update(&self) -> builder::VpcSubnetUpdate;
    /// Delete subnet
    ///
    /// Sends a `DELETE` request to `/v1/vpc-subnets/{subnet}`
    ///
    /// Arguments:
    /// - `subnet`: Name or ID of the subnet
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_subnet_delete()
    ///    .subnet(subnet)
    ///    .project(project)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_delete(&self) -> builder::VpcSubnetDelete;
    /// List network interfaces
    ///
    /// Sends a `GET` request to `/v1/vpc-subnets/{subnet}/network-interfaces`
    ///
    /// Arguments:
    /// - `subnet`: Name or ID of the subnet
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project, only required if `vpc` is
    ///   provided as a `Name`
    /// - `sort_by`
    /// - `vpc`: Name or ID of the VPC
    /// ```ignore
    /// let response = client.vpc_subnet_list_network_interfaces()
    ///    .subnet(subnet)
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .vpc(vpc)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_subnet_list_network_interfaces(&self) -> builder::VpcSubnetListNetworkInterfaces;
    /// List VPCs
    ///
    /// Sends a `GET` request to `/v1/vpcs`
    ///
    /// Arguments:
    /// - `limit`: Maximum number of items returned by a single call
    /// - `page_token`: Token returned by previous call to retrieve the
    ///   subsequent page
    /// - `project`: Name or ID of the project
    /// - `sort_by`
    /// ```ignore
    /// let response = client.vpc_list()
    ///    .limit(limit)
    ///    .page_token(page_token)
    ///    .project(project)
    ///    .sort_by(sort_by)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_list(&self) -> builder::VpcList;
    /// Create VPC
    ///
    /// Sends a `POST` request to `/v1/vpcs`
    ///
    /// Arguments:
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_create()
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_create(&self) -> builder::VpcCreate;
    /// Fetch VPC
    ///
    /// Sends a `GET` request to `/v1/vpcs/{vpc}`
    ///
    /// Arguments:
    /// - `vpc`: Name or ID of the VPC
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.vpc_view()
    ///    .vpc(vpc)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_view(&self) -> builder::VpcView;
    /// Update a VPC
    ///
    /// Sends a `PUT` request to `/v1/vpcs/{vpc}`
    ///
    /// Arguments:
    /// - `vpc`: Name or ID of the VPC
    /// - `project`: Name or ID of the project
    /// - `body`
    /// ```ignore
    /// let response = client.vpc_update()
    ///    .vpc(vpc)
    ///    .project(project)
    ///    .body(body)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_update(&self) -> builder::VpcUpdate;
    /// Delete VPC
    ///
    /// Sends a `DELETE` request to `/v1/vpcs/{vpc}`
    ///
    /// Arguments:
    /// - `vpc`: Name or ID of the VPC
    /// - `project`: Name or ID of the project
    /// ```ignore
    /// let response = client.vpc_delete()
    ///    .vpc(vpc)
    ///    .project(project)
    ///    .send()
    ///    .await;
    /// ```
    fn vpc_delete(&self) -> builder::VpcDelete;
}

impl ClientVpcsExt for Client {
    fn internet_gateway_ip_address_list(&self) -> builder::InternetGatewayIpAddressList {
        builder::InternetGatewayIpAddressList::new(self)
    }

    fn internet_gateway_ip_address_create(&self) -> builder::InternetGatewayIpAddressCreate {
        builder::InternetGatewayIpAddressCreate::new(self)
    }

    fn internet_gateway_ip_address_delete(&self) -> builder::InternetGatewayIpAddressDelete {
        builder::InternetGatewayIpAddressDelete::new(self)
    }

    fn internet_gateway_ip_pool_list(&self) -> builder::InternetGatewayIpPoolList {
        builder::InternetGatewayIpPoolList::new(self)
    }

    fn internet_gateway_ip_pool_create(&self) -> builder::InternetGatewayIpPoolCreate {
        builder::InternetGatewayIpPoolCreate::new(self)
    }

    fn internet_gateway_ip_pool_delete(&self) -> builder::InternetGatewayIpPoolDelete {
        builder::InternetGatewayIpPoolDelete::new(self)
    }

    fn internet_gateway_list(&self) -> builder::InternetGatewayList {
        builder::InternetGatewayList::new(self)
    }

    fn internet_gateway_create(&self) -> builder::InternetGatewayCreate {
        builder::InternetGatewayCreate::new(self)
    }

    fn internet_gateway_view(&self) -> builder::InternetGatewayView {
        builder::InternetGatewayView::new(self)
    }

    fn internet_gateway_delete(&self) -> builder::InternetGatewayDelete {
        builder::InternetGatewayDelete::new(self)
    }

    fn vpc_firewall_rules_view(&self) -> builder::VpcFirewallRulesView {
        builder::VpcFirewallRulesView::new(self)
    }

    fn vpc_firewall_rules_update(&self) -> builder::VpcFirewallRulesUpdate {
        builder::VpcFirewallRulesUpdate::new(self)
    }

    fn vpc_router_route_list(&self) -> builder::VpcRouterRouteList {
        builder::VpcRouterRouteList::new(self)
    }

    fn vpc_router_route_create(&self) -> builder::VpcRouterRouteCreate {
        builder::VpcRouterRouteCreate::new(self)
    }

    fn vpc_router_route_view(&self) -> builder::VpcRouterRouteView {
        builder::VpcRouterRouteView::new(self)
    }

    fn vpc_router_route_update(&self) -> builder::VpcRouterRouteUpdate {
        builder::VpcRouterRouteUpdate::new(self)
    }

    fn vpc_router_route_delete(&self) -> builder::VpcRouterRouteDelete {
        builder::VpcRouterRouteDelete::new(self)
    }

    fn vpc_router_list(&self) -> builder::VpcRouterList {
        builder::VpcRouterList::new(self)
    }

    fn vpc_router_create(&self) -> builder::VpcRouterCreate {
        builder::VpcRouterCreate::new(self)
    }

    fn vpc_router_view(&self) -> builder::VpcRouterView {
        builder::VpcRouterView::new(self)
    }

    fn vpc_router_update(&self) -> builder::VpcRouterUpdate {
        builder::VpcRouterUpdate::new(self)
    }

    fn vpc_router_delete(&self) -> builder::VpcRouterDelete {
        builder::VpcRouterDelete::new(self)
    }

    fn vpc_subnet_list(&self) -> builder::VpcSubnetList {
        builder::VpcSubnetList::new(self)
    }

    fn vpc_subnet_create(&self) -> builder::VpcSubnetCreate {
        builder::VpcSubnetCreate::new(self)
    }

    fn vpc_subnet_view(&self) -> builder::VpcSubnetView {
        builder::VpcSubnetView::new(self)
    }

    fn vpc_subnet_update(&self) -> builder::VpcSubnetUpdate {
        builder::VpcSubnetUpdate::new(self)
    }

    fn vpc_subnet_delete(&self) -> builder::VpcSubnetDelete {
        builder::VpcSubnetDelete::new(self)
    }

    fn vpc_subnet_list_network_interfaces(&self) -> builder::VpcSubnetListNetworkInterfaces {
        builder::VpcSubnetListNetworkInterfaces::new(self)
    }

    fn vpc_list(&self) -> builder::VpcList {
        builder::VpcList::new(self)
    }

    fn vpc_create(&self) -> builder::VpcCreate {
        builder::VpcCreate::new(self)
    }

    fn vpc_view(&self) -> builder::VpcView {
        builder::VpcView::new(self)
    }

    fn vpc_update(&self) -> builder::VpcUpdate {
        builder::VpcUpdate::new(self)
    }

    fn vpc_delete(&self) -> builder::VpcDelete {
        builder::VpcDelete::new(self)
    }
}

/// Types for composing operation parameters.
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, ClientHooks, ClientInfo, Error, OperationInfo, RequestBuilderExt,
        ResponseValue,
    };
    /// Builder for [`ClientHiddenExt::device_auth_request`]
    ///
    /// [`ClientHiddenExt::device_auth_request`]: super::ClientHiddenExt::device_auth_request
    #[derive(Debug, Clone)]
    pub struct DeviceAuthRequest<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeviceAuthRequest, String>,
    }

    impl<'a> DeviceAuthRequest<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAuthRequest>,
            <V as std::convert::TryInto<types::DeviceAuthRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DeviceAuthRequest` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeviceAuthRequest,
            ) -> types::builder::DeviceAuthRequest,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/device/auth`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::DeviceAuthRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/auth", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .form_urlencoded(&body)?
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "device_auth_request",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::device_auth_confirm`]
    ///
    /// [`ClientHiddenExt::device_auth_confirm`]: super::ClientHiddenExt::device_auth_confirm
    #[derive(Debug, Clone)]
    pub struct DeviceAuthConfirm<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeviceAuthVerify, String>,
    }

    impl<'a> DeviceAuthConfirm<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAuthVerify>,
            <V as std::convert::TryInto<types::DeviceAuthVerify>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DeviceAuthVerify` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeviceAuthVerify,
            ) -> types::builder::DeviceAuthVerify,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/device/confirm`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::DeviceAuthVerify::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/confirm", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "device_auth_confirm",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::device_access_token`]
    ///
    /// [`ClientHiddenExt::device_access_token`]: super::ClientHiddenExt::device_access_token
    #[derive(Debug, Clone)]
    pub struct DeviceAccessToken<'a> {
        client: &'a super::Client,
        body: Result<types::builder::DeviceAccessTokenRequest, String>,
    }

    impl<'a> DeviceAccessToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAccessTokenRequest>,
            <V as std::convert::TryInto<types::DeviceAccessTokenRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `DeviceAccessTokenRequest` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::DeviceAccessTokenRequest,
            ) -> types::builder::DeviceAccessTokenRequest,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/device/token`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::DeviceAccessTokenRequest::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/token", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .form_urlencoded(&body)?
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "device_access_token",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::probe_list`]
    ///
    /// [`ClientHiddenExt::probe_list`]: super::ClientHiddenExt::probe_list
    #[derive(Debug, Clone)]
    pub struct ProbeList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProbeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/experimental/v1/probes`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProbeInfoResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/experimental/v1/probes", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "probe_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/experimental/v1/probes`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::ProbeInfo, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientHiddenExt::probe_create`]
    ///
    /// [`ClientHiddenExt::probe_create`]: super::ClientHiddenExt::probe_create
    #[derive(Debug, Clone)]
    pub struct ProbeCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::ProbeCreate, String>,
    }

    impl<'a> ProbeCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProbeCreate>,
            <V as std::convert::TryInto<types::ProbeCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProbeCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProbeCreate) -> types::builder::ProbeCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/experimental/v1/probes`
        pub async fn send(self) -> Result<ResponseValue<types::Probe>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProbeCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/experimental/v1/probes", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "probe_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::probe_view`]
    ///
    /// [`ClientHiddenExt::probe_view`]: super::ClientHiddenExt::probe_view
    #[derive(Debug, Clone)]
    pub struct ProbeView<'a> {
        client: &'a super::Client,
        probe: Result<types::NameOrId, String>,
        project: Result<types::NameOrId, String>,
    }

    impl<'a> ProbeView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                probe: Err("probe was not initialized".to_string()),
                project: Err("project was not initialized".to_string()),
            }
        }

        pub fn probe<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.probe = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for probe failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/experimental/v1/probes/{probe}`
        pub async fn send(self) -> Result<ResponseValue<types::ProbeInfo>, Error<types::Error>> {
            let Self {
                client,
                probe,
                project,
            } = self;
            let probe = probe.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/probes/{}",
                client.baseurl,
                encode_path(&probe.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "probe_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::probe_delete`]
    ///
    /// [`ClientHiddenExt::probe_delete`]: super::ClientHiddenExt::probe_delete
    #[derive(Debug, Clone)]
    pub struct ProbeDelete<'a> {
        client: &'a super::Client,
        probe: Result<types::NameOrId, String>,
        project: Result<types::NameOrId, String>,
    }

    impl<'a> ProbeDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                probe: Err("probe was not initialized".to_string()),
                project: Err("project was not initialized".to_string()),
            }
        }

        pub fn probe<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.probe = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for probe failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/experimental/v1/probes/{probe}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                probe,
                project,
            } = self;
            let probe = probe.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/probes/{}",
                client.baseurl,
                encode_path(&probe.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "probe_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_list`]
    ///
    /// [`ClientHiddenExt::support_bundle_list`]: super::ClientHiddenExt::support_bundle_list
    #[derive(Debug, Clone)]
    pub struct SupportBundleList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SupportBundleList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/experimental/v1/system/support-bundles`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SupportBundleInfoResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/experimental/v1/system/support-bundles", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/experimental/v1/system/support-bundles`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SupportBundleInfo, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_create`]
    ///
    /// [`ClientHiddenExt::support_bundle_create`]: super::ClientHiddenExt::support_bundle_create
    #[derive(Debug, Clone)]
    pub struct SupportBundleCreate<'a> {
        client: &'a super::Client,
    }

    impl<'a> SupportBundleCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `POST` request to `/experimental/v1/system/support-bundles`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SupportBundleInfo>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/experimental/v1/system/support-bundles", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_view`]
    ///
    /// [`ClientHiddenExt::support_bundle_view`]: super::ClientHiddenExt::support_bundle_view
    #[derive(Debug, Clone)]
    pub struct SupportBundleView<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
    }

    impl<'a> SupportBundleView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SupportBundleInfo>, Error<types::Error>> {
            let Self {
                client,
                support_bundle,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_delete`]
    ///
    /// [`ClientHiddenExt::support_bundle_delete`]: super::ClientHiddenExt::support_bundle_delete
    #[derive(Debug, Clone)]
    pub struct SupportBundleDelete<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
    }

    impl<'a> SupportBundleDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        /// Sends a `DELETE` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                support_bundle,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_download`]
    ///
    /// [`ClientHiddenExt::support_bundle_download`]: super::ClientHiddenExt::support_bundle_download
    #[derive(Debug, Clone)]
    pub struct SupportBundleDownload<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
    }

    impl<'a> SupportBundleDownload<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}/download`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                support_bundle,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}/download",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_download",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_head`]
    ///
    /// [`ClientHiddenExt::support_bundle_head`]: super::ClientHiddenExt::support_bundle_head
    #[derive(Debug, Clone)]
    pub struct SupportBundleHead<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
    }

    impl<'a> SupportBundleHead<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        /// Sends a `HEAD` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}/download`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                support_bundle,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}/download",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.head(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_head",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_download_file`]
    ///
    /// [`ClientHiddenExt::support_bundle_download_file`]: super::ClientHiddenExt::support_bundle_download_file
    #[derive(Debug, Clone)]
    pub struct SupportBundleDownloadFile<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
        file: Result<::std::string::String, String>,
    }

    impl<'a> SupportBundleDownloadFile<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
                file: Err("file was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        pub fn file<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.file = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for file failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}/download/
        /// {file}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                support_bundle,
                file,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let file = file.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}/download/{}",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
                encode_path(&file.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_download_file",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_head_file`]
    ///
    /// [`ClientHiddenExt::support_bundle_head_file`]: super::ClientHiddenExt::support_bundle_head_file
    #[derive(Debug, Clone)]
    pub struct SupportBundleHeadFile<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
        file: Result<::std::string::String, String>,
    }

    impl<'a> SupportBundleHeadFile<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
                file: Err("file was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        pub fn file<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.file = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for file failed".to_string()
            });
            self
        }

        /// Sends a `HEAD` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}/download/
        /// {file}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                support_bundle,
                file,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let file = file.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}/download/{}",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
                encode_path(&file.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.head(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_head_file",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::support_bundle_index`]
    ///
    /// [`ClientHiddenExt::support_bundle_index`]: super::ClientHiddenExt::support_bundle_index
    #[derive(Debug, Clone)]
    pub struct SupportBundleIndex<'a> {
        client: &'a super::Client,
        support_bundle: Result<::uuid::Uuid, String>,
    }

    impl<'a> SupportBundleIndex<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                support_bundle: Err("support_bundle was not initialized".to_string()),
            }
        }

        pub fn support_bundle<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.support_bundle = value.try_into().map_err(|_| {
                "conversion to `:: uuid :: Uuid` for support_bundle failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to
        /// `/experimental/v1/system/support-bundles/{support_bundle}/index`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self {
                client,
                support_bundle,
            } = self;
            let support_bundle = support_bundle.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/experimental/v1/system/support-bundles/{}/index",
                client.baseurl,
                encode_path(&support_bundle.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client.client.get(url).headers(header_map).build()?;
            let info = OperationInfo {
                operation_id: "support_bundle_index",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    /// Builder for [`ClientLoginExt::login_saml`]
    ///
    /// [`ClientLoginExt::login_saml`]: super::ClientLoginExt::login_saml
    #[derive(Debug)]
    pub struct LoginSaml<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
        body: Result<reqwest::Body, String>,
    }

    impl<'a> LoginSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }

        /// Sends a `POST` request to `/login/{silo_name}/saml/{provider_name}`
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::CONTENT_TYPE,
                    ::reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "login_saml",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_list`]
    ///
    /// [`ClientHiddenExt::affinity_group_list`]: super::ClientHiddenExt::affinity_group_list
    #[derive(Debug, Clone)]
    pub struct AffinityGroupList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> AffinityGroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/affinity-groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/affinity-groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/affinity-groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AffinityGroup, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_create`]
    ///
    /// [`ClientHiddenExt::affinity_group_create`]: super::ClientHiddenExt::affinity_group_create
    #[derive(Debug, Clone)]
    pub struct AffinityGroupCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::AffinityGroupCreate, String>,
    }

    impl<'a> AffinityGroupCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AffinityGroupCreate>,
            <V as std::convert::TryInto<types::AffinityGroupCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AffinityGroupCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AffinityGroupCreate,
            ) -> types::builder::AffinityGroupCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/affinity-groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroup>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AffinityGroupCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/affinity-groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_view`]
    ///
    /// [`ClientHiddenExt::affinity_group_view`]: super::ClientHiddenExt::affinity_group_view
    #[derive(Debug, Clone)]
    pub struct AffinityGroupView<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AffinityGroupView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/affinity-groups/{affinity_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroup>, Error<types::Error>> {
            let Self {
                client,
                affinity_group,
                project,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_update`]
    ///
    /// [`ClientHiddenExt::affinity_group_update`]: super::ClientHiddenExt::affinity_group_update
    #[derive(Debug, Clone)]
    pub struct AffinityGroupUpdate<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::AffinityGroupUpdate, String>,
    }

    impl<'a> AffinityGroupUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AffinityGroupUpdate>,
            <V as std::convert::TryInto<types::AffinityGroupUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AffinityGroupUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AffinityGroupUpdate,
            ) -> types::builder::AffinityGroupUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/affinity-groups/{affinity_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroup>, Error<types::Error>> {
            let Self {
                client,
                affinity_group,
                project,
                body,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::AffinityGroupUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_delete`]
    ///
    /// [`ClientHiddenExt::affinity_group_delete`]: super::ClientHiddenExt::affinity_group_delete
    #[derive(Debug, Clone)]
    pub struct AffinityGroupDelete<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AffinityGroupDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/affinity-groups/{affinity_group}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                affinity_group,
                project,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_member_list`]
    ///
    /// [`ClientHiddenExt::affinity_group_member_list`]: super::ClientHiddenExt::affinity_group_member_list
    #[derive(Debug, Clone)]
    pub struct AffinityGroupMemberList<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> AffinityGroupMemberList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/affinity-groups/{affinity_group}/members`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroupMemberResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                affinity_group,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}/members",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_member_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/affinity-groups/{affinity_group}/members`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AffinityGroupMember, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_member_instance_view`]
    ///
    /// [`ClientHiddenExt::affinity_group_member_instance_view`]: super::ClientHiddenExt::affinity_group_member_instance_view
    #[derive(Debug, Clone)]
    pub struct AffinityGroupMemberInstanceView<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AffinityGroupMemberInstanceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/affinity-groups/{affinity_group}/members/instance/{instance}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroupMember>, Error<types::Error>> {
            let Self {
                client,
                affinity_group,
                instance,
                project,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}/members/instance/{}",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_member_instance_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_member_instance_add`]
    ///
    /// [`ClientHiddenExt::affinity_group_member_instance_add`]: super::ClientHiddenExt::affinity_group_member_instance_add
    #[derive(Debug, Clone)]
    pub struct AffinityGroupMemberInstanceAdd<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AffinityGroupMemberInstanceAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to
        /// `/v1/affinity-groups/{affinity_group}/members/instance/{instance}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroupMember>, Error<types::Error>> {
            let Self {
                client,
                affinity_group,
                instance,
                project,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}/members/instance/{}",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_member_instance_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::affinity_group_member_instance_delete`]
    ///
    /// [`ClientHiddenExt::affinity_group_member_instance_delete`]: super::ClientHiddenExt::affinity_group_member_instance_delete
    #[derive(Debug, Clone)]
    pub struct AffinityGroupMemberInstanceDelete<'a> {
        client: &'a super::Client,
        affinity_group: Result<types::NameOrId, String>,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AffinityGroupMemberInstanceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                affinity_group: Err("affinity_group was not initialized".to_string()),
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for affinity_group failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/affinity-groups/{affinity_group}/members/instance/{instance}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                affinity_group,
                instance,
                project,
            } = self;
            let affinity_group = affinity_group.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/affinity-groups/{}/members/instance/{}",
                client.baseurl,
                encode_path(&affinity_group.to_string()),
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "affinity_group_member_instance_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientAffinityExt::anti_affinity_group_list`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_list`]: super::ClientAffinityExt::anti_affinity_group_list
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> AntiAffinityGroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/anti-affinity-groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroupResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/anti-affinity-groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/anti-affinity-groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AntiAffinityGroup, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientAffinityExt::anti_affinity_group_create`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_create`]: super::ClientAffinityExt::anti_affinity_group_create
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::AntiAffinityGroupCreate, String>,
    }

    impl<'a> AntiAffinityGroupCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AntiAffinityGroupCreate>,
            <V as std::convert::TryInto<types::AntiAffinityGroupCreate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `AntiAffinityGroupCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AntiAffinityGroupCreate,
            ) -> types::builder::AntiAffinityGroupCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/anti-affinity-groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroup>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::AntiAffinityGroupCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/anti-affinity-groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientAffinityExt::anti_affinity_group_view`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_view`]: super::ClientAffinityExt::anti_affinity_group_view
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupView<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AntiAffinityGroupView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroup>, Error<types::Error>> {
            let Self {
                client,
                anti_affinity_group,
                project,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientAffinityExt::anti_affinity_group_update`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_update`]: super::ClientAffinityExt::anti_affinity_group_update
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupUpdate<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::AntiAffinityGroupUpdate, String>,
    }

    impl<'a> AntiAffinityGroupUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AntiAffinityGroupUpdate>,
            <V as std::convert::TryInto<types::AntiAffinityGroupUpdate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `AntiAffinityGroupUpdate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AntiAffinityGroupUpdate,
            ) -> types::builder::AntiAffinityGroupUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroup>, Error<types::Error>> {
            let Self {
                client,
                anti_affinity_group,
                project,
                body,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::AntiAffinityGroupUpdate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientAffinityExt::anti_affinity_group_delete`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_delete`]: super::ClientAffinityExt::anti_affinity_group_delete
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupDelete<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AntiAffinityGroupDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                anti_affinity_group,
                project,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientAffinityExt::anti_affinity_group_member_list`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_member_list`]: super::ClientAffinityExt::anti_affinity_group_member_list
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupMemberList<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> AntiAffinityGroupMemberList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}/members`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroupMemberResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                anti_affinity_group,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}/members",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_member_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}/members`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AntiAffinityGroupMember, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for
    /// [`ClientAffinityExt::anti_affinity_group_member_instance_view`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_member_instance_view`]: super::ClientAffinityExt::anti_affinity_group_member_instance_view
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupMemberInstanceView<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AntiAffinityGroupMemberInstanceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}/members/instance/
        /// {instance}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroupMember>, Error<types::Error>> {
            let Self {
                client,
                anti_affinity_group,
                instance,
                project,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}/members/instance/{}",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_member_instance_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientAffinityExt::anti_affinity_group_member_instance_add`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_member_instance_add`]: super::ClientAffinityExt::anti_affinity_group_member_instance_add
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupMemberInstanceAdd<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AntiAffinityGroupMemberInstanceAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}/members/instance/
        /// {instance}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroupMember>, Error<types::Error>> {
            let Self {
                client,
                anti_affinity_group,
                instance,
                project,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}/members/instance/{}",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_member_instance_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientAffinityExt::anti_affinity_group_member_instance_delete`]
    ///
    /// [`ClientAffinityExt::anti_affinity_group_member_instance_delete`]: super::ClientAffinityExt::anti_affinity_group_member_instance_delete
    #[derive(Debug, Clone)]
    pub struct AntiAffinityGroupMemberInstanceDelete<'a> {
        client: &'a super::Client,
        anti_affinity_group: Result<types::NameOrId, String>,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> AntiAffinityGroupMemberInstanceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                anti_affinity_group: Err("anti_affinity_group was not initialized".to_string()),
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn anti_affinity_group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.anti_affinity_group = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for anti_affinity_group failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/anti-affinity-groups/{anti_affinity_group}/members/instance/
        /// {instance}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                anti_affinity_group,
                instance,
                project,
            } = self;
            let anti_affinity_group = anti_affinity_group.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/anti-affinity-groups/{}/members/instance/{}",
                client.baseurl,
                encode_path(&anti_affinity_group.to_string()),
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "anti_affinity_group_member_instance_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::certificate_list`]
    ///
    /// [`ClientSilosExt::certificate_list`]: super::ClientSilosExt::certificate_list
    #[derive(Debug, Clone)]
    pub struct CertificateList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> CertificateList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/certificates`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CertificateResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/certificates", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "certificate_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/certificates`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Certificate, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSilosExt::certificate_create`]
    ///
    /// [`ClientSilosExt::certificate_create`]: super::ClientSilosExt::certificate_create
    #[derive(Debug, Clone)]
    pub struct CertificateCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CertificateCreate, String>,
    }

    impl<'a> CertificateCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CertificateCreate>,
            <V as std::convert::TryInto<types::CertificateCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CertificateCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::CertificateCreate,
            ) -> types::builder::CertificateCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/certificates`
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CertificateCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/certificates", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "certificate_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::certificate_view`]
    ///
    /// [`ClientSilosExt::certificate_view`]: super::ClientSilosExt::certificate_view
    #[derive(Debug, Clone)]
    pub struct CertificateView<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/certificates/{certificate}`
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "certificate_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::certificate_delete`]
    ///
    /// [`ClientSilosExt::certificate_delete`]: super::ClientSilosExt::certificate_delete
    #[derive(Debug, Clone)]
    pub struct CertificateDelete<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/certificates/{certificate}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "certificate_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_list`]
    ///
    /// [`ClientDisksExt::disk_list`]: super::ClientDisksExt::disk_list
    #[derive(Debug, Clone)]
    pub struct DiskList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> DiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/disks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientDisksExt::disk_create`]
    ///
    /// [`ClientDisksExt::disk_create`]: super::ClientDisksExt::disk_create
    #[derive(Debug, Clone)]
    pub struct DiskCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::DiskCreate, String>,
    }

    impl<'a> DiskCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskCreate>,
            <V as std::convert::TryInto<types::DiskCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskCreate) -> types::builder::DiskCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/disks`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/disks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_view`]
    ///
    /// [`ClientDisksExt::disk_view`]: super::ClientDisksExt::disk_view
    #[derive(Debug, Clone)]
    pub struct DiskView<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/disks/{disk}`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                disk,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_delete`]
    ///
    /// [`ClientDisksExt::disk_delete`]: super::ClientDisksExt::disk_delete
    #[derive(Debug, Clone)]
    pub struct DiskDelete<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/disks/{disk}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_bulk_write_import`]
    ///
    /// [`ClientDisksExt::disk_bulk_write_import`]: super::ClientDisksExt::disk_bulk_write_import
    #[derive(Debug, Clone)]
    pub struct DiskBulkWriteImport<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::ImportBlocksBulkWrite, String>,
    }

    impl<'a> DiskBulkWriteImport<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImportBlocksBulkWrite>,
            <V as std::convert::TryInto<types::ImportBlocksBulkWrite>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `ImportBlocksBulkWrite` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ImportBlocksBulkWrite,
            ) -> types::builder::ImportBlocksBulkWrite,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/disks/{disk}/bulk-write`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                project,
                body,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ImportBlocksBulkWrite::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}/bulk-write",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_bulk_write_import",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_bulk_write_import_start`]
    ///
    /// [`ClientDisksExt::disk_bulk_write_import_start`]: super::ClientDisksExt::disk_bulk_write_import_start
    #[derive(Debug, Clone)]
    pub struct DiskBulkWriteImportStart<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskBulkWriteImportStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/disks/{disk}/bulk-write-start`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}/bulk-write-start",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_bulk_write_import_start",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_bulk_write_import_stop`]
    ///
    /// [`ClientDisksExt::disk_bulk_write_import_stop`]: super::ClientDisksExt::disk_bulk_write_import_stop
    #[derive(Debug, Clone)]
    pub struct DiskBulkWriteImportStop<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskBulkWriteImportStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/disks/{disk}/bulk-write-stop`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}/bulk-write-stop",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_bulk_write_import_stop",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_finalize_import`]
    ///
    /// [`ClientDisksExt::disk_finalize_import`]: super::ClientDisksExt::disk_finalize_import
    #[derive(Debug, Clone)]
    pub struct DiskFinalizeImport<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::FinalizeDisk, String>,
    }

    impl<'a> DiskFinalizeImport<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FinalizeDisk>,
            <V as std::convert::TryInto<types::FinalizeDisk>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FinalizeDisk` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::FinalizeDisk) -> types::builder::FinalizeDisk,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/disks/{disk}/finalize`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                project,
                body,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::FinalizeDisk::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}/finalize",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_finalize_import",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientDisksExt::disk_metrics_list`]
    ///
    /// [`ClientDisksExt::disk_metrics_list`]: super::ClientDisksExt::disk_metrics_list
    #[derive(Debug, Clone)]
    pub struct DiskMetricsList<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        metric: Result<types::DiskMetricName, String>,
        end_time: Result<Option<::chrono::DateTime<::chrono::offset::Utc>>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        order: Result<Option<types::PaginationOrder>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        start_time: Result<Option<::chrono::DateTime<::chrono::offset::Utc>>, String>,
    }

    impl<'a> DiskMetricsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk: Err("disk was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                end_time: Ok(None),
                limit: Ok(None),
                order: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskMetricName>,
        {
            self.metric = value
                .try_into()
                .map_err(|_| "conversion to `DiskMetricName` for metric failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
        {
            self.end_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: chrono :: DateTime < :: chrono :: offset :: Utc >` for end_time \
                 failed"
                    .to_string()
            });
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PaginationOrder>,
        {
            self.order = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `PaginationOrder` for order failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
        {
            self.start_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: chrono :: DateTime < :: chrono :: offset :: Utc >` for \
                 start_time failed"
                    .to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/disks/{disk}/metrics/{metric}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                disk,
                metric,
                end_time,
                limit,
                order,
                page_token,
                project,
                start_time,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let order = order.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}/metrics/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
                encode_path(&metric.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("end_time", &end_time))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("order", &order))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new(
                    "start_time",
                    &start_time,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "disk_metrics_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/disks/{disk}/metrics/{metric}`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                end_time: Ok(None),
                order: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                start_time: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_list`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_list`]: super::ClientFloatingIpsExt::floating_ip_list
    #[derive(Debug, Clone)]
    pub struct FloatingIpList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> FloatingIpList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/floating-ips`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FloatingIpResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/floating-ips", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/floating-ips`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::FloatingIp, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_create`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_create`]: super::ClientFloatingIpsExt::floating_ip_create
    #[derive(Debug, Clone)]
    pub struct FloatingIpCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::FloatingIpCreate, String>,
    }

    impl<'a> FloatingIpCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FloatingIpCreate>,
            <V as std::convert::TryInto<types::FloatingIpCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FloatingIpCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FloatingIpCreate,
            ) -> types::builder::FloatingIpCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/floating-ips`
        pub async fn send(self) -> Result<ResponseValue<types::FloatingIp>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::FloatingIpCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/floating-ips", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_view`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_view`]: super::ClientFloatingIpsExt::floating_ip_view
    #[derive(Debug, Clone)]
    pub struct FloatingIpView<'a> {
        client: &'a super::Client,
        floating_ip: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> FloatingIpView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                floating_ip: Err("floating_ip was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn floating_ip<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.floating_ip = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for floating_ip failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/floating-ips/{floating_ip}`
        pub async fn send(self) -> Result<ResponseValue<types::FloatingIp>, Error<types::Error>> {
            let Self {
                client,
                floating_ip,
                project,
            } = self;
            let floating_ip = floating_ip.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/floating-ips/{}",
                client.baseurl,
                encode_path(&floating_ip.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_update`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_update`]: super::ClientFloatingIpsExt::floating_ip_update
    #[derive(Debug, Clone)]
    pub struct FloatingIpUpdate<'a> {
        client: &'a super::Client,
        floating_ip: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::FloatingIpUpdate, String>,
    }

    impl<'a> FloatingIpUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                floating_ip: Err("floating_ip was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn floating_ip<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.floating_ip = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for floating_ip failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FloatingIpUpdate>,
            <V as std::convert::TryInto<types::FloatingIpUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FloatingIpUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FloatingIpUpdate,
            ) -> types::builder::FloatingIpUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/floating-ips/{floating_ip}`
        pub async fn send(self) -> Result<ResponseValue<types::FloatingIp>, Error<types::Error>> {
            let Self {
                client,
                floating_ip,
                project,
                body,
            } = self;
            let floating_ip = floating_ip.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::FloatingIpUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/floating-ips/{}",
                client.baseurl,
                encode_path(&floating_ip.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_delete`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_delete`]: super::ClientFloatingIpsExt::floating_ip_delete
    #[derive(Debug, Clone)]
    pub struct FloatingIpDelete<'a> {
        client: &'a super::Client,
        floating_ip: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> FloatingIpDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                floating_ip: Err("floating_ip was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn floating_ip<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.floating_ip = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for floating_ip failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/floating-ips/{floating_ip}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                floating_ip,
                project,
            } = self;
            let floating_ip = floating_ip.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/floating-ips/{}",
                client.baseurl,
                encode_path(&floating_ip.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_attach`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_attach`]: super::ClientFloatingIpsExt::floating_ip_attach
    #[derive(Debug, Clone)]
    pub struct FloatingIpAttach<'a> {
        client: &'a super::Client,
        floating_ip: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::FloatingIpAttach, String>,
    }

    impl<'a> FloatingIpAttach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                floating_ip: Err("floating_ip was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn floating_ip<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.floating_ip = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for floating_ip failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FloatingIpAttach>,
            <V as std::convert::TryInto<types::FloatingIpAttach>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FloatingIpAttach` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::FloatingIpAttach,
            ) -> types::builder::FloatingIpAttach,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/floating-ips/{floating_ip}/attach`
        pub async fn send(self) -> Result<ResponseValue<types::FloatingIp>, Error<types::Error>> {
            let Self {
                client,
                floating_ip,
                project,
                body,
            } = self;
            let floating_ip = floating_ip.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::FloatingIpAttach::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/floating-ips/{}/attach",
                client.baseurl,
                encode_path(&floating_ip.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_attach",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientFloatingIpsExt::floating_ip_detach`]
    ///
    /// [`ClientFloatingIpsExt::floating_ip_detach`]: super::ClientFloatingIpsExt::floating_ip_detach
    #[derive(Debug, Clone)]
    pub struct FloatingIpDetach<'a> {
        client: &'a super::Client,
        floating_ip: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> FloatingIpDetach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                floating_ip: Err("floating_ip was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn floating_ip<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.floating_ip = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for floating_ip failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/floating-ips/{floating_ip}/detach`
        pub async fn send(self) -> Result<ResponseValue<types::FloatingIp>, Error<types::Error>> {
            let Self {
                client,
                floating_ip,
                project,
            } = self;
            let floating_ip = floating_ip.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/floating-ips/{}/detach",
                client.baseurl,
                encode_path(&floating_ip.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "floating_ip_detach",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::group_list`]
    ///
    /// [`ClientSilosExt::group_list`]: super::ClientSilosExt::group_list
    #[derive(Debug, Clone)]
    pub struct GroupList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> GroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "group_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSilosExt::group_view`]
    ///
    /// [`ClientSilosExt::group_view`]: super::ClientSilosExt::group_view
    #[derive(Debug, Clone)]
    pub struct GroupView<'a> {
        client: &'a super::Client,
        group_id: Result<::uuid::Uuid, String>,
    }

    impl<'a> GroupView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                group_id: Err("group_id was not initialized".to_string()),
            }
        }

        pub fn group_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.group_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for group_id failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/groups/{group_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Group>, Error<types::Error>> {
            let Self { client, group_id } = self;
            let group_id = group_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/groups/{}",
                client.baseurl,
                encode_path(&group_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "group_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientImagesExt::image_list`]
    ///
    /// [`ClientImagesExt::image_list`]: super::ClientImagesExt::image_list
    #[derive(Debug, Clone)]
    pub struct ImageList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ImageList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/images`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/images", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "image_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/images`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Image, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientImagesExt::image_create`]
    ///
    /// [`ClientImagesExt::image_create`]: super::ClientImagesExt::image_create
    #[derive(Debug, Clone)]
    pub struct ImageCreate<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::ImageCreate, String>,
    }

    impl<'a> ImageCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImageCreate>,
            <V as std::convert::TryInto<types::ImageCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ImageCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ImageCreate) -> types::builder::ImageCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/images`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ImageCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/images", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "image_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientImagesExt::image_view`]
    ///
    /// [`ClientImagesExt::image_view`]: super::ClientImagesExt::image_view
    #[derive(Debug, Clone)]
    pub struct ImageView<'a> {
        client: &'a super::Client,
        image: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ImageView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                image: Err("image was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn image<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.image = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for image failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/images/{image}`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                image,
                project,
            } = self;
            let image = image.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/images/{}",
                client.baseurl,
                encode_path(&image.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "image_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientImagesExt::image_delete`]
    ///
    /// [`ClientImagesExt::image_delete`]: super::ClientImagesExt::image_delete
    #[derive(Debug, Clone)]
    pub struct ImageDelete<'a> {
        client: &'a super::Client,
        image: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ImageDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                image: Err("image was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn image<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.image = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for image failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/images/{image}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                image,
                project,
            } = self;
            let image = image.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/images/{}",
                client.baseurl,
                encode_path(&image.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "image_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientImagesExt::image_demote`]
    ///
    /// [`ClientImagesExt::image_demote`]: super::ClientImagesExt::image_demote
    #[derive(Debug, Clone)]
    pub struct ImageDemote<'a> {
        client: &'a super::Client,
        image: Result<types::NameOrId, String>,
        project: Result<types::NameOrId, String>,
    }

    impl<'a> ImageDemote<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                image: Err("image was not initialized".to_string()),
                project: Err("project was not initialized".to_string()),
            }
        }

        pub fn image<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.image = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for image failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/images/{image}/demote`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                image,
                project,
            } = self;
            let image = image.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/images/{}/demote",
                client.baseurl,
                encode_path(&image.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "image_demote",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientImagesExt::image_promote`]
    ///
    /// [`ClientImagesExt::image_promote`]: super::ClientImagesExt::image_promote
    #[derive(Debug, Clone)]
    pub struct ImagePromote<'a> {
        client: &'a super::Client,
        image: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ImagePromote<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                image: Err("image was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn image<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.image = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for image failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/images/{image}/promote`
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                image,
                project,
            } = self;
            let image = image.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/images/{}/promote",
                client.baseurl,
                encode_path(&image.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "image_promote",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_list`]
    ///
    /// [`ClientInstancesExt::instance_list`]: super::ClientInstancesExt::instance_list
    #[derive(Debug, Clone)]
    pub struct InstanceList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/instances", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/instances`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_create`]
    ///
    /// [`ClientInstancesExt::instance_create`]: super::ClientInstancesExt::instance_create
    #[derive(Debug, Clone)]
    pub struct InstanceCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::InstanceCreate, String>,
    }

    impl<'a> InstanceCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceCreate>,
            <V as std::convert::TryInto<types::InstanceCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InstanceCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::InstanceCreate) -> types::builder::InstanceCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/instances`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InstanceCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/instances", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_view`]
    ///
    /// [`ClientInstancesExt::instance_view`]: super::ClientInstancesExt::instance_view
    #[derive(Debug, Clone)]
    pub struct InstanceView<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances/{instance}`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_update`]
    ///
    /// [`ClientInstancesExt::instance_update`]: super::ClientInstancesExt::instance_update
    #[derive(Debug, Clone)]
    pub struct InstanceUpdate<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::InstanceUpdate, String>,
    }

    impl<'a> InstanceUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceUpdate>,
            <V as std::convert::TryInto<types::InstanceUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `InstanceUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::InstanceUpdate) -> types::builder::InstanceUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/instances/{instance}`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InstanceUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_delete`]
    ///
    /// [`ClientInstancesExt::instance_delete`]: super::ClientInstancesExt::instance_delete
    #[derive(Debug, Clone)]
    pub struct InstanceDelete<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/instances/{instance}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::instance_affinity_group_list`]
    ///
    /// [`ClientHiddenExt::instance_affinity_group_list`]: super::ClientHiddenExt::instance_affinity_group_list
    #[derive(Debug, Clone)]
    pub struct InstanceAffinityGroupList<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceAffinityGroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances/{instance}/affinity-groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AffinityGroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/affinity-groups",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_affinity_group_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/instances/{instance}/affinity-groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AffinityGroup, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_anti_affinity_group_list`]
    ///
    /// [`ClientInstancesExt::instance_anti_affinity_group_list`]: super::ClientInstancesExt::instance_anti_affinity_group_list
    #[derive(Debug, Clone)]
    pub struct InstanceAntiAffinityGroupList<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceAntiAffinityGroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/instances/{instance}/anti-affinity-groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AntiAffinityGroupResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                instance,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/anti-affinity-groups",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_anti_affinity_group_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/instances/{instance}/anti-affinity-groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AntiAffinityGroup, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_disk_list`]
    ///
    /// [`ClientInstancesExt::instance_disk_list`]: super::ClientInstancesExt::instance_disk_list
    #[derive(Debug, Clone)]
    pub struct InstanceDiskList<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances/{instance}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_disk_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/instances/{instance}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_disk_attach`]
    ///
    /// [`ClientInstancesExt::instance_disk_attach`]: super::ClientInstancesExt::instance_disk_attach
    #[derive(Debug, Clone)]
    pub struct InstanceDiskAttach<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::DiskPath, String>,
    }

    impl<'a> InstanceDiskAttach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskPath>,
            <V as std::convert::TryInto<types::DiskPath>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskPath` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskPath) -> types::builder::DiskPath,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/instances/{instance}/disks/attach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskPath::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks/attach",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_disk_attach",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_disk_detach`]
    ///
    /// [`ClientInstancesExt::instance_disk_detach`]: super::ClientInstancesExt::instance_disk_detach
    #[derive(Debug, Clone)]
    pub struct InstanceDiskDetach<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::DiskPath, String>,
    }

    impl<'a> InstanceDiskDetach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskPath>,
            <V as std::convert::TryInto<types::DiskPath>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `DiskPath` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::DiskPath) -> types::builder::DiskPath,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/instances/{instance}/disks/detach`
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::DiskPath::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks/detach",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_disk_detach",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_external_ip_list`]
    ///
    /// [`ClientInstancesExt::instance_external_ip_list`]: super::ClientInstancesExt::instance_external_ip_list
    #[derive(Debug, Clone)]
    pub struct InstanceExternalIpList<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceExternalIpList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances/{instance}/external-ips`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExternalIpResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/external-ips",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_external_ip_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_ephemeral_ip_attach`]
    ///
    /// [`ClientInstancesExt::instance_ephemeral_ip_attach`]: super::ClientInstancesExt::instance_ephemeral_ip_attach
    #[derive(Debug, Clone)]
    pub struct InstanceEphemeralIpAttach<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::EphemeralIpCreate, String>,
    }

    impl<'a> InstanceEphemeralIpAttach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::EphemeralIpCreate>,
            <V as std::convert::TryInto<types::EphemeralIpCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `EphemeralIpCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::EphemeralIpCreate,
            ) -> types::builder::EphemeralIpCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to
        /// `/v1/instances/{instance}/external-ips/ephemeral`
        pub async fn send(self) -> Result<ResponseValue<types::ExternalIp>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::EphemeralIpCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/external-ips/ephemeral",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_ephemeral_ip_attach",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_ephemeral_ip_detach`]
    ///
    /// [`ClientInstancesExt::instance_ephemeral_ip_detach`]: super::ClientInstancesExt::instance_ephemeral_ip_detach
    #[derive(Debug, Clone)]
    pub struct InstanceEphemeralIpDetach<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceEphemeralIpDetach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/instances/{instance}/external-ips/ephemeral`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/external-ips/ephemeral",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_ephemeral_ip_detach",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_reboot`]
    ///
    /// [`ClientInstancesExt::instance_reboot`]: super::ClientInstancesExt::instance_reboot
    #[derive(Debug, Clone)]
    pub struct InstanceReboot<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceReboot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/instances/{instance}/reboot`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/reboot",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_reboot",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_serial_console`]
    ///
    /// [`ClientInstancesExt::instance_serial_console`]: super::ClientInstancesExt::instance_serial_console
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsole<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        from_start: Result<Option<u64>, String>,
        max_bytes: Result<Option<u64>, String>,
        most_recent: Result<Option<u64>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceSerialConsole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                from_start: Ok(None),
                max_bytes: Ok(None),
                most_recent: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn from_start<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.from_start = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for from_start failed".to_string());
            self
        }

        pub fn max_bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.max_bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for max_bytes failed".to_string());
            self
        }

        pub fn most_recent<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.most_recent = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for most_recent failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances/{instance}/serial-console`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceSerialConsoleData>, Error<types::Error>> {
            let Self {
                client,
                instance,
                from_start,
                max_bytes,
                most_recent,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let from_start = from_start.map_err(Error::InvalidRequest)?;
            let max_bytes = max_bytes.map_err(Error::InvalidRequest)?;
            let most_recent = most_recent.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/serial-console",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "from_start",
                    &from_start,
                ))
                .query(&progenitor_client::QueryParam::new("max_bytes", &max_bytes))
                .query(&progenitor_client::QueryParam::new(
                    "most_recent",
                    &most_recent,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_serial_console",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_serial_console_stream`]
    ///
    /// [`ClientInstancesExt::instance_serial_console_stream`]: super::ClientInstancesExt::instance_serial_console_stream
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleStream<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        most_recent: Result<Option<u64>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceSerialConsoleStream<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                most_recent: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn most_recent<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.most_recent = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for most_recent failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/instances/{instance}/serial-console/stream`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<reqwest::Upgraded>, Error<reqwest::Upgraded>> {
            let Self {
                client,
                instance,
                most_recent,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let most_recent = most_recent.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/serial-console/stream",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .query(&progenitor_client::QueryParam::new(
                    "most_recent",
                    &most_recent,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .header(::reqwest::header::CONNECTION, "Upgrade")
                .header(::reqwest::header::UPGRADE, "websocket")
                .header(::reqwest::header::SEC_WEBSOCKET_VERSION, "13")
                .header(
                    ::reqwest::header::SEC_WEBSOCKET_KEY,
                    ::base64::Engine::encode(
                        &::base64::engine::general_purpose::STANDARD,
                        ::rand::random::<[u8; 16]>(),
                    ),
                )
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_serial_console_stream",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                101u16 => ResponseValue::upgrade(response).await,
                200..=299 => ResponseValue::upgrade(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_ssh_public_key_list`]
    ///
    /// [`ClientInstancesExt::instance_ssh_public_key_list`]: super::ClientInstancesExt::instance_ssh_public_key_list
    #[derive(Debug, Clone)]
    pub struct InstanceSshPublicKeyList<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceSshPublicKeyList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/instances/{instance}/ssh-public-keys`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/ssh-public-keys",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_ssh_public_key_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/instances/{instance}/ssh-public-keys`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_start`]
    ///
    /// [`ClientInstancesExt::instance_start`]: super::ClientInstancesExt::instance_start
    #[derive(Debug, Clone)]
    pub struct InstanceStart<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/instances/{instance}/start`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/start",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_start",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_stop`]
    ///
    /// [`ClientInstancesExt::instance_stop`]: super::ClientInstancesExt::instance_stop
    #[derive(Debug, Clone)]
    pub struct InstanceStop<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/instances/{instance}/stop`
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/stop",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_stop",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_ip_address_list`]
    ///
    /// [`ClientVpcsExt::internet_gateway_ip_address_list`]: super::ClientVpcsExt::internet_gateway_ip_address_list
    #[derive(Debug, Clone)]
    pub struct InternetGatewayIpAddressList<'a> {
        client: &'a super::Client,
        gateway: Result<Option<types::NameOrId>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayIpAddressList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                gateway: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/internet-gateway-ip-addresses`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGatewayIpAddressResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                gateway,
                limit,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/internet-gateway-ip-addresses", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("gateway", &gateway))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_ip_address_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/internet-gateway-ip-addresses`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::InternetGatewayIpAddress, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                gateway: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_ip_address_create`]
    ///
    /// [`ClientVpcsExt::internet_gateway_ip_address_create`]: super::ClientVpcsExt::internet_gateway_ip_address_create
    #[derive(Debug, Clone)]
    pub struct InternetGatewayIpAddressCreate<'a> {
        client: &'a super::Client,
        gateway: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::InternetGatewayIpAddressCreate, String>,
    }

    impl<'a> InternetGatewayIpAddressCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                gateway: Err("gateway was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InternetGatewayIpAddressCreate>,
            <V as std::convert::TryInto<types::InternetGatewayIpAddressCreate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InternetGatewayIpAddressCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::InternetGatewayIpAddressCreate,
            ) -> types::builder::InternetGatewayIpAddressCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/internet-gateway-ip-addresses`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGatewayIpAddress>, Error<types::Error>> {
            let Self {
                client,
                gateway,
                project,
                vpc,
                body,
            } = self;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::InternetGatewayIpAddressCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/internet-gateway-ip-addresses", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("gateway", &gateway))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_ip_address_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_ip_address_delete`]
    ///
    /// [`ClientVpcsExt::internet_gateway_ip_address_delete`]: super::ClientVpcsExt::internet_gateway_ip_address_delete
    #[derive(Debug, Clone)]
    pub struct InternetGatewayIpAddressDelete<'a> {
        client: &'a super::Client,
        address: Result<types::NameOrId, String>,
        cascade: Result<Option<bool>, String>,
        gateway: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayIpAddressDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address: Err("address was not initialized".to_string()),
                cascade: Ok(None),
                gateway: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.address = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for address failed".to_string());
            self
        }

        pub fn cascade<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.cascade = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for cascade failed".to_string());
            self
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/internet-gateway-ip-addresses/{address}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                address,
                cascade,
                gateway,
                project,
                vpc,
            } = self;
            let address = address.map_err(Error::InvalidRequest)?;
            let cascade = cascade.map_err(Error::InvalidRequest)?;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/internet-gateway-ip-addresses/{}",
                client.baseurl,
                encode_path(&address.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("cascade", &cascade))
                .query(&progenitor_client::QueryParam::new("gateway", &gateway))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_ip_address_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_ip_pool_list`]
    ///
    /// [`ClientVpcsExt::internet_gateway_ip_pool_list`]: super::ClientVpcsExt::internet_gateway_ip_pool_list
    #[derive(Debug, Clone)]
    pub struct InternetGatewayIpPoolList<'a> {
        client: &'a super::Client,
        gateway: Result<Option<types::NameOrId>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayIpPoolList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                gateway: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/internet-gateway-ip-pools`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGatewayIpPoolResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                gateway,
                limit,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/internet-gateway-ip-pools", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("gateway", &gateway))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_ip_pool_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/internet-gateway-ip-pools`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::InternetGatewayIpPool, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                gateway: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_ip_pool_create`]
    ///
    /// [`ClientVpcsExt::internet_gateway_ip_pool_create`]: super::ClientVpcsExt::internet_gateway_ip_pool_create
    #[derive(Debug, Clone)]
    pub struct InternetGatewayIpPoolCreate<'a> {
        client: &'a super::Client,
        gateway: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::InternetGatewayIpPoolCreate, String>,
    }

    impl<'a> InternetGatewayIpPoolCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                gateway: Err("gateway was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InternetGatewayIpPoolCreate>,
            <V as std::convert::TryInto<types::InternetGatewayIpPoolCreate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InternetGatewayIpPoolCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::InternetGatewayIpPoolCreate,
            ) -> types::builder::InternetGatewayIpPoolCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/internet-gateway-ip-pools`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGatewayIpPool>, Error<types::Error>> {
            let Self {
                client,
                gateway,
                project,
                vpc,
                body,
            } = self;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::InternetGatewayIpPoolCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/internet-gateway-ip-pools", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("gateway", &gateway))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_ip_pool_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_ip_pool_delete`]
    ///
    /// [`ClientVpcsExt::internet_gateway_ip_pool_delete`]: super::ClientVpcsExt::internet_gateway_ip_pool_delete
    #[derive(Debug, Clone)]
    pub struct InternetGatewayIpPoolDelete<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        cascade: Result<Option<bool>, String>,
        gateway: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayIpPoolDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                cascade: Ok(None),
                gateway: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn cascade<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.cascade = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for cascade failed".to_string());
            self
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/internet-gateway-ip-pools/{pool}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                pool,
                cascade,
                gateway,
                project,
                vpc,
            } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let cascade = cascade.map_err(Error::InvalidRequest)?;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/internet-gateway-ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("cascade", &cascade))
                .query(&progenitor_client::QueryParam::new("gateway", &gateway))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_ip_pool_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_list`]
    ///
    /// [`ClientVpcsExt::internet_gateway_list`]: super::ClientVpcsExt::internet_gateway_list
    #[derive(Debug, Clone)]
    pub struct InternetGatewayList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/internet-gateways`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGatewayResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/internet-gateways", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/internet-gateways`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::InternetGateway, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_create`]
    ///
    /// [`ClientVpcsExt::internet_gateway_create`]: super::ClientVpcsExt::internet_gateway_create
    #[derive(Debug, Clone)]
    pub struct InternetGatewayCreate<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::builder::InternetGatewayCreate, String>,
    }

    impl<'a> InternetGatewayCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InternetGatewayCreate>,
            <V as std::convert::TryInto<types::InternetGatewayCreate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InternetGatewayCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::InternetGatewayCreate,
            ) -> types::builder::InternetGatewayCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/internet-gateways`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGateway>, Error<types::Error>> {
            let Self {
                client,
                project,
                vpc,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::InternetGatewayCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/internet-gateways", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_view`]
    ///
    /// [`ClientVpcsExt::internet_gateway_view`]: super::ClientVpcsExt::internet_gateway_view
    #[derive(Debug, Clone)]
    pub struct InternetGatewayView<'a> {
        client: &'a super::Client,
        gateway: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                gateway: Err("gateway was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/internet-gateways/{gateway}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InternetGateway>, Error<types::Error>> {
            let Self {
                client,
                gateway,
                project,
                vpc,
            } = self;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/internet-gateways/{}",
                client.baseurl,
                encode_path(&gateway.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::internet_gateway_delete`]
    ///
    /// [`ClientVpcsExt::internet_gateway_delete`]: super::ClientVpcsExt::internet_gateway_delete
    #[derive(Debug, Clone)]
    pub struct InternetGatewayDelete<'a> {
        client: &'a super::Client,
        gateway: Result<types::NameOrId, String>,
        cascade: Result<Option<bool>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InternetGatewayDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                gateway: Err("gateway was not initialized".to_string()),
                cascade: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn gateway<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.gateway = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for gateway failed".to_string());
            self
        }

        pub fn cascade<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.cascade = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for cascade failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/internet-gateways/{gateway}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                gateway,
                cascade,
                project,
                vpc,
            } = self;
            let gateway = gateway.map_err(Error::InvalidRequest)?;
            let cascade = cascade.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/internet-gateways/{}",
                client.baseurl,
                encode_path(&gateway.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("cascade", &cascade))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "internet_gateway_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_ip_pool_list`]
    ///
    /// [`ClientProjectsExt::project_ip_pool_list`]: super::ClientProjectsExt::project_ip_pool_list
    #[derive(Debug, Clone)]
    pub struct ProjectIpPoolList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProjectIpPoolList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/ip-pools`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloIpPoolResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/ip-pools", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_ip_pool_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/ip-pools`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SiloIpPool, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientProjectsExt::project_ip_pool_view`]
    ///
    /// [`ClientProjectsExt::project_ip_pool_view`]: super::ClientProjectsExt::project_ip_pool_view
    #[derive(Debug, Clone)]
    pub struct ProjectIpPoolView<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
    }

    impl<'a> ProjectIpPoolView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/ip-pools/{pool}`
        pub async fn send(self) -> Result<ResponseValue<types::SiloIpPool>, Error<types::Error>> {
            let Self { client, pool } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_ip_pool_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientLoginExt::login_local`]
    ///
    /// [`ClientLoginExt::login_local`]: super::ClientLoginExt::login_local
    #[derive(Debug, Clone)]
    pub struct LoginLocal<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::builder::UsernamePasswordCredentials, String>,
    }

    impl<'a> LoginLocal<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UsernamePasswordCredentials>,
            <V as std::convert::TryInto<types::UsernamePasswordCredentials>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `UsernamePasswordCredentials` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UsernamePasswordCredentials,
            ) -> types::builder::UsernamePasswordCredentials,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/login/{silo_name}/local`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::UsernamePasswordCredentials::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/login/{}/local",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "login_local",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::logout`]
    ///
    /// [`ClientHiddenExt::logout`]: super::ClientHiddenExt::logout
    #[derive(Debug, Clone)]
    pub struct Logout<'a> {
        client: &'a super::Client,
    }

    impl<'a> Logout<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `POST` request to `/v1/logout`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/logout", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "logout",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSessionExt::current_user_view`]
    ///
    /// [`ClientSessionExt::current_user_view`]: super::ClientSessionExt::current_user_view
    #[derive(Debug, Clone)]
    pub struct CurrentUserView<'a> {
        client: &'a super::Client,
    }

    impl<'a> CurrentUserView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/me`
        pub async fn send(self) -> Result<ResponseValue<types::CurrentUser>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/me", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "current_user_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSessionExt::current_user_groups`]
    ///
    /// [`ClientSessionExt::current_user_groups`]: super::ClientSessionExt::current_user_groups
    #[derive(Debug, Clone)]
    pub struct CurrentUserGroups<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> CurrentUserGroups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/me/groups`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/me/groups", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "current_user_groups",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/me/groups`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSessionExt::current_user_ssh_key_list`]
    ///
    /// [`ClientSessionExt::current_user_ssh_key_list`]: super::ClientSessionExt::current_user_ssh_key_list
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> CurrentUserSshKeyList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/me/ssh-keys`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/me/ssh-keys", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "current_user_ssh_key_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/me/ssh-keys`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSessionExt::current_user_ssh_key_create`]
    ///
    /// [`ClientSessionExt::current_user_ssh_key_create`]: super::ClientSessionExt::current_user_ssh_key_create
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SshKeyCreate, String>,
    }

    impl<'a> CurrentUserSshKeyCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SshKeyCreate>,
            <V as std::convert::TryInto<types::SshKeyCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SshKeyCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SshKeyCreate) -> types::builder::SshKeyCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/me/ssh-keys`
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SshKeyCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/me/ssh-keys", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "current_user_ssh_key_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSessionExt::current_user_ssh_key_view`]
    ///
    /// [`ClientSessionExt::current_user_ssh_key_view`]: super::ClientSessionExt::current_user_ssh_key_view
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyView<'a> {
        client: &'a super::Client,
        ssh_key: Result<types::NameOrId, String>,
    }

    impl<'a> CurrentUserSshKeyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                ssh_key: Err("ssh_key was not initialized".to_string()),
            }
        }

        pub fn ssh_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.ssh_key = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for ssh_key failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/me/ssh-keys/{ssh_key}`
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, ssh_key } = self;
            let ssh_key = ssh_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/me/ssh-keys/{}",
                client.baseurl,
                encode_path(&ssh_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "current_user_ssh_key_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSessionExt::current_user_ssh_key_delete`]
    ///
    /// [`ClientSessionExt::current_user_ssh_key_delete`]: super::ClientSessionExt::current_user_ssh_key_delete
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyDelete<'a> {
        client: &'a super::Client,
        ssh_key: Result<types::NameOrId, String>,
    }

    impl<'a> CurrentUserSshKeyDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                ssh_key: Err("ssh_key was not initialized".to_string()),
            }
        }

        pub fn ssh_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.ssh_key = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for ssh_key failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/me/ssh-keys/{ssh_key}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, ssh_key } = self;
            let ssh_key = ssh_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/me/ssh-keys/{}",
                client.baseurl,
                encode_path(&ssh_key.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "current_user_ssh_key_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientMetricsExt::silo_metric`]
    ///
    /// [`ClientMetricsExt::silo_metric`]: super::ClientMetricsExt::silo_metric
    #[derive(Debug, Clone)]
    pub struct SiloMetric<'a> {
        client: &'a super::Client,
        metric_name: Result<types::SystemMetricName, String>,
        end_time: Result<Option<::chrono::DateTime<::chrono::offset::Utc>>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        order: Result<Option<types::PaginationOrder>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        start_time: Result<Option<::chrono::DateTime<::chrono::offset::Utc>>, String>,
    }

    impl<'a> SiloMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                metric_name: Err("metric_name was not initialized".to_string()),
                end_time: Ok(None),
                limit: Ok(None),
                order: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn metric_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemMetricName>,
        {
            self.metric_name = value
                .try_into()
                .map_err(|_| "conversion to `SystemMetricName` for metric_name failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
        {
            self.end_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: chrono :: DateTime < :: chrono :: offset :: Utc >` for end_time \
                 failed"
                    .to_string()
            });
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PaginationOrder>,
        {
            self.order = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `PaginationOrder` for order failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
        {
            self.start_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: chrono :: DateTime < :: chrono :: offset :: Utc >` for \
                 start_time failed"
                    .to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/metrics/{metric_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                metric_name,
                end_time,
                limit,
                order,
                page_token,
                project,
                start_time,
            } = self;
            let metric_name = metric_name.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let order = order.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/metrics/{}",
                client.baseurl,
                encode_path(&metric_name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("end_time", &end_time))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("order", &order))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new(
                    "start_time",
                    &start_time,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_metric",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/metrics/{metric_name}`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                end_time: Ok(None),
                order: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                start_time: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_network_interface_list`]
    ///
    /// [`ClientInstancesExt::instance_network_interface_list`]: super::ClientInstancesExt::instance_network_interface_list
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceList<'a> {
        client: &'a super::Client,
        instance: Result<Option<types::NameOrId>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceNetworkInterfaceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceNetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                instance,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/network-interfaces", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("instance", &instance))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_network_interface_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/network-interfaces`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::InstanceNetworkInterface, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                instance: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientInstancesExt::instance_network_interface_create`]
    ///
    /// [`ClientInstancesExt::instance_network_interface_create`]: super::ClientInstancesExt::instance_network_interface_create
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceCreate<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::InstanceNetworkInterfaceCreate, String>,
    }

    impl<'a> InstanceNetworkInterfaceCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                instance: Err("instance was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceNetworkInterfaceCreate>,
            <V as std::convert::TryInto<types::InstanceNetworkInterfaceCreate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InstanceNetworkInterfaceCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::InstanceNetworkInterfaceCreate,
            ) -> types::builder::InstanceNetworkInterfaceCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceNetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                instance,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::InstanceNetworkInterfaceCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/network-interfaces", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("instance", &instance))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_network_interface_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_network_interface_view`]
    ///
    /// [`ClientInstancesExt::instance_network_interface_view`]: super::ClientInstancesExt::instance_network_interface_view
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceView<'a> {
        client: &'a super::Client,
        interface: Result<types::NameOrId, String>,
        instance: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceNetworkInterfaceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                interface: Err("interface was not initialized".to_string()),
                instance: Ok(None),
                project: Ok(None),
            }
        }

        pub fn interface<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.interface = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for interface failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/network-interfaces/{interface}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceNetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                interface,
                instance,
                project,
            } = self;
            let interface = interface.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/network-interfaces/{}",
                client.baseurl,
                encode_path(&interface.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("instance", &instance))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_network_interface_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_network_interface_update`]
    ///
    /// [`ClientInstancesExt::instance_network_interface_update`]: super::ClientInstancesExt::instance_network_interface_update
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceUpdate<'a> {
        client: &'a super::Client,
        interface: Result<types::NameOrId, String>,
        instance: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::InstanceNetworkInterfaceUpdate, String>,
    }

    impl<'a> InstanceNetworkInterfaceUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                interface: Err("interface was not initialized".to_string()),
                instance: Ok(None),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn interface<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.interface = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for interface failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceNetworkInterfaceUpdate>,
            <V as std::convert::TryInto<types::InstanceNetworkInterfaceUpdate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `InstanceNetworkInterfaceUpdate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::InstanceNetworkInterfaceUpdate,
            ) -> types::builder::InstanceNetworkInterfaceUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/network-interfaces/{interface}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceNetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                interface,
                instance,
                project,
                body,
            } = self;
            let interface = interface.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::InstanceNetworkInterfaceUpdate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/network-interfaces/{}",
                client.baseurl,
                encode_path(&interface.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("instance", &instance))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_network_interface_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientInstancesExt::instance_network_interface_delete`]
    ///
    /// [`ClientInstancesExt::instance_network_interface_delete`]: super::ClientInstancesExt::instance_network_interface_delete
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceDelete<'a> {
        client: &'a super::Client,
        interface: Result<types::NameOrId, String>,
        instance: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceNetworkInterfaceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                interface: Err("interface was not initialized".to_string()),
                instance: Ok(None),
                project: Ok(None),
            }
        }

        pub fn interface<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.interface = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for interface failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/network-interfaces/{interface}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                interface,
                instance,
                project,
            } = self;
            let interface = interface.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/network-interfaces/{}",
                client.baseurl,
                encode_path(&interface.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("instance", &instance))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "instance_network_interface_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemStatusExt::ping`]
    ///
    /// [`ClientSystemStatusExt::ping`]: super::ClientSystemStatusExt::ping
    #[derive(Debug, Clone)]
    pub struct Ping<'a> {
        client: &'a super::Client,
    }

    impl<'a> Ping<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/ping`
        pub async fn send(self) -> Result<ResponseValue<types::Ping>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/ping", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ping",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::policy_view`]
    ///
    /// [`ClientSilosExt::policy_view`]: super::ClientSilosExt::policy_view
    #[derive(Debug, Clone)]
    pub struct PolicyView<'a> {
        client: &'a super::Client,
    }

    impl<'a> PolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/policy", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "policy_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::policy_update`]
    ///
    /// [`ClientSilosExt::policy_update`]: super::ClientSilosExt::policy_update
    #[derive(Debug, Clone)]
    pub struct PolicyUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SiloRolePolicy, String>,
    }

    impl<'a> PolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
            <V as std::convert::TryInto<types::SiloRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SiloRolePolicy) -> types::builder::SiloRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SiloRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/policy", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "policy_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_list`]
    ///
    /// [`ClientProjectsExt::project_list`]: super::ClientProjectsExt::project_list
    #[derive(Debug, Clone)]
    pub struct ProjectList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProjectList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/projects`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/projects", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/projects`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientProjectsExt::project_create`]
    ///
    /// [`ClientProjectsExt::project_create`]: super::ClientProjectsExt::project_create
    #[derive(Debug, Clone)]
    pub struct ProjectCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::ProjectCreate, String>,
    }

    impl<'a> ProjectCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectCreate>,
            <V as std::convert::TryInto<types::ProjectCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProjectCreate) -> types::builder::ProjectCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/projects`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::ProjectCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/projects", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_view`]
    ///
    /// [`ClientProjectsExt::project_view`]: super::ClientProjectsExt::project_view
    #[derive(Debug, Clone)]
    pub struct ProjectView<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
    }

    impl<'a> ProjectView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/projects/{project}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self { client, project } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_update`]
    ///
    /// [`ClientProjectsExt::project_update`]: super::ClientProjectsExt::project_update
    #[derive(Debug, Clone)]
    pub struct ProjectUpdate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::ProjectUpdate, String>,
    }

    impl<'a> ProjectUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectUpdate>,
            <V as std::convert::TryInto<types::ProjectUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::ProjectUpdate) -> types::builder::ProjectUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/projects/{project}`
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_delete`]
    ///
    /// [`ClientProjectsExt::project_delete`]: super::ClientProjectsExt::project_delete
    #[derive(Debug, Clone)]
    pub struct ProjectDelete<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
    }

    impl<'a> ProjectDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/projects/{project}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, project } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_policy_view`]
    ///
    /// [`ClientProjectsExt::project_policy_view`]: super::ClientProjectsExt::project_policy_view
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyView<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
    }

    impl<'a> ProjectPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/projects/{project}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self { client, project } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}/policy",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_policy_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientProjectsExt::project_policy_update`]
    ///
    /// [`ClientProjectsExt::project_policy_update`]: super::ClientProjectsExt::project_policy_update
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyUpdate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::ProjectRolePolicy, String>,
    }

    impl<'a> ProjectPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectRolePolicy>,
            <V as std::convert::TryInto<types::ProjectRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `ProjectRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::ProjectRolePolicy,
            ) -> types::builder::ProjectRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/projects/{project}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::ProjectRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}/policy",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "project_policy_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSnapshotsExt::snapshot_list`]
    ///
    /// [`ClientSnapshotsExt::snapshot_list`]: super::ClientSnapshotsExt::snapshot_list
    #[derive(Debug, Clone)]
    pub struct SnapshotList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SnapshotList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/snapshots`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/snapshots", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "snapshot_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/snapshots`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSnapshotsExt::snapshot_create`]
    ///
    /// [`ClientSnapshotsExt::snapshot_create`]: super::ClientSnapshotsExt::snapshot_create
    #[derive(Debug, Clone)]
    pub struct SnapshotCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::SnapshotCreate, String>,
    }

    impl<'a> SnapshotCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreate>,
            <V as std::convert::TryInto<types::SnapshotCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SnapshotCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SnapshotCreate) -> types::builder::SnapshotCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/snapshots`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SnapshotCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/snapshots", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "snapshot_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSnapshotsExt::snapshot_view`]
    ///
    /// [`ClientSnapshotsExt::snapshot_view`]: super::ClientSnapshotsExt::snapshot_view
    #[derive(Debug, Clone)]
    pub struct SnapshotView<'a> {
        client: &'a super::Client,
        snapshot: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> SnapshotView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                snapshot: Err("snapshot was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.snapshot = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for snapshot failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/snapshots/{snapshot}`
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                snapshot,
                project,
            } = self;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/snapshots/{}",
                client.baseurl,
                encode_path(&snapshot.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "snapshot_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSnapshotsExt::snapshot_delete`]
    ///
    /// [`ClientSnapshotsExt::snapshot_delete`]: super::ClientSnapshotsExt::snapshot_delete
    #[derive(Debug, Clone)]
    pub struct SnapshotDelete<'a> {
        client: &'a super::Client,
        snapshot: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> SnapshotDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                snapshot: Err("snapshot was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.snapshot = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for snapshot failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/snapshots/{snapshot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                snapshot,
                project,
            } = self;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/snapshots/{}",
                client.baseurl,
                encode_path(&snapshot.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "snapshot_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::physical_disk_list`]
    ///
    /// [`ClientSystemHardwareExt::physical_disk_list`]: super::ClientSystemHardwareExt::physical_disk_list
    #[derive(Debug, Clone)]
    pub struct PhysicalDiskList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> PhysicalDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/disks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "physical_disk_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/hardware/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::physical_disk_view`]
    ///
    /// [`ClientSystemHardwareExt::physical_disk_view`]: super::ClientSystemHardwareExt::physical_disk_view
    #[derive(Debug, Clone)]
    pub struct PhysicalDiskView<'a> {
        client: &'a super::Client,
        disk_id: Result<::uuid::Uuid, String>,
    }

    impl<'a> PhysicalDiskView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                disk_id: Err("disk_id was not initialized".to_string()),
            }
        }

        pub fn disk_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.disk_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for disk_id failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/disks/{disk_id}`
        pub async fn send(self) -> Result<ResponseValue<types::PhysicalDisk>, Error<types::Error>> {
            let Self { client, disk_id } = self;
            let disk_id = disk_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/disks/{}",
                client.baseurl,
                encode_path(&disk_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "physical_disk_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_lldp_neighbors`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_lldp_neighbors`]: super::ClientSystemNetworkingExt::networking_switch_port_lldp_neighbors
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortLldpNeighbors<'a> {
        client: &'a super::Client,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
        port: Result<types::Name, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> NetworkingSwitchPortLldpNeighbors<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
                port: Err("port was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `Name` for port failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/hardware/rack-switch-port/{rack_id}/{switch_location}/
        /// {port}/lldp/neighbors`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::LldpNeighborResultsPage>, Error<types::Error>> {
            let Self {
                client,
                rack_id,
                switch_location,
                port,
                limit,
                page_token,
                sort_by,
            } = self;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let port = port.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/rack-switch-port/{}/{}/{}/lldp/neighbors",
                client.baseurl,
                encode_path(&rack_id.to_string()),
                encode_path(&switch_location.to_string()),
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_lldp_neighbors",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/system/hardware/rack-switch-port/{rack_id}/{switch_location}/
        /// {port}/lldp/neighbors`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::LldpNeighbor, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::rack_list`]
    ///
    /// [`ClientSystemHardwareExt::rack_list`]: super::ClientSystemHardwareExt::rack_list
    #[derive(Debug, Clone)]
    pub struct RackList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> RackList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/racks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/racks", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "rack_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/hardware/racks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::rack_view`]
    ///
    /// [`ClientSystemHardwareExt::rack_view`]: super::ClientSystemHardwareExt::rack_view
    #[derive(Debug, Clone)]
    pub struct RackView<'a> {
        client: &'a super::Client,
        rack_id: Result<::uuid::Uuid, String>,
    }

    impl<'a> RackView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                rack_id: Err("rack_id was not initialized".to_string()),
            }
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/racks/{rack_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Rack>, Error<types::Error>> {
            let Self { client, rack_id } = self;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/racks/{}",
                client.baseurl,
                encode_path(&rack_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "rack_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_list`]
    ///
    /// [`ClientSystemHardwareExt::sled_list`]: super::ClientSystemHardwareExt::sled_list
    #[derive(Debug, Clone)]
    pub struct SledList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/sleds`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/sleds", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/hardware/sleds`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_add`]
    ///
    /// [`ClientSystemHardwareExt::sled_add`]: super::ClientSystemHardwareExt::sled_add
    #[derive(Debug, Clone)]
    pub struct SledAdd<'a> {
        client: &'a super::Client,
        body: Result<types::builder::UninitializedSledId, String>,
    }

    impl<'a> SledAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UninitializedSledId>,
            <V as std::convert::TryInto<types::UninitializedSledId>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UninitializedSledId` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::UninitializedSledId,
            ) -> types::builder::UninitializedSledId,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/hardware/sleds`
        pub async fn send(self) -> Result<ResponseValue<types::SledId>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::UninitializedSledId::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/sleds", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_view`]
    ///
    /// [`ClientSystemHardwareExt::sled_view`]: super::ClientSystemHardwareExt::sled_view
    #[derive(Debug, Clone)]
    pub struct SledView<'a> {
        client: &'a super::Client,
        sled_id: Result<::uuid::Uuid, String>,
    }

    impl<'a> SledView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                sled_id: Err("sled_id was not initialized".to_string()),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Sled>, Error<types::Error>> {
            let Self { client, sled_id } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/sleds/{}",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_physical_disk_list`]
    ///
    /// [`ClientSystemHardwareExt::sled_physical_disk_list`]: super::ClientSystemHardwareExt::sled_physical_disk_list
    #[derive(Debug, Clone)]
    pub struct SledPhysicalDiskList<'a> {
        client: &'a super::Client,
        sled_id: Result<::uuid::Uuid, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledPhysicalDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                sled_id: Err("sled_id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}/disks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                sled_id,
                limit,
                page_token,
                sort_by,
            } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/sleds/{}/disks",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_physical_disk_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/system/hardware/sleds/{sled_id}/disks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_instance_list`]
    ///
    /// [`ClientSystemHardwareExt::sled_instance_list`]: super::ClientSystemHardwareExt::sled_instance_list
    #[derive(Debug, Clone)]
    pub struct SledInstanceList<'a> {
        client: &'a super::Client,
        sled_id: Result<::uuid::Uuid, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledInstanceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                sled_id: Err("sled_id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/hardware/sleds/{sled_id}/instances`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledInstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                sled_id,
                limit,
                page_token,
                sort_by,
            } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/sleds/{}/instances",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_instance_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/system/hardware/sleds/{sled_id}/instances`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SledInstance, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_set_provision_policy`]
    ///
    /// [`ClientSystemHardwareExt::sled_set_provision_policy`]: super::ClientSystemHardwareExt::sled_set_provision_policy
    #[derive(Debug, Clone)]
    pub struct SledSetProvisionPolicy<'a> {
        client: &'a super::Client,
        sled_id: Result<::uuid::Uuid, String>,
        body: Result<types::builder::SledProvisionPolicyParams, String>,
    }

    impl<'a> SledSetProvisionPolicy<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                sled_id: Err("sled_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SledProvisionPolicyParams>,
            <V as std::convert::TryInto<types::SledProvisionPolicyParams>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SledProvisionPolicyParams` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SledProvisionPolicyParams,
            ) -> types::builder::SledProvisionPolicyParams,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to
        /// `/v1/system/hardware/sleds/{sled_id}/provision-policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledProvisionPolicyResponse>, Error<types::Error>>
        {
            let Self {
                client,
                sled_id,
                body,
            } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::SledProvisionPolicyParams::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/sleds/{}/provision-policy",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_set_provision_policy",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::sled_list_uninitialized`]
    ///
    /// [`ClientSystemHardwareExt::sled_list_uninitialized`]: super::ClientSystemHardwareExt::sled_list_uninitialized
    #[derive(Debug, Clone)]
    pub struct SledListUninitialized<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }

    impl<'a> SledListUninitialized<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/sleds-uninitialized`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UninitializedSledResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/sleds-uninitialized", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "sled_list_uninitialized",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/hardware/sleds-uninitialized`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UninitializedSled, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::networking_switch_port_list`]
    ///
    /// [`ClientSystemHardwareExt::networking_switch_port_list`]: super::ClientSystemHardwareExt::networking_switch_port_list
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
        switch_port_id: Result<Option<::uuid::Uuid>, String>,
    }

    impl<'a> NetworkingSwitchPortList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                switch_port_id: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn switch_port_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.switch_port_id = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: uuid :: Uuid` for switch_port_id failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/switch-port`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SwitchPortResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
                switch_port_id,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let switch_port_id = switch_port_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/switch-port", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new(
                    "switch_port_id",
                    &switch_port_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/hardware/switch-port`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SwitchPort, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                switch_port_id: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_lldp_config_view`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_lldp_config_view`]: super::ClientSystemNetworkingExt::networking_switch_port_lldp_config_view
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortLldpConfigView<'a> {
        client: &'a super::Client,
        port: Result<types::Name, String>,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
    }

    impl<'a> NetworkingSwitchPortLldpConfigView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port: Err("port was not initialized".to_string()),
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
            }
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `Name` for port failed".to_string());
            self
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/hardware/switch-port/{port}/lldp/config`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::LldpLinkConfig>, Error<types::Error>> {
            let Self {
                client,
                port,
                rack_id,
                switch_location,
            } = self;
            let port = port.map_err(Error::InvalidRequest)?;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/switch-port/{}/lldp/config",
                client.baseurl,
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("rack_id", &rack_id))
                .query(&progenitor_client::QueryParam::new(
                    "switch_location",
                    &switch_location,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_lldp_config_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_lldp_config_update`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_lldp_config_update`]: super::ClientSystemNetworkingExt::networking_switch_port_lldp_config_update
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortLldpConfigUpdate<'a> {
        client: &'a super::Client,
        port: Result<types::Name, String>,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
        body: Result<types::builder::LldpLinkConfig, String>,
    }

    impl<'a> NetworkingSwitchPortLldpConfigUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port: Err("port was not initialized".to_string()),
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `Name` for port failed".to_string());
            self
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::LldpLinkConfig>,
            <V as std::convert::TryInto<types::LldpLinkConfig>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `LldpLinkConfig` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::LldpLinkConfig) -> types::builder::LldpLinkConfig,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to
        /// `/v1/system/hardware/switch-port/{port}/lldp/config`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                port,
                rack_id,
                switch_location,
                body,
            } = self;
            let port = port.map_err(Error::InvalidRequest)?;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::LldpLinkConfig::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/switch-port/{}/lldp/config",
                client.baseurl,
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("rack_id", &rack_id))
                .query(&progenitor_client::QueryParam::new(
                    "switch_location",
                    &switch_location,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_lldp_config_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemHardwareExt::networking_switch_port_apply_settings`]
    ///
    /// [`ClientSystemHardwareExt::networking_switch_port_apply_settings`]: super::ClientSystemHardwareExt::networking_switch_port_apply_settings
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortApplySettings<'a> {
        client: &'a super::Client,
        port: Result<types::Name, String>,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
        body: Result<types::builder::SwitchPortApplySettings, String>,
    }

    impl<'a> NetworkingSwitchPortApplySettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port: Err("port was not initialized".to_string()),
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `Name` for port failed".to_string());
            self
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SwitchPortApplySettings>,
            <V as std::convert::TryInto<types::SwitchPortApplySettings>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SwitchPortApplySettings` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SwitchPortApplySettings,
            ) -> types::builder::SwitchPortApplySettings,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to
        /// `/v1/system/hardware/switch-port/{port}/settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                port,
                rack_id,
                switch_location,
                body,
            } = self;
            let port = port.map_err(Error::InvalidRequest)?;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::SwitchPortApplySettings::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/switch-port/{}/settings",
                client.baseurl,
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("rack_id", &rack_id))
                .query(&progenitor_client::QueryParam::new(
                    "switch_location",
                    &switch_location,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_apply_settings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemHardwareExt::networking_switch_port_clear_settings`]
    ///
    /// [`ClientSystemHardwareExt::networking_switch_port_clear_settings`]: super::ClientSystemHardwareExt::networking_switch_port_clear_settings
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortClearSettings<'a> {
        client: &'a super::Client,
        port: Result<types::Name, String>,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
    }

    impl<'a> NetworkingSwitchPortClearSettings<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port: Err("port was not initialized".to_string()),
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
            }
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `Name` for port failed".to_string());
            self
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/hardware/switch-port/{port}/settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                port,
                rack_id,
                switch_location,
            } = self;
            let port = port.map_err(Error::InvalidRequest)?;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/switch-port/{}/settings",
                client.baseurl,
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("rack_id", &rack_id))
                .query(&progenitor_client::QueryParam::new(
                    "switch_location",
                    &switch_location,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_clear_settings",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::networking_switch_port_status`]
    ///
    /// [`ClientSystemHardwareExt::networking_switch_port_status`]: super::ClientSystemHardwareExt::networking_switch_port_status
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortStatus<'a> {
        client: &'a super::Client,
        port: Result<types::Name, String>,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
    }

    impl<'a> NetworkingSwitchPortStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port: Err("port was not initialized".to_string()),
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
            }
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `Name` for port failed".to_string());
            self
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/hardware/switch-port/{port}/status`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SwitchLinkState>, Error<types::Error>> {
            let Self {
                client,
                port,
                rack_id,
                switch_location,
            } = self;
            let port = port.map_err(Error::InvalidRequest)?;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/switch-port/{}/status",
                client.baseurl,
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("rack_id", &rack_id))
                .query(&progenitor_client::QueryParam::new(
                    "switch_location",
                    &switch_location,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_status",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemHardwareExt::switch_list`]
    ///
    /// [`ClientSystemHardwareExt::switch_list`]: super::ClientSystemHardwareExt::switch_list
    #[derive(Debug, Clone)]
    pub struct SwitchList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SwitchList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/switches`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SwitchResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/switches", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "switch_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/hardware/switches`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Switch, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemHardwareExt::switch_view`]
    ///
    /// [`ClientSystemHardwareExt::switch_view`]: super::ClientSystemHardwareExt::switch_view
    #[derive(Debug, Clone)]
    pub struct SwitchView<'a> {
        client: &'a super::Client,
        switch_id: Result<::uuid::Uuid, String>,
    }

    impl<'a> SwitchView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                switch_id: Err("switch_id was not initialized".to_string()),
            }
        }

        pub fn switch_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.switch_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for switch_id failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/hardware/switches/{switch_id}`
        pub async fn send(self) -> Result<ResponseValue<types::Switch>, Error<types::Error>> {
            let Self { client, switch_id } = self;
            let switch_id = switch_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/switches/{}",
                client.baseurl,
                encode_path(&switch_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "switch_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_identity_provider_list`]
    ///
    /// [`ClientSystemSilosExt::silo_identity_provider_list`]: super::ClientSystemSilosExt::silo_identity_provider_list
    #[derive(Debug, Clone)]
    pub struct SiloIdentityProviderList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        silo: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloIdentityProviderList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/identity-providers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IdentityProviderResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                silo,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/identity-providers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_identity_provider_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/identity-providers`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IdentityProvider, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::local_idp_user_create`]
    ///
    /// [`ClientSystemSilosExt::local_idp_user_create`]: super::ClientSystemSilosExt::local_idp_user_create
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserCreate<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::builder::UserCreate, String>,
    }

    impl<'a> LocalIdpUserCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserCreate>,
            <V as std::convert::TryInto<types::UserCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UserCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::UserCreate) -> types::builder::UserCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to
        /// `/v1/system/identity-providers/local/users`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UserCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/local/users",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "local_idp_user_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::local_idp_user_delete`]
    ///
    /// [`ClientSystemSilosExt::local_idp_user_delete`]: super::ClientSystemSilosExt::local_idp_user_delete
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserDelete<'a> {
        client: &'a super::Client,
        user_id: Result<::uuid::Uuid, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> LocalIdpUserDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/identity-providers/local/users/{user_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                user_id,
                silo,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/local/users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "local_idp_user_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::local_idp_user_set_password`]
    ///
    /// [`ClientSystemSilosExt::local_idp_user_set_password`]: super::ClientSystemSilosExt::local_idp_user_set_password
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserSetPassword<'a> {
        client: &'a super::Client,
        user_id: Result<::uuid::Uuid, String>,
        silo: Result<types::NameOrId, String>,
        body: Result<types::UserPassword, String>,
    }

    impl<'a> LocalIdpUserSetPassword<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserPassword>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UserPassword` for body failed".to_string());
            self
        }

        /// Sends a `POST` request to
        /// `/v1/system/identity-providers/local/users/{user_id}/set-password`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                user_id,
                silo,
                body,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/local/users/{}/set-password",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "local_idp_user_set_password",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::saml_identity_provider_create`]
    ///
    /// [`ClientSystemSilosExt::saml_identity_provider_create`]: super::ClientSystemSilosExt::saml_identity_provider_create
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderCreate<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::builder::SamlIdentityProviderCreate, String>,
    }

    impl<'a> SamlIdentityProviderCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SamlIdentityProviderCreate>,
            <V as std::convert::TryInto<types::SamlIdentityProviderCreate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SamlIdentityProviderCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SamlIdentityProviderCreate,
            ) -> types::builder::SamlIdentityProviderCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/identity-providers/saml`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::SamlIdentityProviderCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/identity-providers/saml", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "saml_identity_provider_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::saml_identity_provider_view`]
    ///
    /// [`ClientSystemSilosExt::saml_identity_provider_view`]: super::ClientSystemSilosExt::saml_identity_provider_view
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderView<'a> {
        client: &'a super::Client,
        provider: Result<types::NameOrId, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SamlIdentityProviderView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                provider: Err("provider was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn provider<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.provider = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for provider failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/identity-providers/saml/{provider}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self {
                client,
                provider,
                silo,
            } = self;
            let provider = provider.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/saml/{}",
                client.baseurl,
                encode_path(&provider.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "saml_identity_provider_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_list`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_list`]: super::ClientSystemIpPoolsExt::ip_pool_list
    #[derive(Debug, Clone)]
    pub struct IpPoolList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> IpPoolList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/ip-pools`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/ip-pools`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPool, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_create`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_create`]: super::ClientSystemIpPoolsExt::ip_pool_create
    #[derive(Debug, Clone)]
    pub struct IpPoolCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::IpPoolCreate, String>,
    }

    impl<'a> IpPoolCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolCreate>,
            <V as std::convert::TryInto<types::IpPoolCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `IpPoolCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::IpPoolCreate) -> types::builder::IpPoolCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/ip-pools`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::IpPoolCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_view`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_view`]: super::ClientSystemIpPoolsExt::ip_pool_view
    #[derive(Debug, Clone)]
    pub struct IpPoolView<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
    }

    impl<'a> IpPoolView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/ip-pools/{pool}`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, pool } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_update`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_update`]: super::ClientSystemIpPoolsExt::ip_pool_update
    #[derive(Debug, Clone)]
    pub struct IpPoolUpdate<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::builder::IpPoolUpdate, String>,
    }

    impl<'a> IpPoolUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolUpdate>,
            <V as std::convert::TryInto<types::IpPoolUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `IpPoolUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::IpPoolUpdate) -> types::builder::IpPoolUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/ip-pools/{pool}`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::IpPoolUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_delete`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_delete`]: super::ClientSystemIpPoolsExt::ip_pool_delete
    #[derive(Debug, Clone)]
    pub struct IpPoolDelete<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
    }

    impl<'a> IpPoolDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/system/ip-pools/{pool}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_range_list`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_range_list`]: super::ClientSystemIpPoolsExt::ip_pool_range_list
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeList<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }

    impl<'a> IpPoolRangeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/ip-pools/{pool}/ranges`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                pool,
                limit,
                page_token,
            } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/ranges",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_range_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/ip-pools/{pool}/ranges`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_range_add`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_range_add`]: super::ClientSystemIpPoolsExt::ip_pool_range_add
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeAdd<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/add`
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/ranges/add",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_range_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_range_remove`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_range_remove`]: super::ClientSystemIpPoolsExt::ip_pool_range_remove
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeRemove<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/remove`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/ranges/remove",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_range_remove",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_silo_list`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_silo_list`]: super::ClientSystemIpPoolsExt::ip_pool_silo_list
    #[derive(Debug, Clone)]
    pub struct IpPoolSiloList<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> IpPoolSiloList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/ip-pools/{pool}/silos`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolSiloLinkResultsPage>, Error<types::Error>> {
            let Self {
                client,
                pool,
                limit,
                page_token,
                sort_by,
            } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/silos",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_silo_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/ip-pools/{pool}/silos`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolSiloLink, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_silo_link`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_silo_link`]: super::ClientSystemIpPoolsExt::ip_pool_silo_link
    #[derive(Debug, Clone)]
    pub struct IpPoolSiloLink<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::builder::IpPoolLinkSilo, String>,
    }

    impl<'a> IpPoolSiloLink<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolLinkSilo>,
            <V as std::convert::TryInto<types::IpPoolLinkSilo>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `IpPoolLinkSilo` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::IpPoolLinkSilo) -> types::builder::IpPoolLinkSilo,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/ip-pools/{pool}/silos`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolSiloLink>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::IpPoolLinkSilo::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/silos",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_silo_link",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_silo_update`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_silo_update`]: super::ClientSystemIpPoolsExt::ip_pool_silo_update
    #[derive(Debug, Clone)]
    pub struct IpPoolSiloUpdate<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        silo: Result<types::NameOrId, String>,
        body: Result<types::builder::IpPoolSiloUpdate, String>,
    }

    impl<'a> IpPoolSiloUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolSiloUpdate>,
            <V as std::convert::TryInto<types::IpPoolSiloUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `IpPoolSiloUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::IpPoolSiloUpdate,
            ) -> types::builder::IpPoolSiloUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/ip-pools/{pool}/silos/{silo}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolSiloLink>, Error<types::Error>> {
            let Self {
                client,
                pool,
                silo,
                body,
            } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::IpPoolSiloUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/silos/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_silo_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_silo_unlink`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_silo_unlink`]: super::ClientSystemIpPoolsExt::ip_pool_silo_unlink
    #[derive(Debug, Clone)]
    pub struct IpPoolSiloUnlink<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> IpPoolSiloUnlink<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/ip-pools/{pool}/silos/{silo}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool, silo } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/silos/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_silo_unlink",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_utilization_view`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_utilization_view`]: super::ClientSystemIpPoolsExt::ip_pool_utilization_view
    #[derive(Debug, Clone)]
    pub struct IpPoolUtilizationView<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
    }

    impl<'a> IpPoolUtilizationView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                pool: Err("pool was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/ip-pools/{pool}/utilization`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolUtilization>, Error<types::Error>> {
            let Self { client, pool } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/utilization",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_utilization_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_service_view`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_service_view`]: super::ClientSystemIpPoolsExt::ip_pool_service_view
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceView<'a> {
        client: &'a super::Client,
    }

    impl<'a> IpPoolServiceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/ip-pools-service`
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/ip-pools-service", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_service_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_service_range_list`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_service_range_list`]: super::ClientSystemIpPoolsExt::ip_pool_service_range_list
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }

    impl<'a> IpPoolServiceRangeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/ip-pools-service/ranges`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools-service/ranges", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_service_range_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/ip-pools-service/ranges`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_service_range_add`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_service_range_add`]: super::ClientSystemIpPoolsExt::ip_pool_service_range_add
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeAdd<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/system/ip-pools-service/ranges/add`
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools-service/ranges/add", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_service_range_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemIpPoolsExt::ip_pool_service_range_remove`]
    ///
    /// [`ClientSystemIpPoolsExt::ip_pool_service_range_remove`]: super::ClientSystemIpPoolsExt::ip_pool_service_range_remove
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeRemove<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        /// Sends a `POST` request to
        /// `/v1/system/ip-pools-service/ranges/remove`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools-service/ranges/remove",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "ip_pool_service_range_remove",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemMetricsExt::system_metric`]
    ///
    /// [`ClientSystemMetricsExt::system_metric`]: super::ClientSystemMetricsExt::system_metric
    #[derive(Debug, Clone)]
    pub struct SystemMetric<'a> {
        client: &'a super::Client,
        metric_name: Result<types::SystemMetricName, String>,
        end_time: Result<Option<::chrono::DateTime<::chrono::offset::Utc>>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        order: Result<Option<types::PaginationOrder>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        silo: Result<Option<types::NameOrId>, String>,
        start_time: Result<Option<::chrono::DateTime<::chrono::offset::Utc>>, String>,
    }

    impl<'a> SystemMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                metric_name: Err("metric_name was not initialized".to_string()),
                end_time: Ok(None),
                limit: Ok(None),
                order: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn metric_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemMetricName>,
        {
            self.metric_name = value
                .try_into()
                .map_err(|_| "conversion to `SystemMetricName` for metric_name failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
        {
            self.end_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: chrono :: DateTime < :: chrono :: offset :: Utc >` for end_time \
                 failed"
                    .to_string()
            });
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn order<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::PaginationOrder>,
        {
            self.order = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `PaginationOrder` for order failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::chrono::DateTime<::chrono::offset::Utc>>,
        {
            self.start_time = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: chrono :: DateTime < :: chrono :: offset :: Utc >` for \
                 start_time failed"
                    .to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/metrics/{metric_name}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                metric_name,
                end_time,
                limit,
                order,
                page_token,
                silo,
                start_time,
            } = self;
            let metric_name = metric_name.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let order = order.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/metrics/{}",
                client.baseurl,
                encode_path(&metric_name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("end_time", &end_time))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new("order", &order))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .query(&progenitor_client::QueryParam::new(
                    "start_time",
                    &start_time,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "system_metric",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/metrics/{metric_name}`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                end_time: Ok(None),
                order: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                start_time: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_address_lot_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_address_lot_list`]: super::ClientSystemNetworkingExt::networking_address_lot_list
    #[derive(Debug, Clone)]
    pub struct NetworkingAddressLotList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> NetworkingAddressLotList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/networking/address-lot`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AddressLotResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/address-lot", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_address_lot_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/networking/address-lot`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AddressLot, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_address_lot_create`]
    ///
    /// [`ClientSystemNetworkingExt::networking_address_lot_create`]: super::ClientSystemNetworkingExt::networking_address_lot_create
    #[derive(Debug, Clone)]
    pub struct NetworkingAddressLotCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::AddressLotCreate, String>,
    }

    impl<'a> NetworkingAddressLotCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AddressLotCreate>,
            <V as std::convert::TryInto<types::AddressLotCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AddressLotCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::AddressLotCreate,
            ) -> types::builder::AddressLotCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/networking/address-lot`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AddressLotCreateResponse>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::AddressLotCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/address-lot", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_address_lot_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_address_lot_delete`]
    ///
    /// [`ClientSystemNetworkingExt::networking_address_lot_delete`]: super::ClientSystemNetworkingExt::networking_address_lot_delete
    #[derive(Debug, Clone)]
    pub struct NetworkingAddressLotDelete<'a> {
        client: &'a super::Client,
        address_lot: Result<types::NameOrId, String>,
    }

    impl<'a> NetworkingAddressLotDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address_lot: Err("address_lot was not initialized".to_string()),
            }
        }

        pub fn address_lot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.address_lot = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for address_lot failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/networking/address-lot/{address_lot}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                address_lot,
            } = self;
            let address_lot = address_lot.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/address-lot/{}",
                client.baseurl,
                encode_path(&address_lot.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_address_lot_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_address_lot_block_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_address_lot_block_list`]: super::ClientSystemNetworkingExt::networking_address_lot_block_list
    #[derive(Debug, Clone)]
    pub struct NetworkingAddressLotBlockList<'a> {
        client: &'a super::Client,
        address_lot: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> NetworkingAddressLotBlockList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                address_lot: Err("address_lot was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn address_lot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.address_lot = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for address_lot failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/networking/address-lot/{address_lot}/blocks`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AddressLotBlockResultsPage>, Error<types::Error>> {
            let Self {
                client,
                address_lot,
                limit,
                page_token,
                sort_by,
            } = self;
            let address_lot = address_lot.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/address-lot/{}/blocks",
                client.baseurl,
                encode_path(&address_lot.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_address_lot_block_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/system/networking/address-lot/{address_lot}/blocks`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::AddressLotBlock, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_allow_list_view`]
    ///
    /// [`ClientSystemNetworkingExt::networking_allow_list_view`]: super::ClientSystemNetworkingExt::networking_allow_list_view
    #[derive(Debug, Clone)]
    pub struct NetworkingAllowListView<'a> {
        client: &'a super::Client,
    }

    impl<'a> NetworkingAllowListView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/networking/allow-list`
        pub async fn send(self) -> Result<ResponseValue<types::AllowList>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/networking/allow-list", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_allow_list_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_allow_list_update`]
    ///
    /// [`ClientSystemNetworkingExt::networking_allow_list_update`]: super::ClientSystemNetworkingExt::networking_allow_list_update
    #[derive(Debug, Clone)]
    pub struct NetworkingAllowListUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::AllowListUpdate, String>,
    }

    impl<'a> NetworkingAllowListUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::AllowListUpdate>,
            <V as std::convert::TryInto<types::AllowListUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `AllowListUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::AllowListUpdate) -> types::builder::AllowListUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/networking/allow-list`
        pub async fn send(self) -> Result<ResponseValue<types::AllowList>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::AllowListUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/allow-list", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_allow_list_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bfd_disable`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bfd_disable`]: super::ClientSystemNetworkingExt::networking_bfd_disable
    #[derive(Debug, Clone)]
    pub struct NetworkingBfdDisable<'a> {
        client: &'a super::Client,
        body: Result<types::builder::BfdSessionDisable, String>,
    }

    impl<'a> NetworkingBfdDisable<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BfdSessionDisable>,
            <V as std::convert::TryInto<types::BfdSessionDisable>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `BfdSessionDisable` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::BfdSessionDisable,
            ) -> types::builder::BfdSessionDisable,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/networking/bfd-disable`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::BfdSessionDisable::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bfd-disable", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bfd_disable",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bfd_enable`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bfd_enable`]: super::ClientSystemNetworkingExt::networking_bfd_enable
    #[derive(Debug, Clone)]
    pub struct NetworkingBfdEnable<'a> {
        client: &'a super::Client,
        body: Result<types::builder::BfdSessionEnable, String>,
    }

    impl<'a> NetworkingBfdEnable<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BfdSessionEnable>,
            <V as std::convert::TryInto<types::BfdSessionEnable>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `BfdSessionEnable` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::BfdSessionEnable,
            ) -> types::builder::BfdSessionEnable,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/networking/bfd-enable`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::BfdSessionEnable::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bfd-enable", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bfd_enable",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bfd_status`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bfd_status`]: super::ClientSystemNetworkingExt::networking_bfd_status
    #[derive(Debug, Clone)]
    pub struct NetworkingBfdStatus<'a> {
        client: &'a super::Client,
    }

    impl<'a> NetworkingBfdStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/networking/bfd-status`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::BfdStatus>>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/networking/bfd-status", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bfd_status",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bgp_config_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_config_list`]: super::ClientSystemNetworkingExt::networking_bgp_config_list
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpConfigList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> NetworkingBgpConfigList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/networking/bgp`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::BgpConfigResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bgp", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_config_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/networking/bgp`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::BgpConfig, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bgp_config_create`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_config_create`]: super::ClientSystemNetworkingExt::networking_bgp_config_create
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpConfigCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::BgpConfigCreate, String>,
    }

    impl<'a> NetworkingBgpConfigCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BgpConfigCreate>,
            <V as std::convert::TryInto<types::BgpConfigCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `BgpConfigCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::BgpConfigCreate) -> types::builder::BgpConfigCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/networking/bgp`
        pub async fn send(self) -> Result<ResponseValue<types::BgpConfig>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::BgpConfigCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bgp", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_config_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bgp_config_delete`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_config_delete`]: super::ClientSystemNetworkingExt::networking_bgp_config_delete
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpConfigDelete<'a> {
        client: &'a super::Client,
        name_or_id: Result<types::NameOrId, String>,
    }

    impl<'a> NetworkingBgpConfigDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                name_or_id: Err("name_or_id was not initialized".to_string()),
            }
        }

        pub fn name_or_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.name_or_id = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for name_or_id failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/system/networking/bgp`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, name_or_id } = self;
            let name_or_id = name_or_id.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bgp", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "name_or_id",
                    &name_or_id,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_config_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_bgp_announce_set_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_announce_set_list`]: super::ClientSystemNetworkingExt::networking_bgp_announce_set_list
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpAnnounceSetList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> NetworkingBgpAnnounceSetList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/networking/bgp-announce-set`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::BgpAnnounceSet>>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bgp-announce-set", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_announce_set_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_bgp_announce_set_update`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_announce_set_update`]: super::ClientSystemNetworkingExt::networking_bgp_announce_set_update
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpAnnounceSetUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::BgpAnnounceSetCreate, String>,
    }

    impl<'a> NetworkingBgpAnnounceSetUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::BgpAnnounceSetCreate>,
            <V as std::convert::TryInto<types::BgpAnnounceSetCreate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `BgpAnnounceSetCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::BgpAnnounceSetCreate,
            ) -> types::builder::BgpAnnounceSetCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/networking/bgp-announce-set`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::BgpAnnounceSet>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::BgpAnnounceSetCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bgp-announce-set", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_announce_set_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_bgp_announce_set_delete`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_announce_set_delete`]: super::ClientSystemNetworkingExt::networking_bgp_announce_set_delete
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpAnnounceSetDelete<'a> {
        client: &'a super::Client,
        announce_set: Result<types::NameOrId, String>,
    }

    impl<'a> NetworkingBgpAnnounceSetDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                announce_set: Err("announce_set was not initialized".to_string()),
            }
        }

        pub fn announce_set<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.announce_set = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for announce_set failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/networking/bgp-announce-set/{announce_set}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                announce_set,
            } = self;
            let announce_set = announce_set.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/bgp-announce-set/{}",
                client.baseurl,
                encode_path(&announce_set.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_announce_set_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_bgp_announcement_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_announcement_list`]: super::ClientSystemNetworkingExt::networking_bgp_announcement_list
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpAnnouncementList<'a> {
        client: &'a super::Client,
        announce_set: Result<types::NameOrId, String>,
    }

    impl<'a> NetworkingBgpAnnouncementList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                announce_set: Err("announce_set was not initialized".to_string()),
            }
        }

        pub fn announce_set<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.announce_set = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for announce_set failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/networking/bgp-announce-set/{announce_set}/announcement`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::BgpAnnouncement>>, Error<types::Error>>
        {
            let Self {
                client,
                announce_set,
            } = self;
            let announce_set = announce_set.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/bgp-announce-set/{}/announcement",
                client.baseurl,
                encode_path(&announce_set.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_announcement_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bgp_exported`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_exported`]: super::ClientSystemNetworkingExt::networking_bgp_exported
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpExported<'a> {
        client: &'a super::Client,
    }

    impl<'a> NetworkingBgpExported<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/networking/bgp-exported`
        pub async fn send(self) -> Result<ResponseValue<types::BgpExported>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/networking/bgp-exported", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_exported",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_bgp_message_history`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_message_history`]: super::ClientSystemNetworkingExt::networking_bgp_message_history
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpMessageHistory<'a> {
        client: &'a super::Client,
        asn: Result<u32, String>,
    }

    impl<'a> NetworkingBgpMessageHistory<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                asn: Err("asn was not initialized".to_string()),
            }
        }

        pub fn asn<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u32>,
        {
            self.asn = value
                .try_into()
                .map_err(|_| "conversion to `u32` for asn failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/networking/bgp-message-history`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::AggregateBgpMessageHistory>, Error<types::Error>> {
            let Self { client, asn } = self;
            let asn = asn.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/bgp-message-history",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("asn", &asn))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_message_history",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_bgp_imported_routes_ipv4`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_imported_routes_ipv4`]: super::ClientSystemNetworkingExt::networking_bgp_imported_routes_ipv4
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpImportedRoutesIpv4<'a> {
        client: &'a super::Client,
        asn: Result<u32, String>,
    }

    impl<'a> NetworkingBgpImportedRoutesIpv4<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                asn: Err("asn was not initialized".to_string()),
            }
        }

        pub fn asn<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u32>,
        {
            self.asn = value
                .try_into()
                .map_err(|_| "conversion to `u32` for asn failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/networking/bgp-routes-ipv4`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::BgpImportedRouteIpv4>>, Error<types::Error>>
        {
            let Self { client, asn } = self;
            let asn = asn.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/bgp-routes-ipv4", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("asn", &asn))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_imported_routes_ipv4",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemNetworkingExt::networking_bgp_status`]
    ///
    /// [`ClientSystemNetworkingExt::networking_bgp_status`]: super::ClientSystemNetworkingExt::networking_bgp_status
    #[derive(Debug, Clone)]
    pub struct NetworkingBgpStatus<'a> {
        client: &'a super::Client,
    }

    impl<'a> NetworkingBgpStatus<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/networking/bgp-status`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<::std::vec::Vec<types::BgpPeerStatus>>, Error<types::Error>>
        {
            let Self { client } = self;
            let url = format!("{}/v1/system/networking/bgp-status", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_bgp_status",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_loopback_address_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_loopback_address_list`]: super::ClientSystemNetworkingExt::networking_loopback_address_list
    #[derive(Debug, Clone)]
    pub struct NetworkingLoopbackAddressList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> NetworkingLoopbackAddressList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/networking/loopback-address`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::LoopbackAddressResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/loopback-address", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_loopback_address_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/networking/loopback-address`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::LoopbackAddress, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_loopback_address_create`]
    ///
    /// [`ClientSystemNetworkingExt::networking_loopback_address_create`]: super::ClientSystemNetworkingExt::networking_loopback_address_create
    #[derive(Debug, Clone)]
    pub struct NetworkingLoopbackAddressCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::LoopbackAddressCreate, String>,
    }

    impl<'a> NetworkingLoopbackAddressCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::LoopbackAddressCreate>,
            <V as std::convert::TryInto<types::LoopbackAddressCreate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `LoopbackAddressCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::LoopbackAddressCreate,
            ) -> types::builder::LoopbackAddressCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/networking/loopback-address`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::LoopbackAddress>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::LoopbackAddressCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/networking/loopback-address", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_loopback_address_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_loopback_address_delete`]
    ///
    /// [`ClientSystemNetworkingExt::networking_loopback_address_delete`]: super::ClientSystemNetworkingExt::networking_loopback_address_delete
    #[derive(Debug, Clone)]
    pub struct NetworkingLoopbackAddressDelete<'a> {
        client: &'a super::Client,
        rack_id: Result<::uuid::Uuid, String>,
        switch_location: Result<types::Name, String>,
        address: Result<::std::net::IpAddr, String>,
        subnet_mask: Result<u8, String>,
    }

    impl<'a> NetworkingLoopbackAddressDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                rack_id: Err("rack_id was not initialized".to_string()),
                switch_location: Err("switch_location was not initialized".to_string()),
                address: Err("address was not initialized".to_string()),
                subnet_mask: Err("subnet_mask was not initialized".to_string()),
            }
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        pub fn switch_location<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.switch_location = value
                .try_into()
                .map_err(|_| "conversion to `Name` for switch_location failed".to_string());
            self
        }

        pub fn address<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::net::IpAddr>,
        {
            self.address = value.try_into().map_err(|_| {
                "conversion to `:: std :: net :: IpAddr` for address failed".to_string()
            });
            self
        }

        pub fn subnet_mask<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u8>,
        {
            self.subnet_mask = value
                .try_into()
                .map_err(|_| "conversion to `u8` for subnet_mask failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/networking/loopback-address/{rack_id}/{switch_location}/
        /// {address}/{subnet_mask}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                rack_id,
                switch_location,
                address,
                subnet_mask,
            } = self;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let switch_location = switch_location.map_err(Error::InvalidRequest)?;
            let address = address.map_err(Error::InvalidRequest)?;
            let subnet_mask = subnet_mask.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/loopback-address/{}/{}/{}/{}",
                client.baseurl,
                encode_path(&rack_id.to_string()),
                encode_path(&switch_location.to_string()),
                encode_path(&address.to_string()),
                encode_path(&subnet_mask.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_loopback_address_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_list`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_list`]: super::ClientSystemNetworkingExt::networking_switch_port_settings_list
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortSettingsList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        port_settings: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> NetworkingSwitchPortSettingsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                port_settings: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn port_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.port_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for port_settings failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/networking/switch-port-settings`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SwitchPortSettingsResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                port_settings,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let port_settings = port_settings.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/switch-port-settings",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new(
                    "port_settings",
                    &port_settings,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_settings_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/system/networking/switch-port-settings`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SwitchPortSettings, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                port_settings: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_create`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_create`]: super::ClientSystemNetworkingExt::networking_switch_port_settings_create
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortSettingsCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SwitchPortSettingsCreate, String>,
    }

    impl<'a> NetworkingSwitchPortSettingsCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SwitchPortSettingsCreate>,
            <V as std::convert::TryInto<types::SwitchPortSettingsCreate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SwitchPortSettingsCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SwitchPortSettingsCreate,
            ) -> types::builder::SwitchPortSettingsCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to
        /// `/v1/system/networking/switch-port-settings`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SwitchPortSettingsView>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| {
                    types::SwitchPortSettingsCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/switch-port-settings",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_settings_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_delete`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_delete`]: super::ClientSystemNetworkingExt::networking_switch_port_settings_delete
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortSettingsDelete<'a> {
        client: &'a super::Client,
        port_settings: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> NetworkingSwitchPortSettingsDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port_settings: Ok(None),
            }
        }

        pub fn port_settings<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.port_settings = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for port_settings failed".to_string());
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/system/networking/switch-port-settings`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                port_settings,
            } = self;
            let port_settings = port_settings.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/switch-port-settings",
                client.baseurl,
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new(
                    "port_settings",
                    &port_settings,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_settings_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_view`]
    ///
    /// [`ClientSystemNetworkingExt::networking_switch_port_settings_view`]: super::ClientSystemNetworkingExt::networking_switch_port_settings_view
    #[derive(Debug, Clone)]
    pub struct NetworkingSwitchPortSettingsView<'a> {
        client: &'a super::Client,
        port: Result<types::NameOrId, String>,
    }

    impl<'a> NetworkingSwitchPortSettingsView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                port: Err("port was not initialized".to_string()),
            }
        }

        pub fn port<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.port = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for port failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/system/networking/switch-port-settings/{port}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SwitchPortSettingsView>, Error<types::Error>> {
            let Self { client, port } = self;
            let port = port.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/networking/switch-port-settings/{}",
                client.baseurl,
                encode_path(&port.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "networking_switch_port_settings_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientPolicyExt::system_policy_view`]
    ///
    /// [`ClientPolicyExt::system_policy_view`]: super::ClientPolicyExt::system_policy_view
    #[derive(Debug, Clone)]
    pub struct SystemPolicyView<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/policy", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "system_policy_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientPolicyExt::system_policy_update`]
    ///
    /// [`ClientPolicyExt::system_policy_update`]: super::ClientPolicyExt::system_policy_update
    #[derive(Debug, Clone)]
    pub struct SystemPolicyUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::FleetRolePolicy, String>,
    }

    impl<'a> SystemPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FleetRolePolicy>,
            <V as std::convert::TryInto<types::FleetRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `FleetRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::FleetRolePolicy) -> types::builder::FleetRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::FleetRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/policy", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "system_policy_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientRolesExt::role_list`]
    ///
    /// [`ClientRolesExt::role_list`]: super::ClientRolesExt::role_list
    #[derive(Debug, Clone)]
    pub struct RoleList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }

    impl<'a> RoleList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/roles`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/roles", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "role_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/roles`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Role, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientRolesExt::role_view`]
    ///
    /// [`ClientRolesExt::role_view`]: super::ClientRolesExt::role_view
    #[derive(Debug, Clone)]
    pub struct RoleView<'a> {
        client: &'a super::Client,
        role_name: Result<::std::string::String, String>,
    }

    impl<'a> RoleView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                role_name: Err("role_name was not initialized".to_string()),
            }
        }

        pub fn role_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.role_name = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for role_name failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/roles/{role_name}`
        pub async fn send(self) -> Result<ResponseValue<types::Role>, Error<types::Error>> {
            let Self { client, role_name } = self;
            let role_name = role_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/roles/{}",
                client.baseurl,
                encode_path(&role_name.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "role_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::system_quotas_list`]
    ///
    /// [`ClientSystemSilosExt::system_quotas_list`]: super::ClientSystemSilosExt::system_quotas_list
    #[derive(Debug, Clone)]
    pub struct SystemQuotasList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SystemQuotasList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/silo-quotas`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloQuotasResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/silo-quotas", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "system_quotas_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/silo-quotas`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SiloQuotas, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_list`]
    ///
    /// [`ClientSystemSilosExt::silo_list`]: super::ClientSystemSilosExt::silo_list
    #[derive(Debug, Clone)]
    pub struct SiloList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/silos`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/silos", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/silos`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_create`]
    ///
    /// [`ClientSystemSilosExt::silo_create`]: super::ClientSystemSilosExt::silo_create
    #[derive(Debug, Clone)]
    pub struct SiloCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SiloCreate, String>,
    }

    impl<'a> SiloCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloCreate>,
            <V as std::convert::TryInto<types::SiloCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SiloCreate) -> types::builder::SiloCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/silos`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SiloCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/silos", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_view`]
    ///
    /// [`ClientSystemSilosExt::silo_view`]: super::ClientSystemSilosExt::silo_view
    #[derive(Debug, Clone)]
    pub struct SiloView<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/silos/{silo}`
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_delete`]
    ///
    /// [`ClientSystemSilosExt::silo_delete`]: super::ClientSystemSilosExt::silo_delete
    #[derive(Debug, Clone)]
    pub struct SiloDelete<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/system/silos/{silo}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_ip_pool_list`]
    ///
    /// [`ClientSystemSilosExt::silo_ip_pool_list`]: super::ClientSystemSilosExt::silo_ip_pool_list
    #[derive(Debug, Clone)]
    pub struct SiloIpPoolList<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloIpPoolList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/silos/{silo}/ip-pools`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloIpPoolResultsPage>, Error<types::Error>> {
            let Self {
                client,
                silo,
                limit,
                page_token,
                sort_by,
            } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/ip-pools",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_ip_pool_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/silos/{silo}/ip-pools`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SiloIpPool, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_policy_view`]
    ///
    /// [`ClientSystemSilosExt::silo_policy_view`]: super::ClientSystemSilosExt::silo_policy_view
    #[derive(Debug, Clone)]
    pub struct SiloPolicyView<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/silos/{silo}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_policy_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_policy_update`]
    ///
    /// [`ClientSystemSilosExt::silo_policy_update`]: super::ClientSystemSilosExt::silo_policy_update
    #[derive(Debug, Clone)]
    pub struct SiloPolicyUpdate<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::builder::SiloRolePolicy, String>,
    }

    impl<'a> SiloPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
            <V as std::convert::TryInto<types::SiloRolePolicy>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloRolePolicy` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::SiloRolePolicy) -> types::builder::SiloRolePolicy,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/silos/{silo}/policy`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SiloRolePolicy::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_policy_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_quotas_view`]
    ///
    /// [`ClientSystemSilosExt::silo_quotas_view`]: super::ClientSystemSilosExt::silo_quotas_view
    #[derive(Debug, Clone)]
    pub struct SiloQuotasView<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloQuotasView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/silos/{silo}/quotas`
        pub async fn send(self) -> Result<ResponseValue<types::SiloQuotas>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/quotas",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_quotas_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_quotas_update`]
    ///
    /// [`ClientSystemSilosExt::silo_quotas_update`]: super::ClientSystemSilosExt::silo_quotas_update
    #[derive(Debug, Clone)]
    pub struct SiloQuotasUpdate<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::builder::SiloQuotasUpdate, String>,
    }

    impl<'a> SiloQuotasUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloQuotasUpdate>,
            <V as std::convert::TryInto<types::SiloQuotasUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `SiloQuotasUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SiloQuotasUpdate,
            ) -> types::builder::SiloQuotasUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/silos/{silo}/quotas`
        pub async fn send(self) -> Result<ResponseValue<types::SiloQuotas>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::SiloQuotasUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/quotas",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_quotas_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemMetricsExt::system_timeseries_query`]
    ///
    /// [`ClientSystemMetricsExt::system_timeseries_query`]: super::ClientSystemMetricsExt::system_timeseries_query
    #[derive(Debug, Clone)]
    pub struct SystemTimeseriesQuery<'a> {
        client: &'a super::Client,
        body: Result<types::builder::TimeseriesQuery, String>,
    }

    impl<'a> SystemTimeseriesQuery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TimeseriesQuery>,
            <V as std::convert::TryInto<types::TimeseriesQuery>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TimeseriesQuery` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::TimeseriesQuery) -> types::builder::TimeseriesQuery,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/system/timeseries/query`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OxqlQueryResult>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::TimeseriesQuery::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/timeseries/query", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "system_timeseries_query",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemMetricsExt::system_timeseries_schema_list`]
    ///
    /// [`ClientSystemMetricsExt::system_timeseries_schema_list`]: super::ClientSystemMetricsExt::system_timeseries_schema_list
    #[derive(Debug, Clone)]
    pub struct SystemTimeseriesSchemaList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }

    impl<'a> SystemTimeseriesSchemaList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/system/timeseries/schemas`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TimeseriesSchemaResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/timeseries/schemas", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "system_timeseries_schema_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/timeseries/schemas`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::TimeseriesSchema, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientHiddenExt::target_release_view`]
    ///
    /// [`ClientHiddenExt::target_release_view`]: super::ClientHiddenExt::target_release_view
    #[derive(Debug, Clone)]
    pub struct TargetReleaseView<'a> {
        client: &'a super::Client,
    }

    impl<'a> TargetReleaseView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/system/update/target-release`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TargetRelease>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/target-release", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "target_release_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::target_release_update`]
    ///
    /// [`ClientHiddenExt::target_release_update`]: super::ClientHiddenExt::target_release_update
    #[derive(Debug, Clone)]
    pub struct TargetReleaseUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::SetTargetReleaseParams, String>,
    }

    impl<'a> TargetReleaseUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SetTargetReleaseParams>,
            <V as std::convert::TryInto<types::SetTargetReleaseParams>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `SetTargetReleaseParams` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::SetTargetReleaseParams,
            ) -> types::builder::SetTargetReleaseParams,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/system/update/target-release`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TargetRelease>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::SetTargetReleaseParams::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/target-release", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "target_release_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_user_list`]
    ///
    /// [`ClientSystemSilosExt::silo_user_list`]: super::ClientSystemSilosExt::silo_user_list
    #[derive(Debug, Clone)]
    pub struct SiloUserList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        silo: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SiloUserList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/users`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                silo,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_user_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/users`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_user_view`]
    ///
    /// [`ClientSystemSilosExt::silo_user_view`]: super::ClientSystemSilosExt::silo_user_view
    #[derive(Debug, Clone)]
    pub struct SiloUserView<'a> {
        client: &'a super::Client,
        user_id: Result<::uuid::Uuid, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloUserView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user_id: Err("user_id was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/users/{user_id}`
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self {
                client,
                user_id,
                silo,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("silo", &silo))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_user_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::user_builtin_list`]
    ///
    /// [`ClientSystemSilosExt::user_builtin_list`]: super::ClientSystemSilosExt::user_builtin_list
    #[derive(Debug, Clone)]
    pub struct UserBuiltinList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> UserBuiltinList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/users-builtin`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserBuiltinResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/users-builtin", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "user_builtin_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/users-builtin`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UserBuiltin, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::user_builtin_view`]
    ///
    /// [`ClientSystemSilosExt::user_builtin_view`]: super::ClientSystemSilosExt::user_builtin_view
    #[derive(Debug, Clone)]
    pub struct UserBuiltinView<'a> {
        client: &'a super::Client,
        user: Result<types::NameOrId, String>,
    }

    impl<'a> UserBuiltinView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                user: Err("user was not initialized".to_string()),
            }
        }

        pub fn user<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.user = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for user failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/users-builtin/{user}`
        pub async fn send(self) -> Result<ResponseValue<types::UserBuiltin>, Error<types::Error>> {
            let Self { client, user } = self;
            let user = user.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/users-builtin/{}",
                client.baseurl,
                encode_path(&user.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "user_builtin_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_utilization_list`]
    ///
    /// [`ClientSystemSilosExt::silo_utilization_list`]: super::ClientSystemSilosExt::silo_utilization_list
    #[derive(Debug, Clone)]
    pub struct SiloUtilizationList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloUtilizationList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/utilization/silos`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloUtilizationResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/utilization/silos", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_utilization_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/system/utilization/silos`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SiloUtilization, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemSilosExt::silo_utilization_view`]
    ///
    /// [`ClientSystemSilosExt::silo_utilization_view`]: super::ClientSystemSilosExt::silo_utilization_view
    #[derive(Debug, Clone)]
    pub struct SiloUtilizationView<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloUtilizationView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/system/utilization/silos/{silo}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloUtilization>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/utilization/silos/{}",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "silo_utilization_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientHiddenExt::timeseries_query`]
    ///
    /// [`ClientHiddenExt::timeseries_query`]: super::ClientHiddenExt::timeseries_query
    #[derive(Debug, Clone)]
    pub struct TimeseriesQuery<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::TimeseriesQuery, String>,
    }

    impl<'a> TimeseriesQuery<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TimeseriesQuery>,
            <V as std::convert::TryInto<types::TimeseriesQuery>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `TimeseriesQuery` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::TimeseriesQuery) -> types::builder::TimeseriesQuery,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/timeseries/query`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OxqlQueryResult>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::TimeseriesQuery::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/timeseries/query", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "timeseries_query",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSilosExt::user_list`]
    ///
    /// [`ClientSilosExt::user_list`]: super::ClientSilosExt::user_list
    #[derive(Debug, Clone)]
    pub struct UserList<'a> {
        client: &'a super::Client,
        group: Result<Option<::uuid::Uuid>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> UserList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                group: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.group = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `:: uuid :: Uuid` for group failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/users`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                group,
                limit,
                page_token,
                sort_by,
            } = self;
            let group = group.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/users", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("group", &group))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "user_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/users`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                group: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSilosExt::utilization_view`]
    ///
    /// [`ClientSilosExt::utilization_view`]: super::ClientSilosExt::utilization_view
    #[derive(Debug, Clone)]
    pub struct UtilizationView<'a> {
        client: &'a super::Client,
    }

    impl<'a> UtilizationView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }

        /// Sends a `GET` request to `/v1/utilization`
        pub async fn send(self) -> Result<ResponseValue<types::Utilization>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/utilization", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "utilization_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_firewall_rules_view`]
    ///
    /// [`ClientVpcsExt::vpc_firewall_rules_view`]: super::ClientVpcsExt::vpc_firewall_rules_view
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesView<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
    }

    impl<'a> VpcFirewallRulesView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-firewall-rules`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                project,
                vpc,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-firewall-rules", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_firewall_rules_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_firewall_rules_update`]
    ///
    /// [`ClientVpcsExt::vpc_firewall_rules_update`]: super::ClientVpcsExt::vpc_firewall_rules_update
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesUpdate<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::builder::VpcFirewallRuleUpdateParams, String>,
    }

    impl<'a> VpcFirewallRulesUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcFirewallRuleUpdateParams>,
            <V as std::convert::TryInto<types::VpcFirewallRuleUpdateParams>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `VpcFirewallRuleUpdateParams` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::VpcFirewallRuleUpdateParams,
            ) -> types::builder::VpcFirewallRuleUpdateParams,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/vpc-firewall-rules`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                project,
                vpc,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::VpcFirewallRuleUpdateParams::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-firewall-rules", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_firewall_rules_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_route_list`]
    ///
    /// [`ClientVpcsExt::vpc_router_route_list`]: super::ClientVpcsExt::vpc_router_route_list
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterRouteList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                router: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-router-routes`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                router,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-router-routes", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("router", &router))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_route_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/vpc-router-routes`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                router: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_route_create`]
    ///
    /// [`ClientVpcsExt::vpc_router_route_create`]: super::ClientVpcsExt::vpc_router_route_create
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteCreate<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<types::NameOrId, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::RouterRouteCreate, String>,
    }

    impl<'a> VpcRouterRouteCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                router: Err("router was not initialized".to_string()),
                vpc: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteCreate>,
            <V as std::convert::TryInto<types::RouterRouteCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `RouterRouteCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RouterRouteCreate,
            ) -> types::builder::RouterRouteCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/vpc-router-routes`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                project,
                router,
                vpc,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::RouterRouteCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-router-routes", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("router", &router))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_route_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_route_view`]
    ///
    /// [`ClientVpcsExt::vpc_router_route_view`]: super::ClientVpcsExt::vpc_router_route_view
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteView<'a> {
        client: &'a super::Client,
        route: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterRouteView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                route: Err("route was not initialized".to_string()),
                project: Ok(None),
                router: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn route<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.route = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for route failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-router-routes/{route}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                route,
                project,
                router,
                vpc,
            } = self;
            let route = route.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&route.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("router", &router))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_route_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_route_update`]
    ///
    /// [`ClientVpcsExt::vpc_router_route_update`]: super::ClientVpcsExt::vpc_router_route_update
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteUpdate<'a> {
        client: &'a super::Client,
        route: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::RouterRouteUpdate, String>,
    }

    impl<'a> VpcRouterRouteUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                route: Err("route was not initialized".to_string()),
                project: Ok(None),
                router: Ok(None),
                vpc: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn route<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.route = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for route failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteUpdate>,
            <V as std::convert::TryInto<types::RouterRouteUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `RouterRouteUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::RouterRouteUpdate,
            ) -> types::builder::RouterRouteUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/vpc-router-routes/{route}`
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                route,
                project,
                router,
                vpc,
                body,
            } = self;
            let route = route.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::RouterRouteUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&route.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("router", &router))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_route_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_route_delete`]
    ///
    /// [`ClientVpcsExt::vpc_router_route_delete`]: super::ClientVpcsExt::vpc_router_route_delete
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteDelete<'a> {
        client: &'a super::Client,
        route: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterRouteDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                route: Err("route was not initialized".to_string()),
                project: Ok(None),
                router: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn route<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.route = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for route failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/vpc-router-routes/{route}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                route,
                project,
                router,
                vpc,
            } = self;
            let route = route.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&route.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("router", &router))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_route_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_list`]
    ///
    /// [`ClientVpcsExt::vpc_router_list`]: super::ClientVpcsExt::vpc_router_list
    #[derive(Debug, Clone)]
    pub struct VpcRouterList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-routers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-routers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/vpc-routers`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_create`]
    ///
    /// [`ClientVpcsExt::vpc_router_create`]: super::ClientVpcsExt::vpc_router_create
    #[derive(Debug, Clone)]
    pub struct VpcRouterCreate<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::builder::VpcRouterCreate, String>,
    }

    impl<'a> VpcRouterCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterCreate>,
            <V as std::convert::TryInto<types::VpcRouterCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcRouterCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcRouterCreate) -> types::builder::VpcRouterCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/vpc-routers`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                project,
                vpc,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcRouterCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-routers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_view`]
    ///
    /// [`ClientVpcsExt::vpc_router_view`]: super::ClientVpcsExt::vpc_router_view
    #[derive(Debug, Clone)]
    pub struct VpcRouterView<'a> {
        client: &'a super::Client,
        router: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                router: Err("router was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-routers/{router}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                router,
                project,
                vpc,
            } = self;
            let router = router.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-routers/{}",
                client.baseurl,
                encode_path(&router.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_update`]
    ///
    /// [`ClientVpcsExt::vpc_router_update`]: super::ClientVpcsExt::vpc_router_update
    #[derive(Debug, Clone)]
    pub struct VpcRouterUpdate<'a> {
        client: &'a super::Client,
        router: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::VpcRouterUpdate, String>,
    }

    impl<'a> VpcRouterUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                router: Err("router was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterUpdate>,
            <V as std::convert::TryInto<types::VpcRouterUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcRouterUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcRouterUpdate) -> types::builder::VpcRouterUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/vpc-routers/{router}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                router,
                project,
                vpc,
                body,
            } = self;
            let router = router.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcRouterUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-routers/{}",
                client.baseurl,
                encode_path(&router.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_router_delete`]
    ///
    /// [`ClientVpcsExt::vpc_router_delete`]: super::ClientVpcsExt::vpc_router_delete
    #[derive(Debug, Clone)]
    pub struct VpcRouterDelete<'a> {
        client: &'a super::Client,
        router: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                router: Err("router was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/vpc-routers/{router}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                router,
                project,
                vpc,
            } = self;
            let router = router.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-routers/{}",
                client.baseurl,
                encode_path(&router.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_router_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_subnet_list`]
    ///
    /// [`ClientVpcsExt::vpc_subnet_list`]: super::ClientVpcsExt::vpc_subnet_list
    #[derive(Debug, Clone)]
    pub struct VpcSubnetList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-subnets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-subnets", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_subnet_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/vpc-subnets`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_subnet_create`]
    ///
    /// [`ClientVpcsExt::vpc_subnet_create`]: super::ClientVpcsExt::vpc_subnet_create
    #[derive(Debug, Clone)]
    pub struct VpcSubnetCreate<'a> {
        client: &'a super::Client,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::builder::VpcSubnetCreate, String>,
    }

    impl<'a> VpcSubnetCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetCreate>,
            <V as std::convert::TryInto<types::VpcSubnetCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcSubnetCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcSubnetCreate) -> types::builder::VpcSubnetCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/vpc-subnets`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                project,
                vpc,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcSubnetCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-subnets", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_subnet_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_subnet_view`]
    ///
    /// [`ClientVpcsExt::vpc_subnet_view`]: super::ClientVpcsExt::vpc_subnet_view
    #[derive(Debug, Clone)]
    pub struct VpcSubnetView<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subnet: Err("subnet was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpc-subnets/{subnet}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                subnet,
                project,
                vpc,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_subnet_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_subnet_update`]
    ///
    /// [`ClientVpcsExt::vpc_subnet_update`]: super::ClientVpcsExt::vpc_subnet_update
    #[derive(Debug, Clone)]
    pub struct VpcSubnetUpdate<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::VpcSubnetUpdate, String>,
    }

    impl<'a> VpcSubnetUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subnet: Err("subnet was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetUpdate>,
            <V as std::convert::TryInto<types::VpcSubnetUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcSubnetUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcSubnetUpdate) -> types::builder::VpcSubnetUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/vpc-subnets/{subnet}`
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                subnet,
                project,
                vpc,
                body,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcSubnetUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_subnet_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_subnet_delete`]
    ///
    /// [`ClientVpcsExt::vpc_subnet_delete`]: super::ClientVpcsExt::vpc_subnet_delete
    #[derive(Debug, Clone)]
    pub struct VpcSubnetDelete<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subnet: Err("subnet was not initialized".to_string()),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/vpc-subnets/{subnet}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                subnet,
                project,
                vpc,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_subnet_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_subnet_list_network_interfaces`]
    ///
    /// [`ClientVpcsExt::vpc_subnet_list_network_interfaces`]: super::ClientVpcsExt::vpc_subnet_list_network_interfaces
    #[derive(Debug, Clone)]
    pub struct VpcSubnetListNetworkInterfaces<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetListNetworkInterfaces<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                subnet: Err("subnet was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        /// Sends a `GET` request to
        /// `/v1/vpc-subnets/{subnet}/network-interfaces`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceNetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                subnet,
                limit,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}/network-interfaces",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .query(&progenitor_client::QueryParam::new("vpc", &vpc))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_subnet_list_network_interfaces",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to
        /// `/v1/vpc-subnets/{subnet}/network-interfaces`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::InstanceNetworkInterface, Error<types::Error>>>
               + Unpin
               + 'a {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_list`]
    ///
    /// [`ClientVpcsExt::vpc_list`]: super::ClientVpcsExt::vpc_list
    #[derive(Debug, Clone)]
    pub struct VpcList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> VpcList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpcs`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpcs", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("project", &project))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/vpcs`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_create`]
    ///
    /// [`ClientVpcsExt::vpc_create`]: super::ClientVpcsExt::vpc_create
    #[derive(Debug, Clone)]
    pub struct VpcCreate<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        body: Result<types::builder::VpcCreate, String>,
    }

    impl<'a> VpcCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                project: Err("project was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcCreate>,
            <V as std::convert::TryInto<types::VpcCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcCreate) -> types::builder::VpcCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/vpcs`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                project,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpcs", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_view`]
    ///
    /// [`ClientVpcsExt::vpc_view`]: super::ClientVpcsExt::vpc_view
    #[derive(Debug, Clone)]
    pub struct VpcView<'a> {
        client: &'a super::Client,
        vpc: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                vpc: Err("vpc was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/vpcs/{vpc}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                vpc,
                project,
            } = self;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpcs/{}",
                client.baseurl,
                encode_path(&vpc.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_update`]
    ///
    /// [`ClientVpcsExt::vpc_update`]: super::ClientVpcsExt::vpc_update
    #[derive(Debug, Clone)]
    pub struct VpcUpdate<'a> {
        client: &'a super::Client,
        vpc: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::builder::VpcUpdate, String>,
    }

    impl<'a> VpcUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                vpc: Err("vpc was not initialized".to_string()),
                project: Ok(None),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcUpdate>,
            <V as std::convert::TryInto<types::VpcUpdate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `VpcUpdate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::VpcUpdate) -> types::builder::VpcUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/vpcs/{vpc}`
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                vpc,
                project,
                body,
            } = self;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::VpcUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpcs/{}",
                client.baseurl,
                encode_path(&vpc.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientVpcsExt::vpc_delete`]
    ///
    /// [`ClientVpcsExt::vpc_delete`]: super::ClientVpcsExt::vpc_delete
    #[derive(Debug, Clone)]
    pub struct VpcDelete<'a> {
        client: &'a super::Client,
        vpc: Result<types::NameOrId, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                vpc: Err("vpc was not initialized".to_string()),
                project: Ok(None),
            }
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/vpcs/{vpc}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                vpc,
                project,
            } = self;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpcs/{}",
                client.baseurl,
                encode_path(&vpc.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("project", &project))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "vpc_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_delivery_list`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_delivery_list`]: super::ClientSystemWebhooksExt::webhook_delivery_list
    #[derive(Debug, Clone)]
    pub struct WebhookDeliveryList<'a> {
        client: &'a super::Client,
        delivered: Result<Option<bool>, String>,
        failed: Result<Option<bool>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        pending: Result<Option<bool>, String>,
        receiver: Result<types::NameOrId, String>,
        sort_by: Result<Option<types::TimeAndIdSortMode>, String>,
    }

    impl<'a> WebhookDeliveryList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                delivered: Ok(None),
                failed: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                pending: Ok(None),
                receiver: Err("receiver was not initialized".to_string()),
                sort_by: Ok(None),
            }
        }

        pub fn delivered<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.delivered = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for delivered failed".to_string());
            self
        }

        pub fn failed<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.failed = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for failed failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn pending<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.pending = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for pending failed".to_string());
            self
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::TimeAndIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `TimeAndIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/webhooks/deliveries`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookDeliveryResultsPage>, Error<types::Error>> {
            let Self {
                client,
                delivered,
                failed,
                limit,
                page_token,
                pending,
                receiver,
                sort_by,
            } = self;
            let delivered = delivered.map_err(Error::InvalidRequest)?;
            let failed = failed.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let pending = pending.map_err(Error::InvalidRequest)?;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/webhooks/deliveries", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("delivered", &delivered))
                .query(&progenitor_client::QueryParam::new("failed", &failed))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("pending", &pending))
                .query(&progenitor_client::QueryParam::new("receiver", &receiver))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_delivery_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_delivery_resend`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_delivery_resend`]: super::ClientSystemWebhooksExt::webhook_delivery_resend
    #[derive(Debug, Clone)]
    pub struct WebhookDeliveryResend<'a> {
        client: &'a super::Client,
        event_id: Result<::uuid::Uuid, String>,
        receiver: Result<types::NameOrId, String>,
    }

    impl<'a> WebhookDeliveryResend<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                event_id: Err("event_id was not initialized".to_string()),
                receiver: Err("receiver was not initialized".to_string()),
            }
        }

        pub fn event_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.event_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for event_id failed".to_string());
            self
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        /// Sends a `POST` request to
        /// `/v1/webhooks/deliveries/{event_id}/resend`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookDeliveryId>, Error<types::Error>> {
            let Self {
                client,
                event_id,
                receiver,
            } = self;
            let event_id = event_id.map_err(Error::InvalidRequest)?;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/deliveries/{}/resend",
                client.baseurl,
                encode_path(&event_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("receiver", &receiver))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_delivery_resend",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_event_class_list`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_event_class_list`]: super::ClientSystemWebhooksExt::webhook_event_class_list
    #[derive(Debug, Clone)]
    pub struct WebhookEventClassList<'a> {
        client: &'a super::Client,
        filter: Result<Option<types::WebhookSubscription>, String>,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
    }

    impl<'a> WebhookEventClassList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                filter: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn filter<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookSubscription>,
        {
            self.filter = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `WebhookSubscription` for filter failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        /// Sends a `GET` request to `/v1/webhooks/event-classes`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::EventClassResultsPage>, Error<types::Error>> {
            let Self {
                client,
                filter,
                limit,
                page_token,
            } = self;
            let filter = filter.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/webhooks/event-classes", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("filter", &filter))
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_event_class_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/webhooks/event-classes`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::EventClass, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                filter: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_receiver_list`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_list`]: super::ClientSystemWebhooksExt::webhook_receiver_list
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverList<'a> {
        client: &'a super::Client,
        limit: Result<Option<::std::num::NonZeroU32>, String>,
        page_token: Result<Option<::std::string::String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> WebhookReceiverList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.page_token = value.try_into().map(Some).map_err(|_| {
                "conversion to `:: std :: string :: String` for page_token failed".to_string()
            });
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/webhooks/receivers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookReceiverResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/webhooks/receivers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("limit", &limit))
                .query(&progenitor_client::QueryParam::new(
                    "page_token",
                    &page_token,
                ))
                .query(&progenitor_client::QueryParam::new("sort_by", &sort_by))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        /// Streams `GET` requests to `/v1/webhooks/receivers`
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::WebhookReceiver, Error<types::Error>>> + Unpin + 'a
        {
            use ::futures::StreamExt;
            use ::futures::TryFutureExt;
            use ::futures::TryStreamExt;
            let next = Self {
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items).map(Ok);
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items).map(Ok),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_receiver_create`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_create`]: super::ClientSystemWebhooksExt::webhook_receiver_create
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverCreate<'a> {
        client: &'a super::Client,
        body: Result<types::builder::WebhookCreate, String>,
    }

    impl<'a> WebhookReceiverCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookCreate>,
            <V as std::convert::TryInto<types::WebhookCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `WebhookCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(types::builder::WebhookCreate) -> types::builder::WebhookCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/webhooks/receivers`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookReceiver>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::WebhookCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/webhooks/receivers", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_create",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_receiver_view`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_view`]: super::ClientSystemWebhooksExt::webhook_receiver_view
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverView<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
    }

    impl<'a> WebhookReceiverView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/webhooks/receivers/{receiver}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookReceiver>, Error<types::Error>> {
            let Self { client, receiver } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/receivers/{}",
                client.baseurl,
                encode_path(&receiver.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_view",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_receiver_update`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_update`]: super::ClientSystemWebhooksExt::webhook_receiver_update
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverUpdate<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
        body: Result<types::builder::WebhookReceiverUpdate, String>,
    }

    impl<'a> WebhookReceiverUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookReceiverUpdate>,
            <V as std::convert::TryInto<types::WebhookReceiverUpdate>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `WebhookReceiverUpdate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WebhookReceiverUpdate,
            ) -> types::builder::WebhookReceiverUpdate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `PUT` request to `/v1/webhooks/receivers/{receiver}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                receiver,
                body,
            } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::WebhookReceiverUpdate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/receivers/{}",
                client.baseurl,
                encode_path(&receiver.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_update",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_receiver_delete`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_delete`]: super::ClientSystemWebhooksExt::webhook_receiver_delete
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverDelete<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
    }

    impl<'a> WebhookReceiverDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/webhooks/receivers/{receiver}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, receiver } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/receivers/{}",
                client.baseurl,
                encode_path(&receiver.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_receiver_probe`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_probe`]: super::ClientSystemWebhooksExt::webhook_receiver_probe
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverProbe<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
        resend: Result<Option<bool>, String>,
    }

    impl<'a> WebhookReceiverProbe<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
                resend: Ok(None),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        pub fn resend<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<bool>,
        {
            self.resend = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `bool` for resend failed".to_string());
            self
        }

        /// Sends a `POST` request to `/v1/webhooks/receivers/{receiver}/probe`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookProbeResult>, Error<types::Error>> {
            let Self {
                client,
                receiver,
                resend,
            } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let resend = resend.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/receivers/{}/probe",
                client.baseurl,
                encode_path(&receiver.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("resend", &resend))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_probe",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemWebhooksExt::webhook_receiver_subscription_add`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_subscription_add`]: super::ClientSystemWebhooksExt::webhook_receiver_subscription_add
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverSubscriptionAdd<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
        body: Result<types::builder::WebhookSubscriptionCreate, String>,
    }

    impl<'a> WebhookReceiverSubscriptionAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookSubscriptionCreate>,
            <V as std::convert::TryInto<types::WebhookSubscriptionCreate>>::Error:
                std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `WebhookSubscriptionCreate` for body failed: {}",
                    s
                )
            });
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WebhookSubscriptionCreate,
            ) -> types::builder::WebhookSubscriptionCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to
        /// `/v1/webhooks/receivers/{receiver}/subscriptions`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSubscriptionCreated>, Error<types::Error>> {
            let Self {
                client,
                receiver,
                body,
            } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| {
                    types::WebhookSubscriptionCreate::try_from(v).map_err(|e| e.to_string())
                })
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/receivers/{}/subscriptions",
                client.baseurl,
                encode_path(&receiver.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_subscription_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for
    /// [`ClientSystemWebhooksExt::webhook_receiver_subscription_remove`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_receiver_subscription_remove`]: super::ClientSystemWebhooksExt::webhook_receiver_subscription_remove
    #[derive(Debug, Clone)]
    pub struct WebhookReceiverSubscriptionRemove<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
        subscription: Result<types::WebhookSubscription, String>,
    }

    impl<'a> WebhookReceiverSubscriptionRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
                subscription: Err("subscription was not initialized".to_string()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        pub fn subscription<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookSubscription>,
        {
            self.subscription = value.try_into().map_err(|_| {
                "conversion to `WebhookSubscription` for subscription failed".to_string()
            });
            self
        }

        /// Sends a `DELETE` request to
        /// `/v1/webhooks/receivers/{receiver}/subscriptions/{subscription}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                receiver,
                subscription,
            } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let subscription = subscription.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/receivers/{}/subscriptions/{}",
                client.baseurl,
                encode_path(&receiver.to_string()),
                encode_path(&subscription.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_receiver_subscription_remove",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_secrets_list`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_secrets_list`]: super::ClientSystemWebhooksExt::webhook_secrets_list
    #[derive(Debug, Clone)]
    pub struct WebhookSecretsList<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
    }

    impl<'a> WebhookSecretsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        /// Sends a `GET` request to `/v1/webhooks/secrets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSecrets>, Error<types::Error>> {
            let Self { client, receiver } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/webhooks/secrets", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .query(&progenitor_client::QueryParam::new("receiver", &receiver))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_secrets_list",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_secrets_add`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_secrets_add`]: super::ClientSystemWebhooksExt::webhook_secrets_add
    #[derive(Debug, Clone)]
    pub struct WebhookSecretsAdd<'a> {
        client: &'a super::Client,
        receiver: Result<types::NameOrId, String>,
        body: Result<types::builder::WebhookSecretCreate, String>,
    }

    impl<'a> WebhookSecretsAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                receiver: Err("receiver was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }

        pub fn receiver<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.receiver = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for receiver failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::WebhookSecretCreate>,
            <V as std::convert::TryInto<types::WebhookSecretCreate>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `WebhookSecretCreate` for body failed: {}", s));
            self
        }

        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                types::builder::WebhookSecretCreate,
            ) -> types::builder::WebhookSecretCreate,
        {
            self.body = self.body.map(f);
            self
        }

        /// Sends a `POST` request to `/v1/webhooks/secrets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::WebhookSecret>, Error<types::Error>> {
            let Self {
                client,
                receiver,
                body,
            } = self;
            let receiver = receiver.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::WebhookSecretCreate::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/webhooks/secrets", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .query(&progenitor_client::QueryParam::new("receiver", &receiver))
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_secrets_add",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    /// Builder for [`ClientSystemWebhooksExt::webhook_secrets_delete`]
    ///
    /// [`ClientSystemWebhooksExt::webhook_secrets_delete`]: super::ClientSystemWebhooksExt::webhook_secrets_delete
    #[derive(Debug, Clone)]
    pub struct WebhookSecretsDelete<'a> {
        client: &'a super::Client,
        secret_id: Result<::uuid::Uuid, String>,
    }

    impl<'a> WebhookSecretsDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                secret_id: Err("secret_id was not initialized".to_string()),
            }
        }

        pub fn secret_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::uuid::Uuid>,
        {
            self.secret_id = value
                .try_into()
                .map_err(|_| "conversion to `:: uuid :: Uuid` for secret_id failed".to_string());
            self
        }

        /// Sends a `DELETE` request to `/v1/webhooks/secrets/{secret_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, secret_id } = self;
            let secret_id = secret_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/webhooks/secrets/{}",
                client.baseurl,
                encode_path(&secret_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "webhook_secrets_delete",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}

/// Items consumers will typically use such as the Client and
/// extension traits.
pub mod prelude {
    #[allow(unused_imports)]
    pub use super::Client;
    pub use super::ClientAffinityExt;
    pub use super::ClientDisksExt;
    pub use super::ClientFloatingIpsExt;
    pub use super::ClientHiddenExt;
    pub use super::ClientImagesExt;
    pub use super::ClientInstancesExt;
    pub use super::ClientLoginExt;
    pub use super::ClientMetricsExt;
    pub use super::ClientPolicyExt;
    pub use super::ClientProjectsExt;
    pub use super::ClientRolesExt;
    pub use super::ClientSessionExt;
    pub use super::ClientSilosExt;
    pub use super::ClientSnapshotsExt;
    pub use super::ClientSystemHardwareExt;
    pub use super::ClientSystemIpPoolsExt;
    pub use super::ClientSystemMetricsExt;
    pub use super::ClientSystemNetworkingExt;
    pub use super::ClientSystemSilosExt;
    pub use super::ClientSystemStatusExt;
    pub use super::ClientSystemWebhooksExt;
    pub use super::ClientVpcsExt;
}
