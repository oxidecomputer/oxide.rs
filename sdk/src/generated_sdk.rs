// The contents of this file are generated; do not modify them.

#[allow(unused_imports)]
use progenitor_client::{encode_path, RequestBuilderExt};
pub use progenitor_client::{ByteStream, Error, ResponseValue};
#[allow(unused_imports)]
use reqwest::header::{HeaderMap, HeaderValue};
pub mod types {
    use serde::{Deserialize, Serialize};
    #[allow(unused_imports)]
    use std::convert::TryFrom;
    #[doc = "Describes properties that should uniquely identify a Gimlet."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Baseboard {
        pub part: String,
        pub revision: i64,
        pub serial: String,
    }

    impl From<&Baseboard> for Baseboard {
        fn from(value: &Baseboard) -> Self {
            value.clone()
        }
    }

    impl Baseboard {
        pub fn builder() -> builder::Baseboard {
            builder::Baseboard::default()
        }
    }

    #[doc = "A type storing a range over `T`.\n\nThis type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum BinRangedouble {
        #[doc = "A range unbounded below and exclusively above, `..end`."]
        #[serde(rename = "range_to")]
        RangeTo { end: f64 },
        #[doc = "A range bounded inclusively below and exclusively above, `start..end`."]
        #[serde(rename = "range")]
        Range { end: f64, start: f64 },
        #[doc = "A range bounded inclusively below and unbounded above, `start..`."]
        #[serde(rename = "range_from")]
        RangeFrom { start: f64 },
    }

    impl From<&BinRangedouble> for BinRangedouble {
        fn from(value: &BinRangedouble) -> Self {
            value.clone()
        }
    }

    #[doc = "A type storing a range over `T`.\n\nThis type supports ranges similar to the `RangeTo`, `Range` and `RangeFrom` types in the standard library. Those cover `(..end)`, `(start..end)`, and `(start..)` respectively."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum BinRangeint64 {
        #[doc = "A range unbounded below and exclusively above, `..end`."]
        #[serde(rename = "range_to")]
        RangeTo { end: i64 },
        #[doc = "A range bounded inclusively below and exclusively above, `start..end`."]
        #[serde(rename = "range")]
        Range { end: i64, start: i64 },
        #[doc = "A range bounded inclusively below and unbounded above, `start..`."]
        #[serde(rename = "range_from")]
        RangeFrom { start: i64 },
    }

    impl From<&BinRangeint64> for BinRangeint64 {
        fn from(value: &BinRangeint64) -> Self {
            value.clone()
        }
    }

    #[doc = "Type storing bin edges and a count of samples within it."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Bindouble {
        #[doc = "The total count of samples in this bin."]
        pub count: u64,
        #[doc = "The range of the support covered by this bin."]
        pub range: BinRangedouble,
    }

    impl From<&Bindouble> for Bindouble {
        fn from(value: &Bindouble) -> Self {
            value.clone()
        }
    }

    impl Bindouble {
        pub fn builder() -> builder::Bindouble {
            builder::Bindouble::default()
        }
    }

    #[doc = "Type storing bin edges and a count of samples within it."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Binint64 {
        #[doc = "The total count of samples in this bin."]
        pub count: u64,
        #[doc = "The range of the support covered by this bin."]
        pub range: BinRangeint64,
    }

    impl From<&Binint64> for Binint64 {
        fn from(value: &Binint64) -> Self {
            value.clone()
        }
    }

    impl Binint64 {
        pub fn builder() -> builder::Binint64 {
            builder::Binint64::default()
        }
    }

    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct BlockSize(i64);
    impl std::ops::Deref for BlockSize {
        type Target = i64;
        fn deref(&self) -> &i64 {
            &self.0
        }
    }

    impl From<BlockSize> for i64 {
        fn from(value: BlockSize) -> Self {
            value.0
        }
    }

    impl From<&BlockSize> for BlockSize {
        fn from(value: &BlockSize) -> Self {
            value.clone()
        }
    }

    impl std::convert::TryFrom<i64> for BlockSize {
        type Error = &'static str;
        fn try_from(value: i64) -> Result<Self, &'static str> {
            if ![512_i64, 2048_i64, 4096_i64].contains(&value) {
                Err("invalid value")
            } else {
                Ok(Self(value))
            }
        }
    }

    impl<'de> serde::Deserialize<'de> for BlockSize {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            Self::try_from(i64::deserialize(deserializer)?)
                .map_err(|e| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "A count of bytes, typically used either for memory or storage capacity\n\nThe maximum supported byte count is [`i64::MAX`].  This makes it somewhat inconvenient to define constructors: a u32 constructor can be infallible, but an i64 constructor can fail (if the value is negative) and a u64 constructor can fail (if the value is larger than i64::MAX).  We provide all of these for consumers' convenience."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ByteCount(pub u64);
    impl std::ops::Deref for ByteCount {
        type Target = u64;
        fn deref(&self) -> &u64 {
            &self.0
        }
    }

    impl From<ByteCount> for u64 {
        fn from(value: ByteCount) -> Self {
            value.0
        }
    }

    impl From<&ByteCount> for ByteCount {
        fn from(value: &ByteCount) -> Self {
            value.clone()
        }
    }

    impl From<u64> for ByteCount {
        fn from(value: u64) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for ByteCount {
        type Err = <u64 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for ByteCount {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ByteCount {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ByteCount {
        type Error = <u64 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for ByteCount {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    #[doc = "Client view of a [`Certificate`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Certificate {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub service: ServiceUsingCertificate,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Certificate> for Certificate {
        fn from(value: &Certificate) -> Self {
            value.clone()
        }
    }

    impl Certificate {
        pub fn builder() -> builder::Certificate {
            builder::Certificate::default()
        }
    }

    #[doc = "Create-time parameters for a [`Certificate`](crate::external_api::views::Certificate)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct CertificateCreate {
        #[doc = "PEM file containing public certificate chain"]
        pub cert: Vec<u8>,
        pub description: String,
        #[doc = "PEM file containing private key"]
        pub key: Vec<u8>,
        pub name: Name,
        #[doc = "The service using this certificate"]
        pub service: ServiceUsingCertificate,
    }

    impl From<&CertificateCreate> for CertificateCreate {
        fn from(value: &CertificateCreate) -> Self {
            value.clone()
        }
    }

    impl CertificateCreate {
        pub fn builder() -> builder::CertificateCreate {
            builder::CertificateCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct CertificateResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Certificate>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&CertificateResultsPage> for CertificateResultsPage {
        fn from(value: &CertificateResultsPage) -> Self {
            value.clone()
        }
    }

    impl CertificateResultsPage {
        pub fn builder() -> builder::CertificateResultsPage {
            builder::CertificateResultsPage::default()
        }
    }

    #[doc = "Identity-related metadata that's included in \"asset\" public API objects (which generally have no name or description)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ComponentUpdate {
        pub component_type: UpdateableComponentType,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&ComponentUpdate> for ComponentUpdate {
        fn from(value: &ComponentUpdate) -> Self {
            value.clone()
        }
    }

    impl ComponentUpdate {
        pub fn builder() -> builder::ComponentUpdate {
            builder::ComponentUpdate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ComponentUpdateResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<ComponentUpdate>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ComponentUpdateResultsPage> for ComponentUpdateResultsPage {
        fn from(value: &ComponentUpdateResultsPage) -> Self {
            value.clone()
        }
    }

    impl ComponentUpdateResultsPage {
        pub fn builder() -> builder::ComponentUpdateResultsPage {
            builder::ComponentUpdateResultsPage::default()
        }
    }

    #[doc = "A cumulative or counter data type."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Cumulativedouble {
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
        pub value: f64,
    }

    impl From<&Cumulativedouble> for Cumulativedouble {
        fn from(value: &Cumulativedouble) -> Self {
            value.clone()
        }
    }

    impl Cumulativedouble {
        pub fn builder() -> builder::Cumulativedouble {
            builder::Cumulativedouble::default()
        }
    }

    #[doc = "A cumulative or counter data type."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Cumulativeint64 {
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
        pub value: i64,
    }

    impl From<&Cumulativeint64> for Cumulativeint64 {
        fn from(value: &Cumulativeint64) -> Self {
            value.clone()
        }
    }

    impl Cumulativeint64 {
        pub fn builder() -> builder::Cumulativeint64 {
            builder::Cumulativeint64::default()
        }
    }

    #[doc = "A `Datum` is a single sampled data point from a metric."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "datum")]
    pub enum Datum {
        #[serde(rename = "bool")]
        Bool(bool),
        #[serde(rename = "i64")]
        I64(i64),
        #[serde(rename = "f64")]
        F64(f64),
        #[serde(rename = "string")]
        String(String),
        #[serde(rename = "bytes")]
        Bytes(Vec<u8>),
        #[serde(rename = "cumulative_i64")]
        CumulativeI64(Cumulativeint64),
        #[serde(rename = "cumulative_f64")]
        CumulativeF64(Cumulativedouble),
        #[serde(rename = "histogram_i64")]
        HistogramI64(Histogramint64),
        #[serde(rename = "histogram_f64")]
        HistogramF64(Histogramdouble),
    }

    impl From<&Datum> for Datum {
        fn from(value: &Datum) -> Self {
            value.clone()
        }
    }

    #[doc = "The type of an individual datum of a metric."]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum DatumType {
        #[serde(rename = "bool")]
        Bool,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "f64")]
        F64,
        #[serde(rename = "string")]
        String,
        #[serde(rename = "bytes")]
        Bytes,
        #[serde(rename = "cumulative_i64")]
        CumulativeI64,
        #[serde(rename = "cumulative_f64")]
        CumulativeF64,
        #[serde(rename = "histogram_i64")]
        HistogramI64,
        #[serde(rename = "histogram_f64")]
        HistogramF64,
    }

    impl From<&DatumType> for DatumType {
        fn from(value: &DatumType) -> Self {
            value.clone()
        }
    }

    impl ToString for DatumType {
        fn to_string(&self) -> String {
            match *self {
                Self::Bool => "bool".to_string(),
                Self::I64 => "i64".to_string(),
                Self::F64 => "f64".to_string(),
                Self::String => "string".to_string(),
                Self::Bytes => "bytes".to_string(),
                Self::CumulativeI64 => "cumulative_i64".to_string(),
                Self::CumulativeF64 => "cumulative_f64".to_string(),
                Self::HistogramI64 => "histogram_i64".to_string(),
                Self::HistogramF64 => "histogram_f64".to_string(),
            }
        }
    }

    impl std::str::FromStr for DatumType {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "bool" => Ok(Self::Bool),
                "i64" => Ok(Self::I64),
                "f64" => Ok(Self::F64),
                "string" => Ok(Self::String),
                "bytes" => Ok(Self::Bytes),
                "cumulative_i64" => Ok(Self::CumulativeI64),
                "cumulative_f64" => Ok(Self::CumulativeF64),
                "histogram_i64" => Ok(Self::HistogramI64),
                "histogram_f64" => Ok(Self::HistogramF64),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DatumType {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DatumType {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DatumType {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DerEncodedKeyPair {
        #[doc = "request signing private key (base64 encoded der file)"]
        pub private_key: String,
        #[doc = "request signing public certificate (base64 encoded der file)"]
        pub public_cert: String,
    }

    impl From<&DerEncodedKeyPair> for DerEncodedKeyPair {
        fn from(value: &DerEncodedKeyPair) -> Self {
            value.clone()
        }
    }

    impl DerEncodedKeyPair {
        pub fn builder() -> builder::DerEncodedKeyPair {
            builder::DerEncodedKeyPair::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DeviceAccessTokenRequest {
        pub client_id: uuid::Uuid,
        pub device_code: String,
        pub grant_type: String,
    }

    impl From<&DeviceAccessTokenRequest> for DeviceAccessTokenRequest {
        fn from(value: &DeviceAccessTokenRequest) -> Self {
            value.clone()
        }
    }

    impl DeviceAccessTokenRequest {
        pub fn builder() -> builder::DeviceAccessTokenRequest {
            builder::DeviceAccessTokenRequest::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DeviceAuthRequest {
        pub client_id: uuid::Uuid,
    }

    impl From<&DeviceAuthRequest> for DeviceAuthRequest {
        fn from(value: &DeviceAuthRequest) -> Self {
            value.clone()
        }
    }

    impl DeviceAuthRequest {
        pub fn builder() -> builder::DeviceAuthRequest {
            builder::DeviceAuthRequest::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DeviceAuthVerify {
        pub user_code: String,
    }

    impl From<&DeviceAuthVerify> for DeviceAuthVerify {
        fn from(value: &DeviceAuthVerify) -> Self {
            value.clone()
        }
    }

    impl DeviceAuthVerify {
        pub fn builder() -> builder::DeviceAuthVerify {
            builder::DeviceAuthVerify::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "value")]
    pub enum Digest {
        #[serde(rename = "sha256")]
        Sha256(String),
    }

    impl From<&Digest> for Digest {
        fn from(value: &Digest) -> Self {
            value.clone()
        }
    }

    #[doc = "Client view of a [`Disk`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Disk {
        pub block_size: ByteCount,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub device_path: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub image_id: Option<uuid::Uuid>,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub snapshot_id: Option<uuid::Uuid>,
        pub state: DiskState,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Disk> for Disk {
        fn from(value: &Disk) -> Self {
            value.clone()
        }
    }

    impl Disk {
        pub fn builder() -> builder::Disk {
            builder::Disk::default()
        }
    }

    #[doc = "Create-time parameters for a [`Disk`](omicron_common::api::external::Disk)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DiskCreate {
        pub description: String,
        #[doc = "initial source for this disk"]
        pub disk_source: DiskSource,
        pub name: Name,
        #[doc = "total size of the Disk in bytes"]
        pub size: ByteCount,
    }

    impl From<&DiskCreate> for DiskCreate {
        fn from(value: &DiskCreate) -> Self {
            value.clone()
        }
    }

    impl DiskCreate {
        pub fn builder() -> builder::DiskCreate {
            builder::DiskCreate::default()
        }
    }

    #[doc = "TODO-v1: Delete this Parameters for the [`Disk`](omicron_common::api::external::Disk) to be attached or detached to an instance"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DiskIdentifier {
        pub name: Name,
    }

    impl From<&DiskIdentifier> for DiskIdentifier {
        fn from(value: &DiskIdentifier) -> Self {
            value.clone()
        }
    }

    impl DiskIdentifier {
        pub fn builder() -> builder::DiskIdentifier {
            builder::DiskIdentifier::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum DiskMetricName {
        #[serde(rename = "activated")]
        Activated,
        #[serde(rename = "flush")]
        Flush,
        #[serde(rename = "read")]
        Read,
        #[serde(rename = "read_bytes")]
        ReadBytes,
        #[serde(rename = "write")]
        Write,
        #[serde(rename = "write_bytes")]
        WriteBytes,
    }

    impl From<&DiskMetricName> for DiskMetricName {
        fn from(value: &DiskMetricName) -> Self {
            value.clone()
        }
    }

    impl ToString for DiskMetricName {
        fn to_string(&self) -> String {
            match *self {
                Self::Activated => "activated".to_string(),
                Self::Flush => "flush".to_string(),
                Self::Read => "read".to_string(),
                Self::ReadBytes => "read_bytes".to_string(),
                Self::Write => "write".to_string(),
                Self::WriteBytes => "write_bytes".to_string(),
            }
        }
    }

    impl std::str::FromStr for DiskMetricName {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "activated" => Ok(Self::Activated),
                "flush" => Ok(Self::Flush),
                "read" => Ok(Self::Read),
                "read_bytes" => Ok(Self::ReadBytes),
                "write" => Ok(Self::Write),
                "write_bytes" => Ok(Self::WriteBytes),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for DiskMetricName {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for DiskMetricName {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for DiskMetricName {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DiskPath {
        pub disk: NameOrId,
    }

    impl From<&DiskPath> for DiskPath {
        fn from(value: &DiskPath) -> Self {
            value.clone()
        }
    }

    impl DiskPath {
        pub fn builder() -> builder::DiskPath {
            builder::DiskPath::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct DiskResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Disk>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&DiskResultsPage> for DiskResultsPage {
        fn from(value: &DiskResultsPage) -> Self {
            value.clone()
        }
    }

    impl DiskResultsPage {
        pub fn builder() -> builder::DiskResultsPage {
            builder::DiskResultsPage::default()
        }
    }

    #[doc = "Different sources for a disk"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum DiskSource {
        #[doc = "Create a blank disk"]
        #[serde(rename = "blank")]
        Blank {
            #[doc = "size of blocks for this Disk. valid values are: 512, 2048, or 4096"]
            block_size: BlockSize,
        },
        #[doc = "Create a disk from a disk snapshot"]
        #[serde(rename = "snapshot")]
        Snapshot { snapshot_id: uuid::Uuid },
        #[doc = "Create a disk from a project image"]
        #[serde(rename = "image")]
        Image { image_id: uuid::Uuid },
        #[doc = "Create a disk from a global image"]
        #[serde(rename = "global_image")]
        GlobalImage { image_id: uuid::Uuid },
    }

    impl From<&DiskSource> for DiskSource {
        fn from(value: &DiskSource) -> Self {
            value.clone()
        }
    }

    #[doc = "State of a Disk (primarily: attached or not)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "state", content = "instance")]
    pub enum DiskState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "detached")]
        Detached,
        #[serde(rename = "maintenance")]
        Maintenance,
        #[doc = "Disk is being attached to the given Instance"]
        #[serde(rename = "attaching")]
        Attaching(uuid::Uuid),
        #[doc = "Disk is attached to the given Instance"]
        #[serde(rename = "attached")]
        Attached(uuid::Uuid),
        #[doc = "Disk is being detached from the given Instance"]
        #[serde(rename = "detaching")]
        Detaching(uuid::Uuid),
        #[serde(rename = "destroyed")]
        Destroyed,
        #[serde(rename = "faulted")]
        Faulted,
    }

    impl From<&DiskState> for DiskState {
        fn from(value: &DiskState) -> Self {
            value.clone()
        }
    }

    #[doc = "OS image distribution"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Distribution {
        #[doc = "The name of the distribution (e.g. \"alpine\" or \"ubuntu\")"]
        pub name: Name,
        #[doc = "The version of the distribution (e.g. \"3.10\" or \"18.04\")"]
        pub version: String,
    }

    impl From<&Distribution> for Distribution {
        fn from(value: &Distribution) -> Self {
            value.clone()
        }
    }

    impl Distribution {
        pub fn builder() -> builder::Distribution {
            builder::Distribution::default()
        }
    }

    #[doc = "Error information from a response."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Error {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub error_code: Option<String>,
        pub message: String,
        pub request_id: String,
    }

    impl From<&Error> for Error {
        fn from(value: &Error) -> Self {
            value.clone()
        }
    }

    impl Error {
        pub fn builder() -> builder::Error {
            builder::Error::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ExternalIp {
        pub ip: std::net::IpAddr,
        pub kind: IpKind,
    }

    impl From<&ExternalIp> for ExternalIp {
        fn from(value: &ExternalIp) -> Self {
            value.clone()
        }
    }

    impl ExternalIp {
        pub fn builder() -> builder::ExternalIp {
            builder::ExternalIp::default()
        }
    }

    #[doc = "Parameters for creating an external IP address for instances."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum ExternalIpCreate {
        #[doc = "An IP address providing both inbound and outbound access. The address is automatically-assigned from the provided IP Pool, or all available pools if not specified."]
        #[serde(rename = "ephemeral")]
        Ephemeral {
            #[serde(default, skip_serializing_if = "Option::is_none")]
            pool_name: Option<Name>,
        },
    }

    impl From<&ExternalIpCreate> for ExternalIpCreate {
        fn from(value: &ExternalIpCreate) -> Self {
            value.clone()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ExternalIpResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<ExternalIp>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ExternalIpResultsPage> for ExternalIpResultsPage {
        fn from(value: &ExternalIpResultsPage) -> Self {
            value.clone()
        }
    }

    impl ExternalIpResultsPage {
        pub fn builder() -> builder::ExternalIpResultsPage {
            builder::ExternalIpResultsPage::default()
        }
    }

    #[doc = "The name and type information for a field of a timeseries schema."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct FieldSchema {
        pub name: String,
        pub source: FieldSource,
        pub ty: FieldType,
    }

    impl From<&FieldSchema> for FieldSchema {
        fn from(value: &FieldSchema) -> Self {
            value.clone()
        }
    }

    impl FieldSchema {
        pub fn builder() -> builder::FieldSchema {
            builder::FieldSchema::default()
        }
    }

    #[doc = "The source from which a field is derived, the target or metric."]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum FieldSource {
        #[serde(rename = "target")]
        Target,
        #[serde(rename = "metric")]
        Metric,
    }

    impl From<&FieldSource> for FieldSource {
        fn from(value: &FieldSource) -> Self {
            value.clone()
        }
    }

    impl ToString for FieldSource {
        fn to_string(&self) -> String {
            match *self {
                Self::Target => "target".to_string(),
                Self::Metric => "metric".to_string(),
            }
        }
    }

    impl std::str::FromStr for FieldSource {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "target" => Ok(Self::Target),
                "metric" => Ok(Self::Metric),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FieldSource {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FieldSource {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FieldSource {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "The `FieldType` identifies the data type of a target or metric field."]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum FieldType {
        #[serde(rename = "string")]
        String,
        #[serde(rename = "i64")]
        I64,
        #[serde(rename = "ip_addr")]
        IpAddr,
        #[serde(rename = "uuid")]
        Uuid,
        #[serde(rename = "bool")]
        Bool,
    }

    impl From<&FieldType> for FieldType {
        fn from(value: &FieldType) -> Self {
            value.clone()
        }
    }

    impl ToString for FieldType {
        fn to_string(&self) -> String {
            match *self {
                Self::String => "string".to_string(),
                Self::I64 => "i64".to_string(),
                Self::IpAddr => "ip_addr".to_string(),
                Self::Uuid => "uuid".to_string(),
                Self::Bool => "bool".to_string(),
            }
        }
    }

    impl std::str::FromStr for FieldType {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "string" => Ok(Self::String),
                "i64" => Ok(Self::I64),
                "ip_addr" => Ok(Self::IpAddr),
                "uuid" => Ok(Self::Uuid),
                "bool" => Ok(Self::Bool),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FieldType {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FieldType {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FieldType {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum FleetRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&FleetRole> for FleetRole {
        fn from(value: &FleetRole) -> Self {
            value.clone()
        }
    }

    impl ToString for FleetRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for FleetRole {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for FleetRole {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for FleetRole {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for FleetRole {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct FleetRolePolicy {
        #[doc = "Roles directly assigned on this resource"]
        pub role_assignments: Vec<FleetRoleRoleAssignment>,
    }

    impl From<&FleetRolePolicy> for FleetRolePolicy {
        fn from(value: &FleetRolePolicy) -> Self {
            value.clone()
        }
    }

    impl FleetRolePolicy {
        pub fn builder() -> builder::FleetRolePolicy {
            builder::FleetRolePolicy::default()
        }
    }

    #[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct FleetRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: FleetRole,
    }

    impl From<&FleetRoleRoleAssignment> for FleetRoleRoleAssignment {
        fn from(value: &FleetRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl FleetRoleRoleAssignment {
        pub fn builder() -> builder::FleetRoleRoleAssignment {
            builder::FleetRoleRoleAssignment::default()
        }
    }

    #[doc = "Client view of global Images"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct GlobalImage {
        #[doc = "size of blocks in bytes"]
        pub block_size: ByteCount,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "Hash of the image contents, if applicable"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub digest: Option<Digest>,
        #[doc = "Image distribution"]
        pub distribution: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "total size in bytes"]
        pub size: ByteCount,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "URL source of this image, if any"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        #[doc = "Image version"]
        pub version: String,
    }

    impl From<&GlobalImage> for GlobalImage {
        fn from(value: &GlobalImage) -> Self {
            value.clone()
        }
    }

    impl GlobalImage {
        pub fn builder() -> builder::GlobalImage {
            builder::GlobalImage::default()
        }
    }

    #[doc = "Create-time parameters for an [`GlobalImage`](crate::external_api::views::GlobalImage)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct GlobalImageCreate {
        #[doc = "block size in bytes"]
        pub block_size: BlockSize,
        pub description: String,
        #[doc = "OS image distribution"]
        pub distribution: Distribution,
        pub name: Name,
        #[doc = "The source of the image's contents."]
        pub source: ImageSource,
    }

    impl From<&GlobalImageCreate> for GlobalImageCreate {
        fn from(value: &GlobalImageCreate) -> Self {
            value.clone()
        }
    }

    impl GlobalImageCreate {
        pub fn builder() -> builder::GlobalImageCreate {
            builder::GlobalImageCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct GlobalImageResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<GlobalImage>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&GlobalImageResultsPage> for GlobalImageResultsPage {
        fn from(value: &GlobalImageResultsPage) -> Self {
            value.clone()
        }
    }

    impl GlobalImageResultsPage {
        pub fn builder() -> builder::GlobalImageResultsPage {
            builder::GlobalImageResultsPage::default()
        }
    }

    #[doc = "Client view of a [`Group`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Group {
        #[doc = "Human-readable name that can identify the group"]
        pub display_name: String,
        pub id: uuid::Uuid,
        #[doc = "Uuid of the silo to which this group belongs"]
        pub silo_id: uuid::Uuid,
    }

    impl From<&Group> for Group {
        fn from(value: &Group) -> Self {
            value.clone()
        }
    }

    impl Group {
        pub fn builder() -> builder::Group {
            builder::Group::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct GroupResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Group>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&GroupResultsPage> for GroupResultsPage {
        fn from(value: &GroupResultsPage) -> Self {
            value.clone()
        }
    }

    impl GroupResultsPage {
        pub fn builder() -> builder::GroupResultsPage {
            builder::GroupResultsPage::default()
        }
    }

    #[doc = "A simple type for managing a histogram metric.\n\nA histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any \"gaps\" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.\n\nNote that any gaps, unsorted bins, or non-finite values will result in an error.\n\nExample ------- ```rust use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64, 10, 20]; let mut hist = Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..) assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);\n\nlet data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range, BinRange::range(i64::MIN, 0)); // An additional bin for `..0` assert_eq!(data[0].count, 0); // Nothing is in this bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```\n\nNotes -----\n\nHistograms may be constructed either from their left bin edges, or from a sequence of ranges. In either case, the left-most bin may be converted upon construction. In particular, if the left-most value is not equal to the minimum of the support, a new bin will be added from the minimum to that provided value. If the left-most value _is_ the support's minimum, because the provided bin was unbounded below, such as `(..0)`, then that bin will be converted into one bounded below, `(MIN..0)` in this case.\n\nThe short of this is that, most of the time, it shouldn't matter. If one specifies the extremes of the support as their bins, be aware that the left-most may be converted from a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the first bin of a histogram is _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In fact, every bin is one of those variants, the `BinRange::RangeTo` is only provided as a convenience during construction."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Histogramdouble {
        pub bins: Vec<Bindouble>,
        pub n_samples: u64,
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Histogramdouble> for Histogramdouble {
        fn from(value: &Histogramdouble) -> Self {
            value.clone()
        }
    }

    impl Histogramdouble {
        pub fn builder() -> builder::Histogramdouble {
            builder::Histogramdouble::default()
        }
    }

    #[doc = "A simple type for managing a histogram metric.\n\nA histogram maintains the count of any number of samples, over a set of bins. Bins are specified on construction via their _left_ edges, inclusive. There can't be any \"gaps\" in the bins, and an additional bin may be added to the left, right, or both so that the bins extend to the entire range of the support.\n\nNote that any gaps, unsorted bins, or non-finite values will result in an error.\n\nExample ------- ```rust use oximeter::histogram::{BinRange, Histogram};\n\nlet edges = [0i64, 10, 20]; let mut hist = Histogram::new(&edges).unwrap(); assert_eq!(hist.n_bins(), 4); // One additional bin for the range (20..) assert_eq!(hist.n_samples(), 0); hist.sample(4); hist.sample(100); assert_eq!(hist.n_samples(), 2);\n\nlet data = hist.iter().collect::<Vec<_>>(); assert_eq!(data[0].range, BinRange::range(i64::MIN, 0)); // An additional bin for `..0` assert_eq!(data[0].count, 0); // Nothing is in this bin\n\nassert_eq!(data[1].range, BinRange::range(0, 10)); // The range `0..10` assert_eq!(data[1].count, 1); // 4 is sampled into this bin ```\n\nNotes -----\n\nHistograms may be constructed either from their left bin edges, or from a sequence of ranges. In either case, the left-most bin may be converted upon construction. In particular, if the left-most value is not equal to the minimum of the support, a new bin will be added from the minimum to that provided value. If the left-most value _is_ the support's minimum, because the provided bin was unbounded below, such as `(..0)`, then that bin will be converted into one bounded below, `(MIN..0)` in this case.\n\nThe short of this is that, most of the time, it shouldn't matter. If one specifies the extremes of the support as their bins, be aware that the left-most may be converted from a `BinRange::RangeTo` into a `BinRange::Range`. In other words, the first bin of a histogram is _always_ a `Bin::Range` or a `Bin::RangeFrom` after construction. In fact, every bin is one of those variants, the `BinRange::RangeTo` is only provided as a convenience during construction."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Histogramint64 {
        pub bins: Vec<Binint64>,
        pub n_samples: u64,
        pub start_time: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Histogramint64> for Histogramint64 {
        fn from(value: &Histogramint64) -> Self {
            value.clone()
        }
    }

    impl Histogramint64 {
        pub fn builder() -> builder::Histogramint64 {
            builder::Histogramint64::default()
        }
    }

    #[doc = "Supported set of sort modes for scanning by id only.\n\nCurrently, we only support scanning in ascending order."]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum IdSortMode {
        #[doc = "sort in increasing order of \"id\""]
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl From<&IdSortMode> for IdSortMode {
        fn from(value: &IdSortMode) -> Self {
            value.clone()
        }
    }

    impl ToString for IdSortMode {
        fn to_string(&self) -> String {
            match *self {
                Self::IdAscending => "id_ascending".to_string(),
            }
        }
    }

    impl std::str::FromStr for IdSortMode {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IdSortMode {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IdSortMode {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IdSortMode {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of an [`IdentityProvider`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IdentityProvider {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "Identity provider type"]
        pub provider_type: IdentityProviderType,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&IdentityProvider> for IdentityProvider {
        fn from(value: &IdentityProvider) -> Self {
            value.clone()
        }
    }

    impl IdentityProvider {
        pub fn builder() -> builder::IdentityProvider {
            builder::IdentityProvider::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IdentityProviderResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<IdentityProvider>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&IdentityProviderResultsPage> for IdentityProviderResultsPage {
        fn from(value: &IdentityProviderResultsPage) -> Self {
            value.clone()
        }
    }

    impl IdentityProviderResultsPage {
        pub fn builder() -> builder::IdentityProviderResultsPage {
            builder::IdentityProviderResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum IdentityProviderType {
        #[doc = "SAML identity provider"]
        #[serde(rename = "saml")]
        Saml,
    }

    impl From<&IdentityProviderType> for IdentityProviderType {
        fn from(value: &IdentityProviderType) -> Self {
            value.clone()
        }
    }

    impl ToString for IdentityProviderType {
        fn to_string(&self) -> String {
            match *self {
                Self::Saml => "saml".to_string(),
            }
        }
    }

    impl std::str::FromStr for IdentityProviderType {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "saml" => Ok(Self::Saml),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IdentityProviderType {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IdentityProviderType {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IdentityProviderType {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Describes what kind of identity is described by an id"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum IdentityType {
        #[serde(rename = "silo_user")]
        SiloUser,
        #[serde(rename = "silo_group")]
        SiloGroup,
    }

    impl From<&IdentityType> for IdentityType {
        fn from(value: &IdentityType) -> Self {
            value.clone()
        }
    }

    impl ToString for IdentityType {
        fn to_string(&self) -> String {
            match *self {
                Self::SiloUser => "silo_user".to_string(),
                Self::SiloGroup => "silo_group".to_string(),
            }
        }
    }

    impl std::str::FromStr for IdentityType {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "silo_user" => Ok(Self::SiloUser),
                "silo_group" => Ok(Self::SiloGroup),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IdentityType {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IdentityType {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IdentityType {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum IdpMetadataSource {
        #[serde(rename = "url")]
        Url { url: String },
        #[serde(rename = "base64_encoded_xml")]
        Base64EncodedXml { data: String },
    }

    impl From<&IdpMetadataSource> for IdpMetadataSource {
        fn from(value: &IdpMetadataSource) -> Self {
            value.clone()
        }
    }

    #[doc = "Client view of project Images"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Image {
        #[doc = "size of blocks in bytes"]
        pub block_size: ByteCount,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "Hash of the image contents, if applicable"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub digest: Option<Digest>,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "The family of the operating system like Debian, Ubuntu, etc."]
        pub os: String,
        #[doc = "The project the image belongs to"]
        pub project_id: uuid::Uuid,
        #[doc = "total size in bytes"]
        pub size: ByteCount,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "URL source of this image, if any"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub url: Option<String>,
        #[doc = "Version of the operating system"]
        pub version: String,
    }

    impl From<&Image> for Image {
        fn from(value: &Image) -> Self {
            value.clone()
        }
    }

    impl Image {
        pub fn builder() -> builder::Image {
            builder::Image::default()
        }
    }

    #[doc = "Create-time parameters for an [`Image`](crate::external_api::views::Image)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ImageCreate {
        #[doc = "block size in bytes"]
        pub block_size: BlockSize,
        pub description: String,
        pub name: Name,
        #[doc = "The family of the operating system (e.g. Debian, Ubuntu, etc.)"]
        pub os: String,
        #[doc = "The source of the image's contents."]
        pub source: ImageSource,
        #[doc = "The version of the operating system (e.g. 18.04, 20.04, etc.)"]
        pub version: String,
    }

    impl From<&ImageCreate> for ImageCreate {
        fn from(value: &ImageCreate) -> Self {
            value.clone()
        }
    }

    impl ImageCreate {
        pub fn builder() -> builder::ImageCreate {
            builder::ImageCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ImageResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Image>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ImageResultsPage> for ImageResultsPage {
        fn from(value: &ImageResultsPage) -> Self {
            value.clone()
        }
    }

    impl ImageResultsPage {
        pub fn builder() -> builder::ImageResultsPage {
            builder::ImageResultsPage::default()
        }
    }

    #[doc = "The source of the underlying image."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum ImageSource {
        #[serde(rename = "url")]
        Url { url: String },
        #[serde(rename = "snapshot")]
        Snapshot { id: uuid::Uuid },
        #[serde(rename = "you_can_boot_anything_as_long_as_its_alpine")]
        YouCanBootAnythingAsLongAsItsAlpine,
    }

    impl From<&ImageSource> for ImageSource {
        fn from(value: &ImageSource) -> Self {
            value.clone()
        }
    }

    #[doc = "Client view of an [`Instance`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Instance {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "RFC1035-compliant hostname for the Instance."]
        pub hostname: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "memory allocated for this Instance"]
        pub memory: ByteCount,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "number of CPUs allocated for this Instance"]
        pub ncpus: InstanceCpuCount,
        #[doc = "id for the project containing this Instance"]
        pub project_id: uuid::Uuid,
        pub run_state: InstanceState,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub time_run_state_updated: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Instance> for Instance {
        fn from(value: &Instance) -> Self {
            value.clone()
        }
    }

    impl Instance {
        pub fn builder() -> builder::Instance {
            builder::Instance::default()
        }
    }

    #[doc = "The number of CPUs in an Instance"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct InstanceCpuCount(pub u16);
    impl std::ops::Deref for InstanceCpuCount {
        type Target = u16;
        fn deref(&self) -> &u16 {
            &self.0
        }
    }

    impl From<InstanceCpuCount> for u16 {
        fn from(value: InstanceCpuCount) -> Self {
            value.0
        }
    }

    impl From<&InstanceCpuCount> for InstanceCpuCount {
        fn from(value: &InstanceCpuCount) -> Self {
            value.clone()
        }
    }

    impl From<u16> for InstanceCpuCount {
        fn from(value: u16) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for InstanceCpuCount {
        type Err = <u16 as std::str::FromStr>::Err;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.parse()?))
        }
    }

    impl std::convert::TryFrom<&str> for InstanceCpuCount {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: &str) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InstanceCpuCount {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: &String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InstanceCpuCount {
        type Error = <u16 as std::str::FromStr>::Err;
        fn try_from(value: String) -> Result<Self, Self::Error> {
            value.parse()
        }
    }

    impl ToString for InstanceCpuCount {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    #[doc = "Create-time parameters for an [`Instance`](omicron_common::api::external::Instance)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct InstanceCreate {
        pub description: String,
        #[doc = "The disks to be created or attached for this instance."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub disks: Vec<InstanceDiskAttachment>,
        #[doc = "The external IP addresses provided to this instance.\n\nBy default, all instances have outbound connectivity, but no inbound connectivity. These external addresses can be used to provide a fixed, known IP address for making inbound connections to the instance."]
        #[serde(default, skip_serializing_if = "Vec::is_empty")]
        pub external_ips: Vec<ExternalIpCreate>,
        pub hostname: String,
        pub memory: ByteCount,
        pub name: Name,
        pub ncpus: InstanceCpuCount,
        #[doc = "The network interfaces to be created for this instance."]
        #[serde(default = "defaults::instance_create_network_interfaces")]
        pub network_interfaces: InstanceNetworkInterfaceAttachment,
        #[doc = "Should this instance be started upon creation; true by default."]
        #[serde(default = "defaults::default_bool::<true>")]
        pub start: bool,
        #[doc = "User data for instance initialization systems (such as cloud-init). Must be a Base64-encoded string, as specified in RFC 4648  4 (+ and / characters with padding). Maximum 32 KiB unencoded data."]
        #[serde(default)]
        pub user_data: String,
    }

    impl From<&InstanceCreate> for InstanceCreate {
        fn from(value: &InstanceCreate) -> Self {
            value.clone()
        }
    }

    impl InstanceCreate {
        pub fn builder() -> builder::InstanceCreate {
            builder::InstanceCreate::default()
        }
    }

    #[doc = "Describe the instance's disks at creation time"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type")]
    pub enum InstanceDiskAttachment {
        #[doc = "During instance creation, create and attach disks"]
        #[serde(rename = "create")]
        Create {
            description: String,
            #[doc = "initial source for this disk"]
            disk_source: DiskSource,
            name: Name,
            #[doc = "total size of the Disk in bytes"]
            size: ByteCount,
        },
        #[doc = "During instance creation, attach this disk"]
        #[serde(rename = "attach")]
        Attach {
            #[doc = "A disk name to attach"]
            name: Name,
        },
    }

    impl From<&InstanceDiskAttachment> for InstanceDiskAttachment {
        fn from(value: &InstanceDiskAttachment) -> Self {
            value.clone()
        }
    }

    #[doc = "Migration parameters for an [`Instance`](omicron_common::api::external::Instance)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct InstanceMigrate {
        pub dst_sled_id: uuid::Uuid,
    }

    impl From<&InstanceMigrate> for InstanceMigrate {
        fn from(value: &InstanceMigrate) -> Self {
            value.clone()
        }
    }

    impl InstanceMigrate {
        pub fn builder() -> builder::InstanceMigrate {
            builder::InstanceMigrate::default()
        }
    }

    #[doc = "Describes an attachment of a `NetworkInterface` to an `Instance`, at the time the instance is created."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "params")]
    pub enum InstanceNetworkInterfaceAttachment {
        #[doc = "Create one or more `NetworkInterface`s for the `Instance`.\n\nIf more than one interface is provided, then the first will be designated the primary interface for the instance."]
        #[serde(rename = "create")]
        Create(Vec<NetworkInterfaceCreate>),
        #[serde(rename = "default")]
        Default,
        #[serde(rename = "none")]
        None,
    }

    impl From<&InstanceNetworkInterfaceAttachment> for InstanceNetworkInterfaceAttachment {
        fn from(value: &InstanceNetworkInterfaceAttachment) -> Self {
            value.clone()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct InstanceResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Instance>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&InstanceResultsPage> for InstanceResultsPage {
        fn from(value: &InstanceResultsPage) -> Self {
            value.clone()
        }
    }

    impl InstanceResultsPage {
        pub fn builder() -> builder::InstanceResultsPage {
            builder::InstanceResultsPage::default()
        }
    }

    #[doc = "Contents of an Instance's serial console buffer."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct InstanceSerialConsoleData {
        #[doc = "The bytes starting from the requested offset up to either the end of the buffer or the request's `max_bytes`. Provided as a u8 array rather than a string, as it may not be UTF-8."]
        pub data: Vec<u8>,
        #[doc = "The absolute offset since boot (suitable for use as `byte_offset` in a subsequent request) of the last byte returned in `data`."]
        pub last_byte_offset: u64,
    }

    impl From<&InstanceSerialConsoleData> for InstanceSerialConsoleData {
        fn from(value: &InstanceSerialConsoleData) -> Self {
            value.clone()
        }
    }

    impl InstanceSerialConsoleData {
        pub fn builder() -> builder::InstanceSerialConsoleData {
            builder::InstanceSerialConsoleData::default()
        }
    }

    #[doc = "Running state of an Instance (primarily: booted or stopped)\n\nThis typically reflects whether it's starting, running, stopping, or stopped, but also includes states related to the Instance's lifecycle"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum InstanceState {
        #[doc = "The instance is being created."]
        #[serde(rename = "creating")]
        Creating,
        #[doc = "The instance is currently starting up."]
        #[serde(rename = "starting")]
        Starting,
        #[doc = "The instance is currently running."]
        #[serde(rename = "running")]
        Running,
        #[doc = "The instance has been requested to stop and a transition to \"Stopped\" is imminent."]
        #[serde(rename = "stopping")]
        Stopping,
        #[doc = "The instance is currently stopped."]
        #[serde(rename = "stopped")]
        Stopped,
        #[doc = "The instance is in the process of rebooting - it will remain in the \"rebooting\" state until the VM is starting once more."]
        #[serde(rename = "rebooting")]
        Rebooting,
        #[doc = "The instance is in the process of migrating - it will remain in the \"migrating\" state until the migration process is complete and the destination propolis is ready to continue execution."]
        #[serde(rename = "migrating")]
        Migrating,
        #[doc = "The instance is attempting to recover from a failure."]
        #[serde(rename = "repairing")]
        Repairing,
        #[doc = "The instance has encountered a failure."]
        #[serde(rename = "failed")]
        Failed,
        #[doc = "The instance has been deleted."]
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl From<&InstanceState> for InstanceState {
        fn from(value: &InstanceState) -> Self {
            value.clone()
        }
    }

    impl ToString for InstanceState {
        fn to_string(&self) -> String {
            match *self {
                Self::Creating => "creating".to_string(),
                Self::Starting => "starting".to_string(),
                Self::Running => "running".to_string(),
                Self::Stopping => "stopping".to_string(),
                Self::Stopped => "stopped".to_string(),
                Self::Rebooting => "rebooting".to_string(),
                Self::Migrating => "migrating".to_string(),
                Self::Repairing => "repairing".to_string(),
                Self::Failed => "failed".to_string(),
                Self::Destroyed => "destroyed".to_string(),
            }
        }
    }

    impl std::str::FromStr for InstanceState {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "creating" => Ok(Self::Creating),
                "starting" => Ok(Self::Starting),
                "running" => Ok(Self::Running),
                "stopping" => Ok(Self::Stopping),
                "stopped" => Ok(Self::Stopped),
                "rebooting" => Ok(Self::Rebooting),
                "migrating" => Ok(Self::Migrating),
                "repairing" => Ok(Self::Repairing),
                "failed" => Ok(Self::Failed),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for InstanceState {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for InstanceState {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for InstanceState {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "The kind of an external IP address for an instance"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum IpKind {
        #[serde(rename = "ephemeral")]
        Ephemeral,
        #[serde(rename = "floating")]
        Floating,
    }

    impl From<&IpKind> for IpKind {
        fn from(value: &IpKind) -> Self {
            value.clone()
        }
    }

    impl ToString for IpKind {
        fn to_string(&self) -> String {
            match *self {
                Self::Ephemeral => "ephemeral".to_string(),
                Self::Floating => "floating".to_string(),
            }
        }
    }

    impl std::str::FromStr for IpKind {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "ephemeral" => Ok(Self::Ephemeral),
                "floating" => Ok(Self::Floating),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for IpKind {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IpKind {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IpKind {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(untagged)]
    pub enum IpNet {
        V4(Ipv4Net),
        V6(Ipv6Net),
    }

    impl From<&IpNet> for IpNet {
        fn from(value: &IpNet) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for IpNet {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if let Ok(v) = value.parse() {
                Ok(Self::V4(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::V6(v))
            } else {
                Err("string conversion failed for all variants")
            }
        }
    }

    impl std::convert::TryFrom<&str> for IpNet {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for IpNet {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for IpNet {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl ToString for IpNet {
        fn to_string(&self) -> String {
            match self {
                Self::V4(x) => x.to_string(),
                Self::V6(x) => x.to_string(),
            }
        }
    }

    #[doc = "Identity-related metadata that's included in nearly all public API objects"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IpPool {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&IpPool> for IpPool {
        fn from(value: &IpPool) -> Self {
            value.clone()
        }
    }

    impl IpPool {
        pub fn builder() -> builder::IpPool {
            builder::IpPool::default()
        }
    }

    #[doc = "Create-time parameters for an IP Pool.\n\nSee [`IpPool`](crate::external_api::views::IpPool)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IpPoolCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&IpPoolCreate> for IpPoolCreate {
        fn from(value: &IpPoolCreate) -> Self {
            value.clone()
        }
    }

    impl IpPoolCreate {
        pub fn builder() -> builder::IpPoolCreate {
            builder::IpPoolCreate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IpPoolRange {
        pub id: uuid::Uuid,
        pub range: IpRange,
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&IpPoolRange> for IpPoolRange {
        fn from(value: &IpPoolRange) -> Self {
            value.clone()
        }
    }

    impl IpPoolRange {
        pub fn builder() -> builder::IpPoolRange {
            builder::IpPoolRange::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IpPoolRangeResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<IpPoolRange>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&IpPoolRangeResultsPage> for IpPoolRangeResultsPage {
        fn from(value: &IpPoolRangeResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolRangeResultsPage {
        pub fn builder() -> builder::IpPoolRangeResultsPage {
            builder::IpPoolRangeResultsPage::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IpPoolResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<IpPool>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&IpPoolResultsPage> for IpPoolResultsPage {
        fn from(value: &IpPoolResultsPage) -> Self {
            value.clone()
        }
    }

    impl IpPoolResultsPage {
        pub fn builder() -> builder::IpPoolResultsPage {
            builder::IpPoolResultsPage::default()
        }
    }

    #[doc = "Parameters for updating an IP Pool"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct IpPoolUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&IpPoolUpdate> for IpPoolUpdate {
        fn from(value: &IpPoolUpdate) -> Self {
            value.clone()
        }
    }

    impl IpPoolUpdate {
        pub fn builder() -> builder::IpPoolUpdate {
            builder::IpPoolUpdate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(untagged)]
    pub enum IpRange {
        V4(Ipv4Range),
        V6(Ipv6Range),
    }

    impl From<&IpRange> for IpRange {
        fn from(value: &IpRange) -> Self {
            value.clone()
        }
    }

    #[doc = "An IPv4 subnet, including prefix and subnet mask"]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct Ipv4Net(String);
    impl std::ops::Deref for Ipv4Net {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv4Net> for String {
        fn from(value: Ipv4Net) -> Self {
            value.0
        }
    }

    impl From<&Ipv4Net> for Ipv4Net {
        fn from(value: &Ipv4Net) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Ipv4Net {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if regress :: Regex :: new ("^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([8-9]|1[0-9]|2[0-9]|3[0-2])$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/([8-9]|1[0-9]|2[0-9]|3[0-2])$\"") ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Ipv4Net {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Ipv4Net {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Ipv4Net {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Ipv4Net {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "A non-decreasing IPv4 address range, inclusive of both ends.\n\nThe first address must be less than or equal to the last address."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Ipv4Range {
        pub first: std::net::Ipv4Addr,
        pub last: std::net::Ipv4Addr,
    }

    impl From<&Ipv4Range> for Ipv4Range {
        fn from(value: &Ipv4Range) -> Self {
            value.clone()
        }
    }

    impl Ipv4Range {
        pub fn builder() -> builder::Ipv4Range {
            builder::Ipv4Range::default()
        }
    }

    #[doc = "An IPv6 subnet, including prefix and subnet mask"]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct Ipv6Net(String);
    impl std::ops::Deref for Ipv6Net {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Ipv6Net> for String {
        fn from(value: Ipv6Net) -> Self {
            value.0
        }
    }

    impl From<&Ipv6Net> for Ipv6Net {
        fn from(value: &Ipv6Net) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Ipv6Net {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if regress :: Regex :: new ("^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^([fF][dD])[0-9a-fA-F]{2}:(([0-9a-fA-F]{1,4}:){6}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,6}:)\\/([1-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8])$\"") ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Ipv6Net {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Ipv6Net {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Ipv6Net {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Ipv6Net {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "A non-decreasing IPv6 address range, inclusive of both ends.\n\nThe first address must be less than or equal to the last address."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Ipv6Range {
        pub first: std::net::Ipv6Addr,
        pub last: std::net::Ipv6Addr,
    }

    impl From<&Ipv6Range> for Ipv6Range {
        fn from(value: &Ipv6Range) -> Self {
            value.clone()
        }
    }

    impl Ipv6Range {
        pub fn builder() -> builder::Ipv6Range {
            builder::Ipv6Range::default()
        }
    }

    #[doc = "An inclusive-inclusive range of IP ports. The second port may be omitted to represent a single port"]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct L4PortRange(String);
    impl std::ops::Deref for L4PortRange {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<L4PortRange> for String {
        fn from(value: L4PortRange) -> Self {
            value.0
        }
    }

    impl From<&L4PortRange> for L4PortRange {
        fn from(value: &L4PortRange) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for L4PortRange {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if value.len() > 11usize {
                return Err("longer than 11 characters");
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters");
            }
            if regress::Regex::new("^[0-9]{1,5}(-[0-9]{1,5})?$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^[0-9]{1,5}(-[0-9]{1,5})?$\"");
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for L4PortRange {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for L4PortRange {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for L4PortRange {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for L4PortRange {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "A Media Access Control address, in EUI-48 format"]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct MacAddr(String);
    impl std::ops::Deref for MacAddr {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<MacAddr> for String {
        fn from(value: MacAddr) -> Self {
            value.0
        }
    }

    impl From<&MacAddr> for MacAddr {
        fn from(value: &MacAddr) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for MacAddr {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if value.len() > 17usize {
                return Err("longer than 17 characters");
            }
            if value.len() < 17usize {
                return Err("shorter than 17 characters");
            }
            if regress::Regex::new("^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$\"");
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for MacAddr {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for MacAddr {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for MacAddr {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for MacAddr {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "A `Measurement` is a timestamped datum from a single metric"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Measurement {
        pub datum: Datum,
        pub timestamp: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Measurement> for Measurement {
        fn from(value: &Measurement) -> Self {
            value.clone()
        }
    }

    impl Measurement {
        pub fn builder() -> builder::Measurement {
            builder::Measurement::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct MeasurementResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Measurement>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&MeasurementResultsPage> for MeasurementResultsPage {
        fn from(value: &MeasurementResultsPage) -> Self {
            value.clone()
        }
    }

    impl MeasurementResultsPage {
        pub fn builder() -> builder::MeasurementResultsPage {
            builder::MeasurementResultsPage::default()
        }
    }

    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct Name(String);
    impl std::ops::Deref for Name {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Name> for String {
        fn from(value: Name) -> Self {
            value.0
        }
    }

    impl From<&Name> for Name {
        fn from(value: &Name) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Name {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if value.len() > 63usize {
                return Err("longer than 63 characters");
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters");
            }
            if regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]*$\"") ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Name {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Name {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Name {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Name {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(untagged)]
    pub enum NameOrId {
        Id(uuid::Uuid),
        Name(Name),
    }

    impl From<&NameOrId> for NameOrId {
        fn from(value: &NameOrId) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for NameOrId {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if let Ok(v) = value.parse() {
                Ok(Self::Id(v))
            } else if let Ok(v) = value.parse() {
                Ok(Self::Name(v))
            } else {
                Err("string conversion failed for all variants")
            }
        }
    }

    impl std::convert::TryFrom<&str> for NameOrId {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NameOrId {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NameOrId {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl ToString for NameOrId {
        fn to_string(&self) -> String {
            match self {
                Self::Id(x) => x.to_string(),
                Self::Name(x) => x.to_string(),
            }
        }
    }

    #[doc = "Supported set of sort modes for scanning by name or id"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum NameOrIdSortMode {
        #[doc = "sort in increasing order of \"name\""]
        #[serde(rename = "name_ascending")]
        NameAscending,
        #[doc = "sort in decreasing order of \"name\""]
        #[serde(rename = "name_descending")]
        NameDescending,
        #[doc = "sort in increasing order of \"id\""]
        #[serde(rename = "id_ascending")]
        IdAscending,
    }

    impl From<&NameOrIdSortMode> for NameOrIdSortMode {
        fn from(value: &NameOrIdSortMode) -> Self {
            value.clone()
        }
    }

    impl ToString for NameOrIdSortMode {
        fn to_string(&self) -> String {
            match *self {
                Self::NameAscending => "name_ascending".to_string(),
                Self::NameDescending => "name_descending".to_string(),
                Self::IdAscending => "id_ascending".to_string(),
            }
        }
    }

    impl std::str::FromStr for NameOrIdSortMode {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                "name_descending" => Ok(Self::NameDescending),
                "id_ascending" => Ok(Self::IdAscending),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NameOrIdSortMode {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NameOrIdSortMode {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NameOrIdSortMode {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Supported set of sort modes for scanning by name only\n\nCurrently, we only support scanning in ascending order."]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum NameSortMode {
        #[doc = "sort in increasing order of \"name\""]
        #[serde(rename = "name_ascending")]
        NameAscending,
    }

    impl From<&NameSortMode> for NameSortMode {
        fn from(value: &NameSortMode) -> Self {
            value.clone()
        }
    }

    impl ToString for NameSortMode {
        fn to_string(&self) -> String {
            match *self {
                Self::NameAscending => "name_ascending".to_string(),
            }
        }
    }

    impl std::str::FromStr for NameSortMode {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "name_ascending" => Ok(Self::NameAscending),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for NameSortMode {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for NameSortMode {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for NameSortMode {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "A `NetworkInterface` represents a virtual network interface device."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct NetworkInterface {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "The Instance to which the interface belongs."]
        pub instance_id: uuid::Uuid,
        #[doc = "The IP address assigned to this interface."]
        pub ip: std::net::IpAddr,
        #[doc = "The MAC address assigned to this interface."]
        pub mac: MacAddr,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "True if this interface is the primary for the instance to which it's attached."]
        pub primary: bool,
        #[doc = "The subnet to which the interface belongs."]
        pub subnet_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC to which the interface belongs."]
        pub vpc_id: uuid::Uuid,
    }

    impl From<&NetworkInterface> for NetworkInterface {
        fn from(value: &NetworkInterface) -> Self {
            value.clone()
        }
    }

    impl NetworkInterface {
        pub fn builder() -> builder::NetworkInterface {
            builder::NetworkInterface::default()
        }
    }

    #[doc = "Create-time parameters for a [`NetworkInterface`](omicron_common::api::external::NetworkInterface)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct NetworkInterfaceCreate {
        pub description: String,
        #[doc = "The IP address for the interface. One will be auto-assigned if not provided."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ip: Option<std::net::IpAddr>,
        pub name: Name,
        #[doc = "The VPC Subnet in which to create the interface."]
        pub subnet_name: Name,
        #[doc = "The VPC in which to create the interface."]
        pub vpc_name: Name,
    }

    impl From<&NetworkInterfaceCreate> for NetworkInterfaceCreate {
        fn from(value: &NetworkInterfaceCreate) -> Self {
            value.clone()
        }
    }

    impl NetworkInterfaceCreate {
        pub fn builder() -> builder::NetworkInterfaceCreate {
            builder::NetworkInterfaceCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct NetworkInterfaceResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<NetworkInterface>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&NetworkInterfaceResultsPage> for NetworkInterfaceResultsPage {
        fn from(value: &NetworkInterfaceResultsPage) -> Self {
            value.clone()
        }
    }

    impl NetworkInterfaceResultsPage {
        pub fn builder() -> builder::NetworkInterfaceResultsPage {
            builder::NetworkInterfaceResultsPage::default()
        }
    }

    #[doc = "Parameters for updating a [`NetworkInterface`](omicron_common::api::external::NetworkInterface).\n\nNote that modifying IP addresses for an interface is not yet supported, a new interface must be created instead."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct NetworkInterfaceUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        #[doc = "Make a secondary interface the instance's primary interface.\n\nIf applied to a secondary interface, that interface will become the primary on the next reboot of the instance. Note that this may have implications for routing between instances, as the new primary interface will be on a distinct subnet from the previous primary interface.\n\nNote that this can only be used to select a new primary interface for an instance. Requests to change the primary interface into a secondary will return an error."]
        #[serde(default)]
        pub primary: bool,
    }

    impl From<&NetworkInterfaceUpdate> for NetworkInterfaceUpdate {
        fn from(value: &NetworkInterfaceUpdate) -> Self {
            value.clone()
        }
    }

    impl NetworkInterfaceUpdate {
        pub fn builder() -> builder::NetworkInterfaceUpdate {
            builder::NetworkInterfaceUpdate::default()
        }
    }

    #[doc = "Unique name for a saga [`Node`]\n\nEach node requires a string name that's unique within its DAG.  The name is used to identify its output.  Nodes that depend on a given node (either directly or indirectly) can access the node's output using its name."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct NodeName(pub String);
    impl std::ops::Deref for NodeName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<NodeName> for String {
        fn from(value: NodeName) -> Self {
            value.0
        }
    }

    impl From<&NodeName> for NodeName {
        fn from(value: &NodeName) -> Self {
            value.clone()
        }
    }

    impl From<String> for NodeName {
        fn from(value: String) -> Self {
            Self(value)
        }
    }

    impl std::str::FromStr for NodeName {
        type Err = std::convert::Infallible;
        fn from_str(value: &str) -> Result<Self, Self::Err> {
            Ok(Self(value.to_string()))
        }
    }

    impl ToString for NodeName {
        fn to_string(&self) -> String {
            self.0.to_string()
        }
    }

    #[doc = "Client view of an [`Organization`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Organization {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Organization> for Organization {
        fn from(value: &Organization) -> Self {
            value.clone()
        }
    }

    impl Organization {
        pub fn builder() -> builder::Organization {
            builder::Organization::default()
        }
    }

    #[doc = "Create-time parameters for an [`Organization`](crate::external_api::views::Organization)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct OrganizationCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&OrganizationCreate> for OrganizationCreate {
        fn from(value: &OrganizationCreate) -> Self {
            value.clone()
        }
    }

    impl OrganizationCreate {
        pub fn builder() -> builder::OrganizationCreate {
            builder::OrganizationCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct OrganizationResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Organization>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&OrganizationResultsPage> for OrganizationResultsPage {
        fn from(value: &OrganizationResultsPage) -> Self {
            value.clone()
        }
    }

    impl OrganizationResultsPage {
        pub fn builder() -> builder::OrganizationResultsPage {
            builder::OrganizationResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum OrganizationRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&OrganizationRole> for OrganizationRole {
        fn from(value: &OrganizationRole) -> Self {
            value.clone()
        }
    }

    impl ToString for OrganizationRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for OrganizationRole {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for OrganizationRole {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for OrganizationRole {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for OrganizationRole {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct OrganizationRolePolicy {
        #[doc = "Roles directly assigned on this resource"]
        pub role_assignments: Vec<OrganizationRoleRoleAssignment>,
    }

    impl From<&OrganizationRolePolicy> for OrganizationRolePolicy {
        fn from(value: &OrganizationRolePolicy) -> Self {
            value.clone()
        }
    }

    impl OrganizationRolePolicy {
        pub fn builder() -> builder::OrganizationRolePolicy {
            builder::OrganizationRolePolicy::default()
        }
    }

    #[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct OrganizationRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: OrganizationRole,
    }

    impl From<&OrganizationRoleRoleAssignment> for OrganizationRoleRoleAssignment {
        fn from(value: &OrganizationRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl OrganizationRoleRoleAssignment {
        pub fn builder() -> builder::OrganizationRoleRoleAssignment {
            builder::OrganizationRoleRoleAssignment::default()
        }
    }

    #[doc = "Updateable properties of an [`Organization`](crate::external_api::views::Organization)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct OrganizationUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&OrganizationUpdate> for OrganizationUpdate {
        fn from(value: &OrganizationUpdate) -> Self {
            value.clone()
        }
    }

    impl OrganizationUpdate {
        pub fn builder() -> builder::OrganizationUpdate {
            builder::OrganizationUpdate::default()
        }
    }

    #[doc = "Passwords may be subject to additional constraints."]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct Password(String);
    impl std::ops::Deref for Password {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<Password> for String {
        fn from(value: Password) -> Self {
            value.0
        }
    }

    impl From<&Password> for Password {
        fn from(value: &Password) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for Password {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if value.len() > 512usize {
                return Err("longer than 512 characters");
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for Password {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for Password {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for Password {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for Password {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "Client view of a [`PhysicalDisk`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct PhysicalDisk {
        pub disk_type: PhysicalDiskType,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub model: String,
        pub serial: String,
        #[doc = "The sled to which this disk is attached, if any."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub sled_id: Option<uuid::Uuid>,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub vendor: String,
    }

    impl From<&PhysicalDisk> for PhysicalDisk {
        fn from(value: &PhysicalDisk) -> Self {
            value.clone()
        }
    }

    impl PhysicalDisk {
        pub fn builder() -> builder::PhysicalDisk {
            builder::PhysicalDisk::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct PhysicalDiskResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<PhysicalDisk>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&PhysicalDiskResultsPage> for PhysicalDiskResultsPage {
        fn from(value: &PhysicalDiskResultsPage) -> Self {
            value.clone()
        }
    }

    impl PhysicalDiskResultsPage {
        pub fn builder() -> builder::PhysicalDiskResultsPage {
            builder::PhysicalDiskResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum PhysicalDiskType {
        #[serde(rename = "internal")]
        Internal,
        #[serde(rename = "external")]
        External,
    }

    impl From<&PhysicalDiskType> for PhysicalDiskType {
        fn from(value: &PhysicalDiskType) -> Self {
            value.clone()
        }
    }

    impl ToString for PhysicalDiskType {
        fn to_string(&self) -> String {
            match *self {
                Self::Internal => "internal".to_string(),
                Self::External => "external".to_string(),
            }
        }
    }

    impl std::str::FromStr for PhysicalDiskType {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "internal" => Ok(Self::Internal),
                "external" => Ok(Self::External),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for PhysicalDiskType {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for PhysicalDiskType {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for PhysicalDiskType {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a [`Project`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Project {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub organization_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Project> for Project {
        fn from(value: &Project) -> Self {
            value.clone()
        }
    }

    impl Project {
        pub fn builder() -> builder::Project {
            builder::Project::default()
        }
    }

    #[doc = "Create-time parameters for a [`Project`](crate::external_api::views::Project)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ProjectCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&ProjectCreate> for ProjectCreate {
        fn from(value: &ProjectCreate) -> Self {
            value.clone()
        }
    }

    impl ProjectCreate {
        pub fn builder() -> builder::ProjectCreate {
            builder::ProjectCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ProjectResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Project>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&ProjectResultsPage> for ProjectResultsPage {
        fn from(value: &ProjectResultsPage) -> Self {
            value.clone()
        }
    }

    impl ProjectResultsPage {
        pub fn builder() -> builder::ProjectResultsPage {
            builder::ProjectResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum ProjectRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&ProjectRole> for ProjectRole {
        fn from(value: &ProjectRole) -> Self {
            value.clone()
        }
    }

    impl ToString for ProjectRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for ProjectRole {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ProjectRole {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ProjectRole {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ProjectRole {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ProjectRolePolicy {
        #[doc = "Roles directly assigned on this resource"]
        pub role_assignments: Vec<ProjectRoleRoleAssignment>,
    }

    impl From<&ProjectRolePolicy> for ProjectRolePolicy {
        fn from(value: &ProjectRolePolicy) -> Self {
            value.clone()
        }
    }

    impl ProjectRolePolicy {
        pub fn builder() -> builder::ProjectRolePolicy {
            builder::ProjectRolePolicy::default()
        }
    }

    #[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ProjectRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: ProjectRole,
    }

    impl From<&ProjectRoleRoleAssignment> for ProjectRoleRoleAssignment {
        fn from(value: &ProjectRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl ProjectRoleRoleAssignment {
        pub fn builder() -> builder::ProjectRoleRoleAssignment {
            builder::ProjectRoleRoleAssignment::default()
        }
    }

    #[doc = "Updateable properties of a [`Project`](crate::external_api::views::Project)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct ProjectUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&ProjectUpdate> for ProjectUpdate {
        fn from(value: &ProjectUpdate) -> Self {
            value.clone()
        }
    }

    impl ProjectUpdate {
        pub fn builder() -> builder::ProjectUpdate {
            builder::ProjectUpdate::default()
        }
    }

    #[doc = "Client view of an [`Rack`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Rack {
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Rack> for Rack {
        fn from(value: &Rack) -> Self {
            value.clone()
        }
    }

    impl Rack {
        pub fn builder() -> builder::Rack {
            builder::Rack::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct RackResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Rack>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&RackResultsPage> for RackResultsPage {
        fn from(value: &RackResultsPage) -> Self {
            value.clone()
        }
    }

    impl RackResultsPage {
        pub fn builder() -> builder::RackResultsPage {
            builder::RackResultsPage::default()
        }
    }

    #[doc = "Client view of a [`Role`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Role {
        pub description: String,
        pub name: RoleName,
    }

    impl From<&Role> for Role {
        fn from(value: &Role) -> Self {
            value.clone()
        }
    }

    impl Role {
        pub fn builder() -> builder::Role {
            builder::Role::default()
        }
    }

    #[doc = "Role names consist of two string components separated by dot (\".\")."]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct RoleName(String);
    impl std::ops::Deref for RoleName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<RoleName> for String {
        fn from(value: RoleName) -> Self {
            value.0
        }
    }

    impl From<&RoleName> for RoleName {
        fn from(value: &RoleName) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for RoleName {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if value.len() > 63usize {
                return Err("longer than 63 characters");
            }
            if regress::Regex::new("[a-z-]+\\.[a-z-]+")
                .unwrap()
                .find(value)
                .is_none()
            {
                return Err("doesn't match pattern \"[a-z-]+\\.[a-z-]+\"");
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for RoleName {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RoleName {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RoleName {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for RoleName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct RoleResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Role>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&RoleResultsPage> for RoleResultsPage {
        fn from(value: &RoleResultsPage) -> Self {
            value.clone()
        }
    }

    impl RoleResultsPage {
        pub fn builder() -> builder::RoleResultsPage {
            builder::RoleResultsPage::default()
        }
    }

    #[doc = "A `RouteDestination` is used to match traffic with a routing rule, on the destination of that traffic.\n\nWhen traffic is to be sent to a destination that is within a given `RouteDestination`, the corresponding [`RouterRoute`] applies, and traffic will be forward to the [`RouteTarget`] for that rule."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteDestination {
        #[doc = "Route applies to traffic destined for a specific IP address"]
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        #[doc = "Route applies to traffic destined for a specific IP subnet"]
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
        #[doc = "Route applies to traffic destined for the given VPC."]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "Route applies to traffic"]
        #[serde(rename = "subnet")]
        Subnet(Name),
    }

    impl From<&RouteDestination> for RouteDestination {
        fn from(value: &RouteDestination) -> Self {
            value.clone()
        }
    }

    #[doc = "A `RouteTarget` describes the possible locations that traffic matching a route destination can be sent."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "value")]
    pub enum RouteTarget {
        #[doc = "Forward traffic to a particular IP address."]
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        #[doc = "Forward traffic to a VPC"]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "Forward traffic to a VPC Subnet"]
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[doc = "Forward traffic to a specific instance"]
        #[serde(rename = "instance")]
        Instance(Name),
        #[doc = "Forward traffic to an internet gateway"]
        #[serde(rename = "internet_gateway")]
        InternetGateway(Name),
    }

    impl From<&RouteTarget> for RouteTarget {
        fn from(value: &RouteTarget) -> Self {
            value.clone()
        }
    }

    #[doc = "A route defines a rule that governs where traffic should be sent based on its destination."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct RouterRoute {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub destination: RouteDestination,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "Describes the kind of router. Set at creation. `read-only`"]
        pub kind: RouterRouteKind,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub target: RouteTarget,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC Router to which the route belongs."]
        pub vpc_router_id: uuid::Uuid,
    }

    impl From<&RouterRoute> for RouterRoute {
        fn from(value: &RouterRoute) -> Self {
            value.clone()
        }
    }

    impl RouterRoute {
        pub fn builder() -> builder::RouterRoute {
            builder::RouterRoute::default()
        }
    }

    #[doc = "Create-time parameters for a [`omicron_common::api::external::RouterRoute`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct RouterRouteCreate {
        pub description: String,
        pub destination: RouteDestination,
        pub name: Name,
        pub target: RouteTarget,
    }

    impl From<&RouterRouteCreate> for RouterRouteCreate {
        fn from(value: &RouterRouteCreate) -> Self {
            value.clone()
        }
    }

    impl RouterRouteCreate {
        pub fn builder() -> builder::RouterRouteCreate {
            builder::RouterRouteCreate::default()
        }
    }

    #[doc = "The classification of a [`RouterRoute`] as defined by the system. The kind determines certain attributes such as if the route is modifiable and describes how or where the route was created.\n\nSee [RFD-21](https://rfd.shared.oxide.computer/rfd/0021#concept-router) for more context"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum RouterRouteKind {
        #[doc = "Determines the default destination of traffic, such as whether it goes to the internet or not.\n\n`Destination: An Internet Gateway` `Modifiable: true`"]
        #[serde(rename = "default")]
        Default,
        #[doc = "Automatically added for each VPC Subnet in the VPC\n\n`Destination: A VPC Subnet` `Modifiable: false`"]
        #[serde(rename = "vpc_subnet")]
        VpcSubnet,
        #[doc = "Automatically added when VPC peering is established\n\n`Destination: A different VPC` `Modifiable: false`"]
        #[serde(rename = "vpc_peering")]
        VpcPeering,
        #[doc = "Created by a user See [`RouteTarget`]\n\n`Destination: User defined` `Modifiable: true`"]
        #[serde(rename = "custom")]
        Custom,
    }

    impl From<&RouterRouteKind> for RouterRouteKind {
        fn from(value: &RouterRouteKind) -> Self {
            value.clone()
        }
    }

    impl ToString for RouterRouteKind {
        fn to_string(&self) -> String {
            match *self {
                Self::Default => "default".to_string(),
                Self::VpcSubnet => "vpc_subnet".to_string(),
                Self::VpcPeering => "vpc_peering".to_string(),
                Self::Custom => "custom".to_string(),
            }
        }
    }

    impl std::str::FromStr for RouterRouteKind {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "default" => Ok(Self::Default),
                "vpc_subnet" => Ok(Self::VpcSubnet),
                "vpc_peering" => Ok(Self::VpcPeering),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for RouterRouteKind {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for RouterRouteKind {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for RouterRouteKind {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct RouterRouteResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<RouterRoute>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&RouterRouteResultsPage> for RouterRouteResultsPage {
        fn from(value: &RouterRouteResultsPage) -> Self {
            value.clone()
        }
    }

    impl RouterRouteResultsPage {
        pub fn builder() -> builder::RouterRouteResultsPage {
            builder::RouterRouteResultsPage::default()
        }
    }

    #[doc = "Updateable properties of a [`omicron_common::api::external::RouterRoute`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct RouterRouteUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        pub destination: RouteDestination,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
        pub target: RouteTarget,
    }

    impl From<&RouterRouteUpdate> for RouterRouteUpdate {
        fn from(value: &RouterRouteUpdate) -> Self {
            value.clone()
        }
    }

    impl RouterRouteUpdate {
        pub fn builder() -> builder::RouterRouteUpdate {
            builder::RouterRouteUpdate::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Saga {
        pub id: uuid::Uuid,
        pub state: SagaState,
    }

    impl From<&Saga> for Saga {
        fn from(value: &Saga) -> Self {
            value.clone()
        }
    }

    impl Saga {
        pub fn builder() -> builder::Saga {
            builder::Saga::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "error")]
    pub enum SagaErrorInfo {
        #[serde(rename = "action_failed")]
        ActionFailed { source_error: serde_json::Value },
        #[serde(rename = "deserialize_failed")]
        DeserializeFailed { message: String },
        #[serde(rename = "injected_error")]
        InjectedError,
        #[serde(rename = "serialize_failed")]
        SerializeFailed { message: String },
        #[serde(rename = "subsaga_create_failed")]
        SubsagaCreateFailed { message: String },
    }

    impl From<&SagaErrorInfo> for SagaErrorInfo {
        fn from(value: &SagaErrorInfo) -> Self {
            value.clone()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SagaResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Saga>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SagaResultsPage> for SagaResultsPage {
        fn from(value: &SagaResultsPage) -> Self {
            value.clone()
        }
    }

    impl SagaResultsPage {
        pub fn builder() -> builder::SagaResultsPage {
            builder::SagaResultsPage::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "state")]
    pub enum SagaState {
        #[serde(rename = "running")]
        Running,
        #[serde(rename = "succeeded")]
        Succeeded,
        #[serde(rename = "failed")]
        Failed {
            error_info: SagaErrorInfo,
            error_node_name: NodeName,
        },
    }

    impl From<&SagaState> for SagaState {
        fn from(value: &SagaState) -> Self {
            value.clone()
        }
    }

    #[doc = "Identity-related metadata that's included in nearly all public API objects"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SamlIdentityProvider {
        #[doc = "service provider endpoint where the response will be sent"]
        pub acs_url: String,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "idp's entity id"]
        pub idp_entity_id: String,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "optional request signing public certificate (base64 encoded der file)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub public_cert: Option<String>,
        #[doc = "service provider endpoint where the idp should send log out requests"]
        pub slo_url: String,
        #[doc = "sp's client id"]
        pub sp_client_id: String,
        #[doc = "customer's technical contact for saml configuration"]
        pub technical_contact_email: String,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&SamlIdentityProvider> for SamlIdentityProvider {
        fn from(value: &SamlIdentityProvider) -> Self {
            value.clone()
        }
    }

    impl SamlIdentityProvider {
        pub fn builder() -> builder::SamlIdentityProvider {
            builder::SamlIdentityProvider::default()
        }
    }

    #[doc = "Create-time identity-related parameters"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SamlIdentityProviderCreate {
        #[doc = "service provider endpoint where the response will be sent"]
        pub acs_url: String,
        pub description: String,
        #[doc = "If set, SAML attributes with this name will be considered to denote a user's group membership, where the attribute value(s) should be a comma-separated list of group names."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub group_attribute_name: Option<String>,
        #[doc = "idp's entity id"]
        pub idp_entity_id: String,
        #[doc = "the source of an identity provider metadata descriptor"]
        pub idp_metadata_source: IdpMetadataSource,
        pub name: Name,
        #[doc = "optional request signing key pair"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub signing_keypair: Option<DerEncodedKeyPair>,
        #[doc = "service provider endpoint where the idp should send log out requests"]
        pub slo_url: String,
        #[doc = "sp's client id"]
        pub sp_client_id: String,
        #[doc = "customer's technical contact for saml configuration"]
        pub technical_contact_email: String,
    }

    impl From<&SamlIdentityProviderCreate> for SamlIdentityProviderCreate {
        fn from(value: &SamlIdentityProviderCreate) -> Self {
            value.clone()
        }
    }

    impl SamlIdentityProviderCreate {
        pub fn builder() -> builder::SamlIdentityProviderCreate {
            builder::SamlIdentityProviderCreate::default()
        }
    }

    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct SemverVersion(String);
    impl std::ops::Deref for SemverVersion {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<SemverVersion> for String {
        fn from(value: SemverVersion) -> Self {
            value.0
        }
    }

    impl From<&SemverVersion> for SemverVersion {
        fn from(value: &SemverVersion) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for SemverVersion {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if regress :: Regex :: new ("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\"") ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for SemverVersion {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SemverVersion {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SemverVersion {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for SemverVersion {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "The service intended to use this certificate."]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum ServiceUsingCertificate {
        #[doc = "This certificate is intended for access to the external API."]
        #[serde(rename = "external_api")]
        ExternalApi,
    }

    impl From<&ServiceUsingCertificate> for ServiceUsingCertificate {
        fn from(value: &ServiceUsingCertificate) -> Self {
            value.clone()
        }
    }

    impl ToString for ServiceUsingCertificate {
        fn to_string(&self) -> String {
            match *self {
                Self::ExternalApi => "external_api".to_string(),
            }
        }
    }

    impl std::str::FromStr for ServiceUsingCertificate {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "external_api" => Ok(Self::ExternalApi),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for ServiceUsingCertificate {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for ServiceUsingCertificate {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for ServiceUsingCertificate {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a ['Silo']"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Silo {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "A silo where discoverable is false can be retrieved only by its id - it will not be part of the \"list all silos\" output."]
        pub discoverable: bool,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "How users and groups are managed in this Silo"]
        pub identity_mode: SiloIdentityMode,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Silo> for Silo {
        fn from(value: &Silo) -> Self {
            value.clone()
        }
    }

    impl Silo {
        pub fn builder() -> builder::Silo {
            builder::Silo::default()
        }
    }

    #[doc = "Create-time parameters for a [`Silo`](crate::external_api::views::Silo)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SiloCreate {
        #[doc = "If set, this group will be created during Silo creation and granted the \"Silo Admin\" role. Identity providers can assert that users belong to this group and those users can log in and further initialize the Silo.\n\nNote that if configuring a SAML based identity provider, group_attribute_name must be set for users to be considered part of a group. See [`SamlIdentityProviderCreate`] for more information."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub admin_group_name: Option<String>,
        pub description: String,
        pub discoverable: bool,
        pub identity_mode: SiloIdentityMode,
        pub name: Name,
    }

    impl From<&SiloCreate> for SiloCreate {
        fn from(value: &SiloCreate) -> Self {
            value.clone()
        }
    }

    impl SiloCreate {
        pub fn builder() -> builder::SiloCreate {
            builder::SiloCreate::default()
        }
    }

    #[doc = "Describes how identities are managed and users are authenticated in this Silo"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum SiloIdentityMode {
        #[doc = "Users are authenticated with SAML using an external authentication provider.  The system updates information about users and groups only during successful authentication (i.e,. \"JIT provisioning\" of users and groups)."]
        #[serde(rename = "saml_jit")]
        SamlJit,
        #[doc = "The system is the source of truth about users.  There is no linkage to an external authentication provider or identity provider."]
        #[serde(rename = "local_only")]
        LocalOnly,
    }

    impl From<&SiloIdentityMode> for SiloIdentityMode {
        fn from(value: &SiloIdentityMode) -> Self {
            value.clone()
        }
    }

    impl ToString for SiloIdentityMode {
        fn to_string(&self) -> String {
            match *self {
                Self::SamlJit => "saml_jit".to_string(),
                Self::LocalOnly => "local_only".to_string(),
            }
        }
    }

    impl std::str::FromStr for SiloIdentityMode {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "saml_jit" => Ok(Self::SamlJit),
                "local_only" => Ok(Self::LocalOnly),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SiloIdentityMode {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SiloIdentityMode {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SiloIdentityMode {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SiloResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Silo>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SiloResultsPage> for SiloResultsPage {
        fn from(value: &SiloResultsPage) -> Self {
            value.clone()
        }
    }

    impl SiloResultsPage {
        pub fn builder() -> builder::SiloResultsPage {
            builder::SiloResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum SiloRole {
        #[serde(rename = "admin")]
        Admin,
        #[serde(rename = "collaborator")]
        Collaborator,
        #[serde(rename = "viewer")]
        Viewer,
    }

    impl From<&SiloRole> for SiloRole {
        fn from(value: &SiloRole) -> Self {
            value.clone()
        }
    }

    impl ToString for SiloRole {
        fn to_string(&self) -> String {
            match *self {
                Self::Admin => "admin".to_string(),
                Self::Collaborator => "collaborator".to_string(),
                Self::Viewer => "viewer".to_string(),
            }
        }
    }

    impl std::str::FromStr for SiloRole {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "admin" => Ok(Self::Admin),
                "collaborator" => Ok(Self::Collaborator),
                "viewer" => Ok(Self::Viewer),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SiloRole {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SiloRole {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SiloRole {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a [`Policy`], which describes how this resource may be accessed\n\nNote that the Policy only describes access granted explicitly for this resource.  The policies of parent resources can also cause a user to have access to this resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SiloRolePolicy {
        #[doc = "Roles directly assigned on this resource"]
        pub role_assignments: Vec<SiloRoleRoleAssignment>,
    }

    impl From<&SiloRolePolicy> for SiloRolePolicy {
        fn from(value: &SiloRolePolicy) -> Self {
            value.clone()
        }
    }

    impl SiloRolePolicy {
        pub fn builder() -> builder::SiloRolePolicy {
            builder::SiloRolePolicy::default()
        }
    }

    #[doc = "Describes the assignment of a particular role on a particular resource to a particular identity (user, group, etc.)\n\nThe resource is not part of this structure.  Rather, [`RoleAssignment`]s are put into a [`Policy`] and that Policy is applied to a particular resource."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SiloRoleRoleAssignment {
        pub identity_id: uuid::Uuid,
        pub identity_type: IdentityType,
        pub role_name: SiloRole,
    }

    impl From<&SiloRoleRoleAssignment> for SiloRoleRoleAssignment {
        fn from(value: &SiloRoleRoleAssignment) -> Self {
            value.clone()
        }
    }

    impl SiloRoleRoleAssignment {
        pub fn builder() -> builder::SiloRoleRoleAssignment {
            builder::SiloRoleRoleAssignment::default()
        }
    }

    #[doc = "Client view of a [`Sled`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Sled {
        pub baseboard: Baseboard,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub rack_id: uuid::Uuid,
        pub service_address: String,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Sled> for Sled {
        fn from(value: &Sled) -> Self {
            value.clone()
        }
    }

    impl Sled {
        pub fn builder() -> builder::Sled {
            builder::Sled::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SledResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Sled>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SledResultsPage> for SledResultsPage {
        fn from(value: &SledResultsPage) -> Self {
            value.clone()
        }
    }

    impl SledResultsPage {
        pub fn builder() -> builder::SledResultsPage {
            builder::SledResultsPage::default()
        }
    }

    #[doc = "Client view of a Snapshot"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Snapshot {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        pub disk_id: uuid::Uuid,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        pub project_id: uuid::Uuid,
        pub size: ByteCount,
        pub state: SnapshotState,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Snapshot> for Snapshot {
        fn from(value: &Snapshot) -> Self {
            value.clone()
        }
    }

    impl Snapshot {
        pub fn builder() -> builder::Snapshot {
            builder::Snapshot::default()
        }
    }

    #[doc = "Create-time parameters for a [`Snapshot`](crate::external_api::views::Snapshot)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SnapshotCreate {
        pub description: String,
        #[doc = "The name of the disk to be snapshotted"]
        pub disk: Name,
        pub name: Name,
    }

    impl From<&SnapshotCreate> for SnapshotCreate {
        fn from(value: &SnapshotCreate) -> Self {
            value.clone()
        }
    }

    impl SnapshotCreate {
        pub fn builder() -> builder::SnapshotCreate {
            builder::SnapshotCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SnapshotResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Snapshot>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SnapshotResultsPage> for SnapshotResultsPage {
        fn from(value: &SnapshotResultsPage) -> Self {
            value.clone()
        }
    }

    impl SnapshotResultsPage {
        pub fn builder() -> builder::SnapshotResultsPage {
            builder::SnapshotResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum SnapshotState {
        #[serde(rename = "creating")]
        Creating,
        #[serde(rename = "ready")]
        Ready,
        #[serde(rename = "faulted")]
        Faulted,
        #[serde(rename = "destroyed")]
        Destroyed,
    }

    impl From<&SnapshotState> for SnapshotState {
        fn from(value: &SnapshotState) -> Self {
            value.clone()
        }
    }

    impl ToString for SnapshotState {
        fn to_string(&self) -> String {
            match *self {
                Self::Creating => "creating".to_string(),
                Self::Ready => "ready".to_string(),
                Self::Faulted => "faulted".to_string(),
                Self::Destroyed => "destroyed".to_string(),
            }
        }
    }

    impl std::str::FromStr for SnapshotState {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "creating" => Ok(Self::Creating),
                "ready" => Ok(Self::Ready),
                "faulted" => Ok(Self::Faulted),
                "destroyed" => Ok(Self::Destroyed),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SnapshotState {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SnapshotState {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SnapshotState {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SpoofLoginBody {
        pub username: String,
    }

    impl From<&SpoofLoginBody> for SpoofLoginBody {
        fn from(value: &SpoofLoginBody) -> Self {
            value.clone()
        }
    }

    impl SpoofLoginBody {
        pub fn builder() -> builder::SpoofLoginBody {
            builder::SpoofLoginBody::default()
        }
    }

    #[doc = "Client view of a [`SshKey`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SshKey {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "SSH public key, e.g., `\"ssh-ed25519 AAAAC3NzaC...\"`"]
        pub public_key: String,
        #[doc = "The user to whom this key belongs"]
        pub silo_user_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&SshKey> for SshKey {
        fn from(value: &SshKey) -> Self {
            value.clone()
        }
    }

    impl SshKey {
        pub fn builder() -> builder::SshKey {
            builder::SshKey::default()
        }
    }

    #[doc = "Create-time parameters for an [`SshKey`](crate::external_api::views::SshKey)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SshKeyCreate {
        pub description: String,
        pub name: Name,
        #[doc = "SSH public key, e.g., `\"ssh-ed25519 AAAAC3NzaC...\"`"]
        pub public_key: String,
    }

    impl From<&SshKeyCreate> for SshKeyCreate {
        fn from(value: &SshKeyCreate) -> Self {
            value.clone()
        }
    }

    impl SshKeyCreate {
        pub fn builder() -> builder::SshKeyCreate {
            builder::SshKeyCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SshKeyResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<SshKey>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SshKeyResultsPage> for SshKeyResultsPage {
        fn from(value: &SshKeyResultsPage) -> Self {
            value.clone()
        }
    }

    impl SshKeyResultsPage {
        pub fn builder() -> builder::SshKeyResultsPage {
            builder::SshKeyResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum SystemMetricName {
        #[serde(rename = "virtual_disk_space_provisioned")]
        VirtualDiskSpaceProvisioned,
        #[serde(rename = "cpus_provisioned")]
        CpusProvisioned,
        #[serde(rename = "ram_provisioned")]
        RamProvisioned,
    }

    impl From<&SystemMetricName> for SystemMetricName {
        fn from(value: &SystemMetricName) -> Self {
            value.clone()
        }
    }

    impl ToString for SystemMetricName {
        fn to_string(&self) -> String {
            match *self {
                Self::VirtualDiskSpaceProvisioned => "virtual_disk_space_provisioned".to_string(),
                Self::CpusProvisioned => "cpus_provisioned".to_string(),
                Self::RamProvisioned => "ram_provisioned".to_string(),
            }
        }
    }

    impl std::str::FromStr for SystemMetricName {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "virtual_disk_space_provisioned" => Ok(Self::VirtualDiskSpaceProvisioned),
                "cpus_provisioned" => Ok(Self::CpusProvisioned),
                "ram_provisioned" => Ok(Self::RamProvisioned),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for SystemMetricName {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for SystemMetricName {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for SystemMetricName {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Identity-related metadata that's included in \"asset\" public API objects (which generally have no name or description)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SystemUpdate {
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&SystemUpdate> for SystemUpdate {
        fn from(value: &SystemUpdate) -> Self {
            value.clone()
        }
    }

    impl SystemUpdate {
        pub fn builder() -> builder::SystemUpdate {
            builder::SystemUpdate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SystemUpdateResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<SystemUpdate>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&SystemUpdateResultsPage> for SystemUpdateResultsPage {
        fn from(value: &SystemUpdateResultsPage) -> Self {
            value.clone()
        }
    }

    impl SystemUpdateResultsPage {
        pub fn builder() -> builder::SystemUpdateResultsPage {
            builder::SystemUpdateResultsPage::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SystemUpdateStart {
        pub version: SemverVersion,
    }

    impl From<&SystemUpdateStart> for SystemUpdateStart {
        fn from(value: &SystemUpdateStart) -> Self {
            value.clone()
        }
    }

    impl SystemUpdateStart {
        pub fn builder() -> builder::SystemUpdateStart {
            builder::SystemUpdateStart::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct SystemVersion {
        pub status: UpdateStatus,
        pub version_range: VersionRange,
    }

    impl From<&SystemVersion> for SystemVersion {
        fn from(value: &SystemVersion) -> Self {
            value.clone()
        }
    }

    impl SystemVersion {
        pub fn builder() -> builder::SystemVersion {
            builder::SystemVersion::default()
        }
    }

    #[doc = "Names are constructed by concatenating the target and metric names with ':'. Target and metric names must be lowercase alphanumeric characters with '_' separating words."]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct TimeseriesName(String);
    impl std::ops::Deref for TimeseriesName {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<TimeseriesName> for String {
        fn from(value: TimeseriesName) -> Self {
            value.0
        }
    }

    impl From<&TimeseriesName> for TimeseriesName {
        fn from(value: &TimeseriesName) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for TimeseriesName {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if regress::Regex::new(
                "(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)",
            )
            .unwrap()
            .find(value)
            .is_none()
            {
                return Err ("doesn't match pattern \"(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*):(([a-z]+[a-z0-9]*)(_([a-z0-9]+))*)\"") ;
            }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for TimeseriesName {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for TimeseriesName {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for TimeseriesName {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for TimeseriesName {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "The schema for a timeseries.\n\nThis includes the name of the timeseries, as well as the datum type of its metric and the schema for each field."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct TimeseriesSchema {
        pub created: chrono::DateTime<chrono::offset::Utc>,
        pub datum_type: DatumType,
        pub field_schema: Vec<FieldSchema>,
        pub timeseries_name: TimeseriesName,
    }

    impl From<&TimeseriesSchema> for TimeseriesSchema {
        fn from(value: &TimeseriesSchema) -> Self {
            value.clone()
        }
    }

    impl TimeseriesSchema {
        pub fn builder() -> builder::TimeseriesSchema {
            builder::TimeseriesSchema::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct TimeseriesSchemaResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<TimeseriesSchema>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&TimeseriesSchemaResultsPage> for TimeseriesSchemaResultsPage {
        fn from(value: &TimeseriesSchemaResultsPage) -> Self {
            value.clone()
        }
    }

    impl TimeseriesSchemaResultsPage {
        pub fn builder() -> builder::TimeseriesSchemaResultsPage {
            builder::TimeseriesSchemaResultsPage::default()
        }
    }

    #[doc = "Identity-related metadata that's included in \"asset\" public API objects (which generally have no name or description)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UpdateDeployment {
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub status: UpdateStatus,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&UpdateDeployment> for UpdateDeployment {
        fn from(value: &UpdateDeployment) -> Self {
            value.clone()
        }
    }

    impl UpdateDeployment {
        pub fn builder() -> builder::UpdateDeployment {
            builder::UpdateDeployment::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UpdateDeploymentResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<UpdateDeployment>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UpdateDeploymentResultsPage> for UpdateDeploymentResultsPage {
        fn from(value: &UpdateDeploymentResultsPage) -> Self {
            value.clone()
        }
    }

    impl UpdateDeploymentResultsPage {
        pub fn builder() -> builder::UpdateDeploymentResultsPage {
            builder::UpdateDeploymentResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    #[serde(tag = "status")]
    pub enum UpdateStatus {
        #[serde(rename = "updating")]
        Updating,
        #[serde(rename = "steady")]
        Steady,
    }

    impl From<&UpdateStatus> for UpdateStatus {
        fn from(value: &UpdateStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for UpdateStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::Updating => "updating".to_string(),
                Self::Steady => "steady".to_string(),
            }
        }
    }

    impl std::str::FromStr for UpdateStatus {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "updating" => Ok(Self::Updating),
                "steady" => Ok(Self::Steady),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UpdateStatus {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UpdateStatus {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UpdateStatus {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Identity-related metadata that's included in \"asset\" public API objects (which generally have no name or description)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UpdateableComponent {
        pub component_type: UpdateableComponentType,
        pub device_id: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub status: UpdateStatus,
        pub system_version: SemverVersion,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        pub version: SemverVersion,
    }

    impl From<&UpdateableComponent> for UpdateableComponent {
        fn from(value: &UpdateableComponent) -> Self {
            value.clone()
        }
    }

    impl UpdateableComponent {
        pub fn builder() -> builder::UpdateableComponent {
            builder::UpdateableComponent::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UpdateableComponentResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<UpdateableComponent>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UpdateableComponentResultsPage> for UpdateableComponentResultsPage {
        fn from(value: &UpdateableComponentResultsPage) -> Self {
            value.clone()
        }
    }

    impl UpdateableComponentResultsPage {
        pub fn builder() -> builder::UpdateableComponentResultsPage {
            builder::UpdateableComponentResultsPage::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum UpdateableComponentType {
        #[serde(rename = "bootloader_for_rot")]
        BootloaderForRot,
        #[serde(rename = "bootloader_for_sp")]
        BootloaderForSp,
        #[serde(rename = "bootloader_for_host_proc")]
        BootloaderForHostProc,
        #[serde(rename = "hubris_for_psc_rot")]
        HubrisForPscRot,
        #[serde(rename = "hubris_for_psc_sp")]
        HubrisForPscSp,
        #[serde(rename = "hubris_for_sidecar_rot")]
        HubrisForSidecarRot,
        #[serde(rename = "hubris_for_sidecar_sp")]
        HubrisForSidecarSp,
        #[serde(rename = "hubris_for_gimlet_rot")]
        HubrisForGimletRot,
        #[serde(rename = "hubris_for_gimlet_sp")]
        HubrisForGimletSp,
        #[serde(rename = "helios_host_phase1")]
        HeliosHostPhase1,
        #[serde(rename = "helios_host_phase2")]
        HeliosHostPhase2,
        #[serde(rename = "host_omicron")]
        HostOmicron,
    }

    impl From<&UpdateableComponentType> for UpdateableComponentType {
        fn from(value: &UpdateableComponentType) -> Self {
            value.clone()
        }
    }

    impl ToString for UpdateableComponentType {
        fn to_string(&self) -> String {
            match *self {
                Self::BootloaderForRot => "bootloader_for_rot".to_string(),
                Self::BootloaderForSp => "bootloader_for_sp".to_string(),
                Self::BootloaderForHostProc => "bootloader_for_host_proc".to_string(),
                Self::HubrisForPscRot => "hubris_for_psc_rot".to_string(),
                Self::HubrisForPscSp => "hubris_for_psc_sp".to_string(),
                Self::HubrisForSidecarRot => "hubris_for_sidecar_rot".to_string(),
                Self::HubrisForSidecarSp => "hubris_for_sidecar_sp".to_string(),
                Self::HubrisForGimletRot => "hubris_for_gimlet_rot".to_string(),
                Self::HubrisForGimletSp => "hubris_for_gimlet_sp".to_string(),
                Self::HeliosHostPhase1 => "helios_host_phase1".to_string(),
                Self::HeliosHostPhase2 => "helios_host_phase2".to_string(),
                Self::HostOmicron => "host_omicron".to_string(),
            }
        }
    }

    impl std::str::FromStr for UpdateableComponentType {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "bootloader_for_rot" => Ok(Self::BootloaderForRot),
                "bootloader_for_sp" => Ok(Self::BootloaderForSp),
                "bootloader_for_host_proc" => Ok(Self::BootloaderForHostProc),
                "hubris_for_psc_rot" => Ok(Self::HubrisForPscRot),
                "hubris_for_psc_sp" => Ok(Self::HubrisForPscSp),
                "hubris_for_sidecar_rot" => Ok(Self::HubrisForSidecarRot),
                "hubris_for_sidecar_sp" => Ok(Self::HubrisForSidecarSp),
                "hubris_for_gimlet_rot" => Ok(Self::HubrisForGimletRot),
                "hubris_for_gimlet_sp" => Ok(Self::HubrisForGimletSp),
                "helios_host_phase1" => Ok(Self::HeliosHostPhase1),
                "helios_host_phase2" => Ok(Self::HeliosHostPhase2),
                "host_omicron" => Ok(Self::HostOmicron),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for UpdateableComponentType {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UpdateableComponentType {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UpdateableComponentType {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Client view of a [`User`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct User {
        #[doc = "Human-readable name that can identify the user"]
        pub display_name: String,
        pub id: uuid::Uuid,
        #[doc = "Uuid of the silo to which this user belongs"]
        pub silo_id: uuid::Uuid,
    }

    impl From<&User> for User {
        fn from(value: &User) -> Self {
            value.clone()
        }
    }

    impl User {
        pub fn builder() -> builder::User {
            builder::User::default()
        }
    }

    #[doc = "Client view of a [`UserBuiltin`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UserBuiltin {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&UserBuiltin> for UserBuiltin {
        fn from(value: &UserBuiltin) -> Self {
            value.clone()
        }
    }

    impl UserBuiltin {
        pub fn builder() -> builder::UserBuiltin {
            builder::UserBuiltin::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UserBuiltinResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<UserBuiltin>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UserBuiltinResultsPage> for UserBuiltinResultsPage {
        fn from(value: &UserBuiltinResultsPage) -> Self {
            value.clone()
        }
    }

    impl UserBuiltinResultsPage {
        pub fn builder() -> builder::UserBuiltinResultsPage {
            builder::UserBuiltinResultsPage::default()
        }
    }

    #[doc = "Create-time parameters for a [`User`](crate::external_api::views::User)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UserCreate {
        #[doc = "username used to log in"]
        pub external_id: UserId,
        #[doc = "password used to log in"]
        pub password: UserPassword,
    }

    impl From<&UserCreate> for UserCreate {
        fn from(value: &UserCreate) -> Self {
            value.clone()
        }
    }

    impl UserCreate {
        pub fn builder() -> builder::UserCreate {
            builder::UserCreate::default()
        }
    }

    #[doc = "Names must begin with a lower case ASCII letter, be composed exclusively of lowercase ASCII, uppercase ASCII, numbers, and '-', and may not end with a '-'. Names cannot be a UUID though they may contain a UUID."]
    #[derive(Clone, Debug, Serialize, schemars :: JsonSchema)]
    pub struct UserId(String);
    impl std::ops::Deref for UserId {
        type Target = String;
        fn deref(&self) -> &String {
            &self.0
        }
    }

    impl From<UserId> for String {
        fn from(value: UserId) -> Self {
            value.0
        }
    }

    impl From<&UserId> for UserId {
        fn from(value: &UserId) -> Self {
            value.clone()
        }
    }

    impl std::str::FromStr for UserId {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            if value.len() > 63usize {
                return Err("longer than 63 characters");
            }
            if value.len() < 1usize {
                return Err("shorter than 1 characters");
            }
            if regress :: Regex :: new ("^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]*$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(?![0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$)^[a-z][a-z0-9-]*[a-zA-Z0-9]*$\"") ; }
            Ok(Self(value.to_string()))
        }
    }

    impl std::convert::TryFrom<&str> for UserId {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for UserId {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for UserId {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl<'de> serde::Deserialize<'de> for UserId {
        fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            String::deserialize(deserializer)?
                .parse()
                .map_err(|e: &'static str| <D::Error as serde::de::Error>::custom(e.to_string()))
        }
    }

    #[doc = "Parameters for setting a user's password"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "user_password_value", content = "details")]
    pub enum UserPassword {
        #[doc = "Sets the user's password to the provided value"]
        #[serde(rename = "password")]
        Password(Password),
        #[serde(rename = "invalid_password")]
        InvalidPassword,
    }

    impl From<&UserPassword> for UserPassword {
        fn from(value: &UserPassword) -> Self {
            value.clone()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UserResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<User>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&UserResultsPage> for UserResultsPage {
        fn from(value: &UserResultsPage) -> Self {
            value.clone()
        }
    }

    impl UserResultsPage {
        pub fn builder() -> builder::UserResultsPage {
            builder::UserResultsPage::default()
        }
    }

    #[doc = "Credentials for local user login"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct UsernamePasswordCredentials {
        pub password: Password,
        pub username: UserId,
    }

    impl From<&UsernamePasswordCredentials> for UsernamePasswordCredentials {
        fn from(value: &UsernamePasswordCredentials) -> Self {
            value.clone()
        }
    }

    impl UsernamePasswordCredentials {
        pub fn builder() -> builder::UsernamePasswordCredentials {
            builder::UsernamePasswordCredentials::default()
        }
    }

    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VersionRange {
        pub high: SemverVersion,
        pub low: SemverVersion,
    }

    impl From<&VersionRange> for VersionRange {
        fn from(value: &VersionRange) -> Self {
            value.clone()
        }
    }

    impl VersionRange {
        pub fn builder() -> builder::VersionRange {
            builder::VersionRange::default()
        }
    }

    #[doc = "Client view of a [`Vpc`]"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct Vpc {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "The name used for the VPC in DNS."]
        pub dns_name: Name,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "The unique local IPv6 address range for subnets in this VPC"]
        pub ipv6_prefix: Ipv6Net,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "id for the project containing this VPC"]
        pub project_id: uuid::Uuid,
        #[doc = "id for the system router where subnet default routes are registered"]
        pub system_router_id: uuid::Uuid,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
    }

    impl From<&Vpc> for Vpc {
        fn from(value: &Vpc) -> Self {
            value.clone()
        }
    }

    impl Vpc {
        pub fn builder() -> builder::Vpc {
            builder::Vpc::default()
        }
    }

    #[doc = "Create-time parameters for a [`Vpc`](crate::external_api::views::Vpc)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcCreate {
        pub description: String,
        pub dns_name: Name,
        #[doc = "The IPv6 prefix for this VPC.\n\nAll IPv6 subnets created from this VPC must be taken from this range, which sould be a Unique Local Address in the range `fd00::/48`. The default VPC Subnet will have the first `/64` range from this prefix."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_prefix: Option<Ipv6Net>,
        pub name: Name,
    }

    impl From<&VpcCreate> for VpcCreate {
        fn from(value: &VpcCreate) -> Self {
            value.clone()
        }
    }

    impl VpcCreate {
        pub fn builder() -> builder::VpcCreate {
            builder::VpcCreate::default()
        }
    }

    #[doc = "A single rule in a VPC firewall"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcFirewallRule {
        #[doc = "whether traffic matching the rule should be allowed or dropped"]
        pub action: VpcFirewallRuleAction,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "whether this rule is for incoming or outgoing traffic"]
        pub direction: VpcFirewallRuleDirection,
        #[doc = "reductions on the scope of the rule"]
        pub filters: VpcFirewallRuleFilter,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "the relative priority of this rule"]
        pub priority: u16,
        #[doc = "whether this rule is in effect"]
        pub status: VpcFirewallRuleStatus,
        #[doc = "list of sets of instances that the rule applies to"]
        pub targets: Vec<VpcFirewallRuleTarget>,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "the VPC to which this rule belongs"]
        pub vpc_id: uuid::Uuid,
    }

    impl From<&VpcFirewallRule> for VpcFirewallRule {
        fn from(value: &VpcFirewallRule) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRule {
        pub fn builder() -> builder::VpcFirewallRule {
            builder::VpcFirewallRule::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleAction {
        #[serde(rename = "allow")]
        Allow,
        #[serde(rename = "deny")]
        Deny,
    }

    impl From<&VpcFirewallRuleAction> for VpcFirewallRuleAction {
        fn from(value: &VpcFirewallRuleAction) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleAction {
        fn to_string(&self) -> String {
            match *self {
                Self::Allow => "allow".to_string(),
                Self::Deny => "deny".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleAction {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "allow" => Ok(Self::Allow),
                "deny" => Ok(Self::Deny),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleAction {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleAction {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleAction {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleDirection {
        #[serde(rename = "inbound")]
        Inbound,
        #[serde(rename = "outbound")]
        Outbound,
    }

    impl From<&VpcFirewallRuleDirection> for VpcFirewallRuleDirection {
        fn from(value: &VpcFirewallRuleDirection) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleDirection {
        fn to_string(&self) -> String {
            match *self {
                Self::Inbound => "inbound".to_string(),
                Self::Outbound => "outbound".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleDirection {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "inbound" => Ok(Self::Inbound),
                "outbound" => Ok(Self::Outbound),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleDirection {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleDirection {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleDirection {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "Filter for a firewall rule. A given packet must match every field that is present for the rule to apply to it. A packet matches a field if any entry in that field matches the packet."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcFirewallRuleFilter {
        #[doc = "If present, the sources (if incoming) or destinations (if outgoing) this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub hosts: Option<Vec<VpcFirewallRuleHostFilter>>,
        #[doc = "If present, the destination ports this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ports: Option<Vec<L4PortRange>>,
        #[doc = "If present, the networking protocols this rule applies to."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub protocols: Option<Vec<VpcFirewallRuleProtocol>>,
    }

    impl From<&VpcFirewallRuleFilter> for VpcFirewallRuleFilter {
        fn from(value: &VpcFirewallRuleFilter) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleFilter {
        pub fn builder() -> builder::VpcFirewallRuleFilter {
            builder::VpcFirewallRuleFilter::default()
        }
    }

    #[doc = "The `VpcFirewallRuleHostFilter` is used to filter traffic on the basis of its source or destination host."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleHostFilter {
        #[doc = "The rule applies to traffic from/to all instances in the VPC"]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "The rule applies to traffic from/to all instances in the VPC Subnet"]
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[doc = "The rule applies to traffic from/to this specific instance"]
        #[serde(rename = "instance")]
        Instance(Name),
        #[doc = "The rule applies to traffic from/to a specific IP address"]
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        #[doc = "The rule applies to traffic from/to a specific IP subnet"]
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl From<&VpcFirewallRuleHostFilter> for VpcFirewallRuleHostFilter {
        fn from(value: &VpcFirewallRuleHostFilter) -> Self {
            value.clone()
        }
    }

    #[doc = "The protocols that may be specified in a firewall rule's filter"]
    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleProtocol {
        #[serde(rename = "TCP")]
        Tcp,
        #[serde(rename = "UDP")]
        Udp,
        #[serde(rename = "ICMP")]
        Icmp,
    }

    impl From<&VpcFirewallRuleProtocol> for VpcFirewallRuleProtocol {
        fn from(value: &VpcFirewallRuleProtocol) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleProtocol {
        fn to_string(&self) -> String {
            match *self {
                Self::Tcp => "TCP".to_string(),
                Self::Udp => "UDP".to_string(),
                Self::Icmp => "ICMP".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleProtocol {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "TCP" => Ok(Self::Tcp),
                "UDP" => Ok(Self::Udp),
                "ICMP" => Ok(Self::Icmp),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleProtocol {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleProtocol {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleProtocol {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum VpcFirewallRuleStatus {
        #[serde(rename = "disabled")]
        Disabled,
        #[serde(rename = "enabled")]
        Enabled,
    }

    impl From<&VpcFirewallRuleStatus> for VpcFirewallRuleStatus {
        fn from(value: &VpcFirewallRuleStatus) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcFirewallRuleStatus {
        fn to_string(&self) -> String {
            match *self {
                Self::Disabled => "disabled".to_string(),
                Self::Enabled => "enabled".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcFirewallRuleStatus {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "disabled" => Ok(Self::Disabled),
                "enabled" => Ok(Self::Enabled),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcFirewallRuleStatus {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcFirewallRuleStatus {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcFirewallRuleStatus {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "A `VpcFirewallRuleTarget` is used to specify the set of [`Instance`]s to which a firewall rule applies."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    #[serde(tag = "type", content = "value")]
    pub enum VpcFirewallRuleTarget {
        #[doc = "The rule applies to all instances in the VPC"]
        #[serde(rename = "vpc")]
        Vpc(Name),
        #[doc = "The rule applies to all instances in the VPC Subnet"]
        #[serde(rename = "subnet")]
        Subnet(Name),
        #[doc = "The rule applies to this specific instance"]
        #[serde(rename = "instance")]
        Instance(Name),
        #[doc = "The rule applies to a specific IP address"]
        #[serde(rename = "ip")]
        Ip(std::net::IpAddr),
        #[doc = "The rule applies to a specific IP subnet"]
        #[serde(rename = "ip_net")]
        IpNet(IpNet),
    }

    impl From<&VpcFirewallRuleTarget> for VpcFirewallRuleTarget {
        fn from(value: &VpcFirewallRuleTarget) -> Self {
            value.clone()
        }
    }

    #[doc = "A single rule in a VPC firewall"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcFirewallRuleUpdate {
        #[doc = "whether traffic matching the rule should be allowed or dropped"]
        pub action: VpcFirewallRuleAction,
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "whether this rule is for incoming or outgoing traffic"]
        pub direction: VpcFirewallRuleDirection,
        #[doc = "reductions on the scope of the rule"]
        pub filters: VpcFirewallRuleFilter,
        #[doc = "name of the rule, unique to this VPC"]
        pub name: Name,
        #[doc = "the relative priority of this rule"]
        pub priority: u16,
        #[doc = "whether this rule is in effect"]
        pub status: VpcFirewallRuleStatus,
        #[doc = "list of sets of instances that the rule applies to"]
        pub targets: Vec<VpcFirewallRuleTarget>,
    }

    impl From<&VpcFirewallRuleUpdate> for VpcFirewallRuleUpdate {
        fn from(value: &VpcFirewallRuleUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleUpdate {
        pub fn builder() -> builder::VpcFirewallRuleUpdate {
            builder::VpcFirewallRuleUpdate::default()
        }
    }

    #[doc = "Updateable properties of a `Vpc`'s firewall Note that VpcFirewallRules are implicitly created along with a Vpc, so there is no explicit creation."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcFirewallRuleUpdateParams {
        pub rules: Vec<VpcFirewallRuleUpdate>,
    }

    impl From<&VpcFirewallRuleUpdateParams> for VpcFirewallRuleUpdateParams {
        fn from(value: &VpcFirewallRuleUpdateParams) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRuleUpdateParams {
        pub fn builder() -> builder::VpcFirewallRuleUpdateParams {
            builder::VpcFirewallRuleUpdateParams::default()
        }
    }

    #[doc = "Collection of a Vpc's firewall rules"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcFirewallRules {
        pub rules: Vec<VpcFirewallRule>,
    }

    impl From<&VpcFirewallRules> for VpcFirewallRules {
        fn from(value: &VpcFirewallRules) -> Self {
            value.clone()
        }
    }

    impl VpcFirewallRules {
        pub fn builder() -> builder::VpcFirewallRules {
            builder::VpcFirewallRules::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<Vpc>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&VpcResultsPage> for VpcResultsPage {
        fn from(value: &VpcResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcResultsPage {
        pub fn builder() -> builder::VpcResultsPage {
            builder::VpcResultsPage::default()
        }
    }

    #[doc = "A VPC router defines a series of rules that indicate where traffic should be sent depending on its destination."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcRouter {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        pub kind: VpcRouterKind,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC to which the router belongs."]
        pub vpc_id: uuid::Uuid,
    }

    impl From<&VpcRouter> for VpcRouter {
        fn from(value: &VpcRouter) -> Self {
            value.clone()
        }
    }

    impl VpcRouter {
        pub fn builder() -> builder::VpcRouter {
            builder::VpcRouter::default()
        }
    }

    #[doc = "Create-time parameters for a [`VpcRouter`](crate::external_api::views::VpcRouter)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcRouterCreate {
        pub description: String,
        pub name: Name,
    }

    impl From<&VpcRouterCreate> for VpcRouterCreate {
        fn from(value: &VpcRouterCreate) -> Self {
            value.clone()
        }
    }

    impl VpcRouterCreate {
        pub fn builder() -> builder::VpcRouterCreate {
            builder::VpcRouterCreate::default()
        }
    }

    #[derive(
        Clone,
        Copy,
        Debug,
        Deserialize,
        Eq,
        Hash,
        Ord,
        PartialEq,
        PartialOrd,
        Serialize,
        schemars :: JsonSchema,
    )]
    pub enum VpcRouterKind {
        #[serde(rename = "system")]
        System,
        #[serde(rename = "custom")]
        Custom,
    }

    impl From<&VpcRouterKind> for VpcRouterKind {
        fn from(value: &VpcRouterKind) -> Self {
            value.clone()
        }
    }

    impl ToString for VpcRouterKind {
        fn to_string(&self) -> String {
            match *self {
                Self::System => "system".to_string(),
                Self::Custom => "custom".to_string(),
            }
        }
    }

    impl std::str::FromStr for VpcRouterKind {
        type Err = &'static str;
        fn from_str(value: &str) -> Result<Self, &'static str> {
            match value {
                "system" => Ok(Self::System),
                "custom" => Ok(Self::Custom),
                _ => Err("invalid value"),
            }
        }
    }

    impl std::convert::TryFrom<&str> for VpcRouterKind {
        type Error = &'static str;
        fn try_from(value: &str) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<&String> for VpcRouterKind {
        type Error = &'static str;
        fn try_from(value: &String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    impl std::convert::TryFrom<String> for VpcRouterKind {
        type Error = &'static str;
        fn try_from(value: String) -> Result<Self, &'static str> {
            value.parse()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcRouterResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcRouter>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&VpcRouterResultsPage> for VpcRouterResultsPage {
        fn from(value: &VpcRouterResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcRouterResultsPage {
        pub fn builder() -> builder::VpcRouterResultsPage {
            builder::VpcRouterResultsPage::default()
        }
    }

    #[doc = "Updateable properties of a [`VpcRouter`](crate::external_api::views::VpcRouter)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcRouterUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&VpcRouterUpdate> for VpcRouterUpdate {
        fn from(value: &VpcRouterUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcRouterUpdate {
        pub fn builder() -> builder::VpcRouterUpdate {
            builder::VpcRouterUpdate::default()
        }
    }

    #[doc = "A VPC subnet represents a logical grouping for instances that allows network traffic between them, within a IPv4 subnetwork or optionall an IPv6 subnetwork."]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcSubnet {
        #[doc = "human-readable free-form text about a resource"]
        pub description: String,
        #[doc = "unique, immutable, system-controlled identifier for each resource"]
        pub id: uuid::Uuid,
        #[doc = "The IPv4 subnet CIDR block."]
        pub ipv4_block: Ipv4Net,
        #[doc = "The IPv6 subnet CIDR block."]
        pub ipv6_block: Ipv6Net,
        #[doc = "unique, mutable, user-controlled identifier for each resource"]
        pub name: Name,
        #[doc = "timestamp when this resource was created"]
        pub time_created: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "timestamp when this resource was last modified"]
        pub time_modified: chrono::DateTime<chrono::offset::Utc>,
        #[doc = "The VPC to which the subnet belongs."]
        pub vpc_id: uuid::Uuid,
    }

    impl From<&VpcSubnet> for VpcSubnet {
        fn from(value: &VpcSubnet) -> Self {
            value.clone()
        }
    }

    impl VpcSubnet {
        pub fn builder() -> builder::VpcSubnet {
            builder::VpcSubnet::default()
        }
    }

    #[doc = "Create-time parameters for a [`VpcSubnet`](crate::external_api::views::VpcSubnet)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcSubnetCreate {
        pub description: String,
        #[doc = "The IPv4 address range for this subnet.\n\nIt must be allocated from an RFC 1918 private address range, and must not overlap with any other existing subnet in the VPC."]
        pub ipv4_block: Ipv4Net,
        #[doc = "The IPv6 address range for this subnet.\n\nIt must be allocated from the RFC 4193 Unique Local Address range, with the prefix equal to the parent VPC's prefix. A random `/64` block will be assigned if one is not provided. It must not overlap with any existing subnet in the VPC."]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub ipv6_block: Option<Ipv6Net>,
        pub name: Name,
    }

    impl From<&VpcSubnetCreate> for VpcSubnetCreate {
        fn from(value: &VpcSubnetCreate) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetCreate {
        pub fn builder() -> builder::VpcSubnetCreate {
            builder::VpcSubnetCreate::default()
        }
    }

    #[doc = "A single page of results"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcSubnetResultsPage {
        #[doc = "list of items on this page of results"]
        pub items: Vec<VpcSubnet>,
        #[doc = "token used to fetch the next page of results (if any)"]
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub next_page: Option<String>,
    }

    impl From<&VpcSubnetResultsPage> for VpcSubnetResultsPage {
        fn from(value: &VpcSubnetResultsPage) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetResultsPage {
        pub fn builder() -> builder::VpcSubnetResultsPage {
            builder::VpcSubnetResultsPage::default()
        }
    }

    #[doc = "Updateable properties of a [`VpcSubnet`](crate::external_api::views::VpcSubnet)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcSubnetUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&VpcSubnetUpdate> for VpcSubnetUpdate {
        fn from(value: &VpcSubnetUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcSubnetUpdate {
        pub fn builder() -> builder::VpcSubnetUpdate {
            builder::VpcSubnetUpdate::default()
        }
    }

    #[doc = "Updateable properties of a [`Vpc`](crate::external_api::views::Vpc)"]
    #[derive(Clone, Debug, Deserialize, Serialize, schemars :: JsonSchema)]
    pub struct VpcUpdate {
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub description: Option<String>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub dns_name: Option<Name>,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        pub name: Option<Name>,
    }

    impl From<&VpcUpdate> for VpcUpdate {
        fn from(value: &VpcUpdate) -> Self {
            value.clone()
        }
    }

    impl VpcUpdate {
        pub fn builder() -> builder::VpcUpdate {
            builder::VpcUpdate::default()
        }
    }

    mod builder {
        pub struct Baseboard {
            part: Result<String, String>,
            revision: Result<i64, String>,
            serial: Result<String, String>,
        }

        impl Default for Baseboard {
            fn default() -> Self {
                Self {
                    part: Err("no value supplied for part".to_string()),
                    revision: Err("no value supplied for revision".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                }
            }
        }

        impl Baseboard {
            pub fn part<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.part = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for part: {}", e));
                self
            }
            pub fn revision<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.revision = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revision: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Baseboard> for super::Baseboard {
            type Error = String;
            fn try_from(value: Baseboard) -> Result<Self, String> {
                Ok(Self {
                    part: value.part?,
                    revision: value.revision?,
                    serial: value.serial?,
                })
            }
        }

        pub struct Bindouble {
            count: Result<u64, String>,
            range: Result<super::BinRangedouble, String>,
        }

        impl Default for Bindouble {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Bindouble {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BinRangedouble>,
                T::Error: std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Bindouble> for super::Bindouble {
            type Error = String;
            fn try_from(value: Bindouble) -> Result<Self, String> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        pub struct Binint64 {
            count: Result<u64, String>,
            range: Result<super::BinRangeint64, String>,
        }

        impl Default for Binint64 {
            fn default() -> Self {
                Self {
                    count: Err("no value supplied for count".to_string()),
                    range: Err("no value supplied for range".to_string()),
                }
            }
        }

        impl Binint64 {
            pub fn count<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.count = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for count: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BinRangeint64>,
                T::Error: std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Binint64> for super::Binint64 {
            type Error = String;
            fn try_from(value: Binint64) -> Result<Self, String> {
                Ok(Self {
                    count: value.count?,
                    range: value.range?,
                })
            }
        }

        pub struct Certificate {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            service: Result<super::ServiceUsingCertificate, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Certificate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    service: Err("no value supplied for service".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Certificate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn service<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ServiceUsingCertificate>,
                T::Error: std::fmt::Display,
            {
                self.service = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Certificate> for super::Certificate {
            type Error = String;
            fn try_from(value: Certificate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    service: value.service?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct CertificateCreate {
            cert: Result<Vec<u8>, String>,
            description: Result<String, String>,
            key: Result<Vec<u8>, String>,
            name: Result<super::Name, String>,
            service: Result<super::ServiceUsingCertificate, String>,
        }

        impl Default for CertificateCreate {
            fn default() -> Self {
                Self {
                    cert: Err("no value supplied for cert".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    service: Err("no value supplied for service".to_string()),
                }
            }
        }

        impl CertificateCreate {
            pub fn cert<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<u8>>,
                T::Error: std::fmt::Display,
            {
                self.cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for cert: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<u8>>,
                T::Error: std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn service<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ServiceUsingCertificate>,
                T::Error: std::fmt::Display,
            {
                self.service = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for service: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<CertificateCreate> for super::CertificateCreate {
            type Error = String;
            fn try_from(value: CertificateCreate) -> Result<Self, String> {
                Ok(Self {
                    cert: value.cert?,
                    description: value.description?,
                    key: value.key?,
                    name: value.name?,
                    service: value.service?,
                })
            }
        }

        pub struct CertificateResultsPage {
            items: Result<Vec<super::Certificate>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for CertificateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl CertificateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Certificate>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<CertificateResultsPage> for super::CertificateResultsPage {
            type Error = String;
            fn try_from(value: CertificateResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct ComponentUpdate {
            component_type: Result<super::UpdateableComponentType, String>,
            id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for ComponentUpdate {
            fn default() -> Self {
                Self {
                    component_type: Err("no value supplied for component_type".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl ComponentUpdate {
            pub fn component_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateableComponentType>,
                T::Error: std::fmt::Display,
            {
                self.component_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_type: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ComponentUpdate> for super::ComponentUpdate {
            type Error = String;
            fn try_from(value: ComponentUpdate) -> Result<Self, String> {
                Ok(Self {
                    component_type: value.component_type?,
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        pub struct ComponentUpdateResultsPage {
            items: Result<Vec<super::ComponentUpdate>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ComponentUpdateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ComponentUpdateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ComponentUpdate>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ComponentUpdateResultsPage> for super::ComponentUpdateResultsPage {
            type Error = String;
            fn try_from(value: ComponentUpdateResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Cumulativedouble {
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            value: Result<f64, String>,
        }

        impl Default for Cumulativedouble {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativedouble {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<f64>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Cumulativedouble> for super::Cumulativedouble {
            type Error = String;
            fn try_from(value: Cumulativedouble) -> Result<Self, String> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        pub struct Cumulativeint64 {
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            value: Result<i64, String>,
        }

        impl Default for Cumulativeint64 {
            fn default() -> Self {
                Self {
                    start_time: Err("no value supplied for start_time".to_string()),
                    value: Err("no value supplied for value".to_string()),
                }
            }
        }

        impl Cumulativeint64 {
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
            pub fn value<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<i64>,
                T::Error: std::fmt::Display,
            {
                self.value = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for value: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Cumulativeint64> for super::Cumulativeint64 {
            type Error = String;
            fn try_from(value: Cumulativeint64) -> Result<Self, String> {
                Ok(Self {
                    start_time: value.start_time?,
                    value: value.value?,
                })
            }
        }

        pub struct DerEncodedKeyPair {
            private_key: Result<String, String>,
            public_cert: Result<String, String>,
        }

        impl Default for DerEncodedKeyPair {
            fn default() -> Self {
                Self {
                    private_key: Err("no value supplied for private_key".to_string()),
                    public_cert: Err("no value supplied for public_cert".to_string()),
                }
            }
        }

        impl DerEncodedKeyPair {
            pub fn private_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.private_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for private_key: {}", e));
                self
            }
            pub fn public_cert<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.public_cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_cert: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DerEncodedKeyPair> for super::DerEncodedKeyPair {
            type Error = String;
            fn try_from(value: DerEncodedKeyPair) -> Result<Self, String> {
                Ok(Self {
                    private_key: value.private_key?,
                    public_cert: value.public_cert?,
                })
            }
        }

        pub struct DeviceAccessTokenRequest {
            client_id: Result<uuid::Uuid, String>,
            device_code: Result<String, String>,
            grant_type: Result<String, String>,
        }

        impl Default for DeviceAccessTokenRequest {
            fn default() -> Self {
                Self {
                    client_id: Err("no value supplied for client_id".to_string()),
                    device_code: Err("no value supplied for device_code".to_string()),
                    grant_type: Err("no value supplied for grant_type".to_string()),
                }
            }
        }

        impl DeviceAccessTokenRequest {
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {}", e));
                self
            }
            pub fn device_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.device_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_code: {}", e));
                self
            }
            pub fn grant_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.grant_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for grant_type: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DeviceAccessTokenRequest> for super::DeviceAccessTokenRequest {
            type Error = String;
            fn try_from(value: DeviceAccessTokenRequest) -> Result<Self, String> {
                Ok(Self {
                    client_id: value.client_id?,
                    device_code: value.device_code?,
                    grant_type: value.grant_type?,
                })
            }
        }

        pub struct DeviceAuthRequest {
            client_id: Result<uuid::Uuid, String>,
        }

        impl Default for DeviceAuthRequest {
            fn default() -> Self {
                Self {
                    client_id: Err("no value supplied for client_id".to_string()),
                }
            }
        }

        impl DeviceAuthRequest {
            pub fn client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.client_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for client_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DeviceAuthRequest> for super::DeviceAuthRequest {
            type Error = String;
            fn try_from(value: DeviceAuthRequest) -> Result<Self, String> {
                Ok(Self {
                    client_id: value.client_id?,
                })
            }
        }

        pub struct DeviceAuthVerify {
            user_code: Result<String, String>,
        }

        impl Default for DeviceAuthVerify {
            fn default() -> Self {
                Self {
                    user_code: Err("no value supplied for user_code".to_string()),
                }
            }
        }

        impl DeviceAuthVerify {
            pub fn user_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.user_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_code: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DeviceAuthVerify> for super::DeviceAuthVerify {
            type Error = String;
            fn try_from(value: DeviceAuthVerify) -> Result<Self, String> {
                Ok(Self {
                    user_code: value.user_code?,
                })
            }
        }

        pub struct Disk {
            block_size: Result<super::ByteCount, String>,
            description: Result<String, String>,
            device_path: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            image_id: Result<Option<uuid::Uuid>, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            size: Result<super::ByteCount, String>,
            snapshot_id: Result<Option<uuid::Uuid>, String>,
            state: Result<super::DiskState, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Disk {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    device_path: Err("no value supplied for device_path".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    image_id: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    snapshot_id: Ok(Default::default()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Disk {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn device_path<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.device_path = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_path: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn image_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<uuid::Uuid>>,
                T::Error: std::fmt::Display,
            {
                self.image_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for image_id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn snapshot_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<uuid::Uuid>>,
                T::Error: std::fmt::Display,
            {
                self.snapshot_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for snapshot_id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::DiskState>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Disk> for super::Disk {
            type Error = String;
            fn try_from(value: Disk) -> Result<Self, String> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    device_path: value.device_path?,
                    id: value.id?,
                    image_id: value.image_id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    snapshot_id: value.snapshot_id?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct DiskCreate {
            description: Result<String, String>,
            disk_source: Result<super::DiskSource, String>,
            name: Result<super::Name, String>,
            size: Result<super::ByteCount, String>,
        }

        impl Default for DiskCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk_source: Err("no value supplied for disk_source".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    size: Err("no value supplied for size".to_string()),
                }
            }
        }

        impl DiskCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk_source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::DiskSource>,
                T::Error: std::fmt::Display,
            {
                self.disk_source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_source: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskCreate> for super::DiskCreate {
            type Error = String;
            fn try_from(value: DiskCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    disk_source: value.disk_source?,
                    name: value.name?,
                    size: value.size?,
                })
            }
        }

        pub struct DiskIdentifier {
            name: Result<super::Name, String>,
        }

        impl Default for DiskIdentifier {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl DiskIdentifier {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskIdentifier> for super::DiskIdentifier {
            type Error = String;
            fn try_from(value: DiskIdentifier) -> Result<Self, String> {
                Ok(Self { name: value.name? })
            }
        }

        pub struct DiskPath {
            disk: Result<super::NameOrId, String>,
        }

        impl Default for DiskPath {
            fn default() -> Self {
                Self {
                    disk: Err("no value supplied for disk".to_string()),
                }
            }
        }

        impl DiskPath {
            pub fn disk<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::NameOrId>,
                T::Error: std::fmt::Display,
            {
                self.disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskPath> for super::DiskPath {
            type Error = String;
            fn try_from(value: DiskPath) -> Result<Self, String> {
                Ok(Self { disk: value.disk? })
            }
        }

        pub struct DiskResultsPage {
            items: Result<Vec<super::Disk>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for DiskResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl DiskResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Disk>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<DiskResultsPage> for super::DiskResultsPage {
            type Error = String;
            fn try_from(value: DiskResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Distribution {
            name: Result<super::Name, String>,
            version: Result<String, String>,
        }

        impl Default for Distribution {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl Distribution {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Distribution> for super::Distribution {
            type Error = String;
            fn try_from(value: Distribution) -> Result<Self, String> {
                Ok(Self {
                    name: value.name?,
                    version: value.version?,
                })
            }
        }

        pub struct Error {
            error_code: Result<Option<String>, String>,
            message: Result<String, String>,
            request_id: Result<String, String>,
        }

        impl Default for Error {
            fn default() -> Self {
                Self {
                    error_code: Ok(Default::default()),
                    message: Err("no value supplied for message".to_string()),
                    request_id: Err("no value supplied for request_id".to_string()),
                }
            }
        }

        impl Error {
            pub fn error_code<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.error_code = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error_code: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
            pub fn request_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.request_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for request_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Error> for super::Error {
            type Error = String;
            fn try_from(value: Error) -> Result<Self, String> {
                Ok(Self {
                    error_code: value.error_code?,
                    message: value.message?,
                    request_id: value.request_id?,
                })
            }
        }

        pub struct ExternalIp {
            ip: Result<std::net::IpAddr, String>,
            kind: Result<super::IpKind, String>,
        }

        impl Default for ExternalIp {
            fn default() -> Self {
                Self {
                    ip: Err("no value supplied for ip".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                }
            }
        }

        impl ExternalIp {
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::IpAddr>,
                T::Error: std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IpKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ExternalIp> for super::ExternalIp {
            type Error = String;
            fn try_from(value: ExternalIp) -> Result<Self, String> {
                Ok(Self {
                    ip: value.ip?,
                    kind: value.kind?,
                })
            }
        }

        pub struct ExternalIpResultsPage {
            items: Result<Vec<super::ExternalIp>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ExternalIpResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ExternalIpResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ExternalIp>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ExternalIpResultsPage> for super::ExternalIpResultsPage {
            type Error = String;
            fn try_from(value: ExternalIpResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct FieldSchema {
            name: Result<String, String>,
            source: Result<super::FieldSource, String>,
            ty: Result<super::FieldType, String>,
        }

        impl Default for FieldSchema {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    ty: Err("no value supplied for ty".to_string()),
                }
            }
        }

        impl FieldSchema {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::FieldSource>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
            pub fn ty<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::FieldType>,
                T::Error: std::fmt::Display,
            {
                self.ty = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ty: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FieldSchema> for super::FieldSchema {
            type Error = String;
            fn try_from(value: FieldSchema) -> Result<Self, String> {
                Ok(Self {
                    name: value.name?,
                    source: value.source?,
                    ty: value.ty?,
                })
            }
        }

        pub struct FleetRolePolicy {
            role_assignments: Result<Vec<super::FleetRoleRoleAssignment>, String>,
        }

        impl Default for FleetRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl FleetRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::FleetRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<FleetRolePolicy> for super::FleetRolePolicy {
            type Error = String;
            fn try_from(value: FleetRolePolicy) -> Result<Self, String> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        pub struct FleetRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::FleetRole, String>,
        }

        impl Default for FleetRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl FleetRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::FleetRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<FleetRoleRoleAssignment> for super::FleetRoleRoleAssignment {
            type Error = String;
            fn try_from(value: FleetRoleRoleAssignment) -> Result<Self, String> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        pub struct GlobalImage {
            block_size: Result<super::ByteCount, String>,
            description: Result<String, String>,
            digest: Result<Option<super::Digest>, String>,
            distribution: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            size: Result<super::ByteCount, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            url: Result<Option<String>, String>,
            version: Result<String, String>,
        }

        impl Default for GlobalImage {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    digest: Ok(Default::default()),
                    distribution: Err("no value supplied for distribution".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    url: Ok(Default::default()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl GlobalImage {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn digest<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Digest>>,
                T::Error: std::fmt::Display,
            {
                self.digest = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for digest: {}", e));
                self
            }
            pub fn distribution<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.distribution = value.try_into().map_err(|e| {
                    format!("error converting supplied value for distribution: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GlobalImage> for super::GlobalImage {
            type Error = String;
            fn try_from(value: GlobalImage) -> Result<Self, String> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    digest: value.digest?,
                    distribution: value.distribution?,
                    id: value.id?,
                    name: value.name?,
                    size: value.size?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    url: value.url?,
                    version: value.version?,
                })
            }
        }

        pub struct GlobalImageCreate {
            block_size: Result<super::BlockSize, String>,
            description: Result<String, String>,
            distribution: Result<super::Distribution, String>,
            name: Result<super::Name, String>,
            source: Result<super::ImageSource, String>,
        }

        impl Default for GlobalImageCreate {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    distribution: Err("no value supplied for distribution".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                }
            }
        }

        impl GlobalImageCreate {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BlockSize>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn distribution<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Distribution>,
                T::Error: std::fmt::Display,
            {
                self.distribution = value.try_into().map_err(|e| {
                    format!("error converting supplied value for distribution: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ImageSource>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GlobalImageCreate> for super::GlobalImageCreate {
            type Error = String;
            fn try_from(value: GlobalImageCreate) -> Result<Self, String> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    distribution: value.distribution?,
                    name: value.name?,
                    source: value.source?,
                })
            }
        }

        pub struct GlobalImageResultsPage {
            items: Result<Vec<super::GlobalImage>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for GlobalImageResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl GlobalImageResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::GlobalImage>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GlobalImageResultsPage> for super::GlobalImageResultsPage {
            type Error = String;
            fn try_from(value: GlobalImageResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Group {
            display_name: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            silo_id: Result<uuid::Uuid, String>,
        }

        impl Default for Group {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl Group {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Group> for super::Group {
            type Error = String;
            fn try_from(value: Group) -> Result<Self, String> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                })
            }
        }

        pub struct GroupResultsPage {
            items: Result<Vec<super::Group>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for GroupResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl GroupResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Group>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<GroupResultsPage> for super::GroupResultsPage {
            type Error = String;
            fn try_from(value: GroupResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Histogramdouble {
            bins: Result<Vec<super::Bindouble>, String>,
            n_samples: Result<u64, String>,
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Histogramdouble {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                }
            }
        }

        impl Histogramdouble {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Bindouble>>,
                T::Error: std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Histogramdouble> for super::Histogramdouble {
            type Error = String;
            fn try_from(value: Histogramdouble) -> Result<Self, String> {
                Ok(Self {
                    bins: value.bins?,
                    n_samples: value.n_samples?,
                    start_time: value.start_time?,
                })
            }
        }

        pub struct Histogramint64 {
            bins: Result<Vec<super::Binint64>, String>,
            n_samples: Result<u64, String>,
            start_time: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Histogramint64 {
            fn default() -> Self {
                Self {
                    bins: Err("no value supplied for bins".to_string()),
                    n_samples: Err("no value supplied for n_samples".to_string()),
                    start_time: Err("no value supplied for start_time".to_string()),
                }
            }
        }

        impl Histogramint64 {
            pub fn bins<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Binint64>>,
                T::Error: std::fmt::Display,
            {
                self.bins = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for bins: {}", e));
                self
            }
            pub fn n_samples<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.n_samples = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for n_samples: {}", e));
                self
            }
            pub fn start_time<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.start_time = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start_time: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Histogramint64> for super::Histogramint64 {
            type Error = String;
            fn try_from(value: Histogramint64) -> Result<Self, String> {
                Ok(Self {
                    bins: value.bins?,
                    n_samples: value.n_samples?,
                    start_time: value.start_time?,
                })
            }
        }

        pub struct IdentityProvider {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            provider_type: Result<super::IdentityProviderType, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for IdentityProvider {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    provider_type: Err("no value supplied for provider_type".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl IdentityProvider {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn provider_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityProviderType>,
                T::Error: std::fmt::Display,
            {
                self.provider_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for provider_type: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<IdentityProvider> for super::IdentityProvider {
            type Error = String;
            fn try_from(value: IdentityProvider) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    provider_type: value.provider_type?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct IdentityProviderResultsPage {
            items: Result<Vec<super::IdentityProvider>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for IdentityProviderResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IdentityProviderResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::IdentityProvider>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IdentityProviderResultsPage> for super::IdentityProviderResultsPage {
            type Error = String;
            fn try_from(value: IdentityProviderResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Image {
            block_size: Result<super::ByteCount, String>,
            description: Result<String, String>,
            digest: Result<Option<super::Digest>, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            os: Result<String, String>,
            project_id: Result<uuid::Uuid, String>,
            size: Result<super::ByteCount, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            url: Result<Option<String>, String>,
            version: Result<String, String>,
        }

        impl Default for Image {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    digest: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    os: Err("no value supplied for os".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    url: Ok(Default::default()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl Image {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn digest<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Digest>>,
                T::Error: std::fmt::Display,
            {
                self.digest = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for digest: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn os<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.os = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for os: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for url: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Image> for super::Image {
            type Error = String;
            fn try_from(value: Image) -> Result<Self, String> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    digest: value.digest?,
                    id: value.id?,
                    name: value.name?,
                    os: value.os?,
                    project_id: value.project_id?,
                    size: value.size?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    url: value.url?,
                    version: value.version?,
                })
            }
        }

        pub struct ImageCreate {
            block_size: Result<super::BlockSize, String>,
            description: Result<String, String>,
            name: Result<super::Name, String>,
            os: Result<String, String>,
            source: Result<super::ImageSource, String>,
            version: Result<String, String>,
        }

        impl Default for ImageCreate {
            fn default() -> Self {
                Self {
                    block_size: Err("no value supplied for block_size".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    os: Err("no value supplied for os".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl ImageCreate {
            pub fn block_size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::BlockSize>,
                T::Error: std::fmt::Display,
            {
                self.block_size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for block_size: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn os<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.os = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for os: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ImageSource>,
                T::Error: std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ImageCreate> for super::ImageCreate {
            type Error = String;
            fn try_from(value: ImageCreate) -> Result<Self, String> {
                Ok(Self {
                    block_size: value.block_size?,
                    description: value.description?,
                    name: value.name?,
                    os: value.os?,
                    source: value.source?,
                    version: value.version?,
                })
            }
        }

        pub struct ImageResultsPage {
            items: Result<Vec<super::Image>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ImageResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ImageResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Image>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ImageResultsPage> for super::ImageResultsPage {
            type Error = String;
            fn try_from(value: ImageResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Instance {
            description: Result<String, String>,
            hostname: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            memory: Result<super::ByteCount, String>,
            name: Result<super::Name, String>,
            ncpus: Result<super::InstanceCpuCount, String>,
            project_id: Result<uuid::Uuid, String>,
            run_state: Result<super::InstanceState, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_run_state_updated: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Instance {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    hostname: Err("no value supplied for hostname".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    run_state: Err("no value supplied for run_state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    time_run_state_updated: Err(
                        "no value supplied for time_run_state_updated".to_string()
                    ),
                }
            }
        }

        impl Instance {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn hostname<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.hostname = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hostname: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn run_state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceState>,
                T::Error: std::fmt::Display,
            {
                self.run_state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for run_state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn time_run_state_updated<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_run_state_updated = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for time_run_state_updated: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<Instance> for super::Instance {
            type Error = String;
            fn try_from(value: Instance) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    hostname: value.hostname?,
                    id: value.id?,
                    memory: value.memory?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    project_id: value.project_id?,
                    run_state: value.run_state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    time_run_state_updated: value.time_run_state_updated?,
                })
            }
        }

        pub struct InstanceCreate {
            description: Result<String, String>,
            disks: Result<Vec<super::InstanceDiskAttachment>, String>,
            external_ips: Result<Vec<super::ExternalIpCreate>, String>,
            hostname: Result<String, String>,
            memory: Result<super::ByteCount, String>,
            name: Result<super::Name, String>,
            ncpus: Result<super::InstanceCpuCount, String>,
            network_interfaces: Result<super::InstanceNetworkInterfaceAttachment, String>,
            start: Result<bool, String>,
            user_data: Result<String, String>,
        }

        impl Default for InstanceCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disks: Ok(Default::default()),
                    external_ips: Ok(Default::default()),
                    hostname: Err("no value supplied for hostname".to_string()),
                    memory: Err("no value supplied for memory".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    ncpus: Err("no value supplied for ncpus".to_string()),
                    network_interfaces: Ok(super::defaults::instance_create_network_interfaces()),
                    start: Ok(super::defaults::default_bool::<true>()),
                    user_data: Ok(Default::default()),
                }
            }
        }

        impl InstanceCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disks<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::InstanceDiskAttachment>>,
                T::Error: std::fmt::Display,
            {
                self.disks = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disks: {}", e));
                self
            }
            pub fn external_ips<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ExternalIpCreate>>,
                T::Error: std::fmt::Display,
            {
                self.external_ips = value.try_into().map_err(|e| {
                    format!("error converting supplied value for external_ips: {}", e)
                });
                self
            }
            pub fn hostname<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.hostname = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hostname: {}", e));
                self
            }
            pub fn memory<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.memory = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for memory: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn ncpus<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceCpuCount>,
                T::Error: std::fmt::Display,
            {
                self.ncpus = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ncpus: {}", e));
                self
            }
            pub fn network_interfaces<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::InstanceNetworkInterfaceAttachment>,
                T::Error: std::fmt::Display,
            {
                self.network_interfaces = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for network_interfaces: {}",
                        e
                    )
                });
                self
            }
            pub fn start<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.start = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for start: {}", e));
                self
            }
            pub fn user_data<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.user_data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for user_data: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<InstanceCreate> for super::InstanceCreate {
            type Error = String;
            fn try_from(value: InstanceCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    disks: value.disks?,
                    external_ips: value.external_ips?,
                    hostname: value.hostname?,
                    memory: value.memory?,
                    name: value.name?,
                    ncpus: value.ncpus?,
                    network_interfaces: value.network_interfaces?,
                    start: value.start?,
                    user_data: value.user_data?,
                })
            }
        }

        pub struct InstanceMigrate {
            dst_sled_id: Result<uuid::Uuid, String>,
        }

        impl Default for InstanceMigrate {
            fn default() -> Self {
                Self {
                    dst_sled_id: Err("no value supplied for dst_sled_id".to_string()),
                }
            }
        }

        impl InstanceMigrate {
            pub fn dst_sled_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.dst_sled_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dst_sled_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<InstanceMigrate> for super::InstanceMigrate {
            type Error = String;
            fn try_from(value: InstanceMigrate) -> Result<Self, String> {
                Ok(Self {
                    dst_sled_id: value.dst_sled_id?,
                })
            }
        }

        pub struct InstanceResultsPage {
            items: Result<Vec<super::Instance>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for InstanceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl InstanceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Instance>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<InstanceResultsPage> for super::InstanceResultsPage {
            type Error = String;
            fn try_from(value: InstanceResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct InstanceSerialConsoleData {
            data: Result<Vec<u8>, String>,
            last_byte_offset: Result<u64, String>,
        }

        impl Default for InstanceSerialConsoleData {
            fn default() -> Self {
                Self {
                    data: Err("no value supplied for data".to_string()),
                    last_byte_offset: Err("no value supplied for last_byte_offset".to_string()),
                }
            }
        }

        impl InstanceSerialConsoleData {
            pub fn data<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<u8>>,
                T::Error: std::fmt::Display,
            {
                self.data = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for data: {}", e));
                self
            }
            pub fn last_byte_offset<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u64>,
                T::Error: std::fmt::Display,
            {
                self.last_byte_offset = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for last_byte_offset: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<InstanceSerialConsoleData> for super::InstanceSerialConsoleData {
            type Error = String;
            fn try_from(value: InstanceSerialConsoleData) -> Result<Self, String> {
                Ok(Self {
                    data: value.data?,
                    last_byte_offset: value.last_byte_offset?,
                })
            }
        }

        pub struct IpPool {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for IpPool {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl IpPool {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<IpPool> for super::IpPool {
            type Error = String;
            fn try_from(value: IpPool) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct IpPoolCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for IpPoolCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl IpPoolCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolCreate> for super::IpPoolCreate {
            type Error = String;
            fn try_from(value: IpPoolCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct IpPoolRange {
            id: Result<uuid::Uuid, String>,
            range: Result<super::IpRange, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for IpPoolRange {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    range: Err("no value supplied for range".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                }
            }
        }

        impl IpPoolRange {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IpRange>,
                T::Error: std::fmt::Display,
            {
                self.range = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for range: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<IpPoolRange> for super::IpPoolRange {
            type Error = String;
            fn try_from(value: IpPoolRange) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    range: value.range?,
                    time_created: value.time_created?,
                })
            }
        }

        pub struct IpPoolRangeResultsPage {
            items: Result<Vec<super::IpPoolRange>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for IpPoolRangeResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolRangeResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::IpPoolRange>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolRangeResultsPage> for super::IpPoolRangeResultsPage {
            type Error = String;
            fn try_from(value: IpPoolRangeResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct IpPoolResultsPage {
            items: Result<Vec<super::IpPool>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for IpPoolResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl IpPoolResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::IpPool>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolResultsPage> for super::IpPoolResultsPage {
            type Error = String;
            fn try_from(value: IpPoolResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct IpPoolUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for IpPoolUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl IpPoolUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<IpPoolUpdate> for super::IpPoolUpdate {
            type Error = String;
            fn try_from(value: IpPoolUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct Ipv4Range {
            first: Result<std::net::Ipv4Addr, String>,
            last: Result<std::net::Ipv4Addr, String>,
        }

        impl Default for Ipv4Range {
            fn default() -> Self {
                Self {
                    first: Err("no value supplied for first".to_string()),
                    last: Err("no value supplied for last".to_string()),
                }
            }
        }

        impl Ipv4Range {
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv4Addr>,
                T::Error: std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn last<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv4Addr>,
                T::Error: std::fmt::Display,
            {
                self.last = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Ipv4Range> for super::Ipv4Range {
            type Error = String;
            fn try_from(value: Ipv4Range) -> Result<Self, String> {
                Ok(Self {
                    first: value.first?,
                    last: value.last?,
                })
            }
        }

        pub struct Ipv6Range {
            first: Result<std::net::Ipv6Addr, String>,
            last: Result<std::net::Ipv6Addr, String>,
        }

        impl Default for Ipv6Range {
            fn default() -> Self {
                Self {
                    first: Err("no value supplied for first".to_string()),
                    last: Err("no value supplied for last".to_string()),
                }
            }
        }

        impl Ipv6Range {
            pub fn first<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv6Addr>,
                T::Error: std::fmt::Display,
            {
                self.first = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for first: {}", e));
                self
            }
            pub fn last<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::Ipv6Addr>,
                T::Error: std::fmt::Display,
            {
                self.last = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for last: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Ipv6Range> for super::Ipv6Range {
            type Error = String;
            fn try_from(value: Ipv6Range) -> Result<Self, String> {
                Ok(Self {
                    first: value.first?,
                    last: value.last?,
                })
            }
        }

        pub struct Measurement {
            datum: Result<super::Datum, String>,
            timestamp: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Measurement {
            fn default() -> Self {
                Self {
                    datum: Err("no value supplied for datum".to_string()),
                    timestamp: Err("no value supplied for timestamp".to_string()),
                }
            }
        }

        impl Measurement {
            pub fn datum<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Datum>,
                T::Error: std::fmt::Display,
            {
                self.datum = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum: {}", e));
                self
            }
            pub fn timestamp<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.timestamp = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for timestamp: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Measurement> for super::Measurement {
            type Error = String;
            fn try_from(value: Measurement) -> Result<Self, String> {
                Ok(Self {
                    datum: value.datum?,
                    timestamp: value.timestamp?,
                })
            }
        }

        pub struct MeasurementResultsPage {
            items: Result<Vec<super::Measurement>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for MeasurementResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl MeasurementResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Measurement>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<MeasurementResultsPage> for super::MeasurementResultsPage {
            type Error = String;
            fn try_from(value: MeasurementResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct NetworkInterface {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            instance_id: Result<uuid::Uuid, String>,
            ip: Result<std::net::IpAddr, String>,
            mac: Result<super::MacAddr, String>,
            name: Result<super::Name, String>,
            primary: Result<bool, String>,
            subnet_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for NetworkInterface {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    instance_id: Err("no value supplied for instance_id".to_string()),
                    ip: Err("no value supplied for ip".to_string()),
                    mac: Err("no value supplied for mac".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    primary: Err("no value supplied for primary".to_string()),
                    subnet_id: Err("no value supplied for subnet_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl NetworkInterface {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn instance_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.instance_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for instance_id: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<std::net::IpAddr>,
                T::Error: std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn mac<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::MacAddr>,
                T::Error: std::fmt::Display,
            {
                self.mac = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for mac: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
            pub fn subnet_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.subnet_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterface> for super::NetworkInterface {
            type Error = String;
            fn try_from(value: NetworkInterface) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    instance_id: value.instance_id?,
                    ip: value.ip?,
                    mac: value.mac?,
                    name: value.name?,
                    primary: value.primary?,
                    subnet_id: value.subnet_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        pub struct NetworkInterfaceCreate {
            description: Result<String, String>,
            ip: Result<Option<std::net::IpAddr>, String>,
            name: Result<super::Name, String>,
            subnet_name: Result<super::Name, String>,
            vpc_name: Result<super::Name, String>,
        }

        impl Default for NetworkInterfaceCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ip: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                    subnet_name: Err("no value supplied for subnet_name".to_string()),
                    vpc_name: Err("no value supplied for vpc_name".to_string()),
                }
            }
        }

        impl NetworkInterfaceCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ip<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<std::net::IpAddr>>,
                T::Error: std::fmt::Display,
            {
                self.ip = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ip: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn subnet_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.subnet_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for subnet_name: {}", e));
                self
            }
            pub fn vpc_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.vpc_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterfaceCreate> for super::NetworkInterfaceCreate {
            type Error = String;
            fn try_from(value: NetworkInterfaceCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    ip: value.ip?,
                    name: value.name?,
                    subnet_name: value.subnet_name?,
                    vpc_name: value.vpc_name?,
                })
            }
        }

        pub struct NetworkInterfaceResultsPage {
            items: Result<Vec<super::NetworkInterface>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for NetworkInterfaceResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl NetworkInterfaceResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::NetworkInterface>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterfaceResultsPage> for super::NetworkInterfaceResultsPage {
            type Error = String;
            fn try_from(value: NetworkInterfaceResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct NetworkInterfaceUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
            primary: Result<bool, String>,
        }

        impl Default for NetworkInterfaceUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                    primary: Ok(Default::default()),
                }
            }
        }

        impl NetworkInterfaceUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn primary<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.primary = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for primary: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<NetworkInterfaceUpdate> for super::NetworkInterfaceUpdate {
            type Error = String;
            fn try_from(value: NetworkInterfaceUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    primary: value.primary?,
                })
            }
        }

        pub struct Organization {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Organization {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Organization {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Organization> for super::Organization {
            type Error = String;
            fn try_from(value: Organization) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct OrganizationCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for OrganizationCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl OrganizationCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationCreate> for super::OrganizationCreate {
            type Error = String;
            fn try_from(value: OrganizationCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct OrganizationResultsPage {
            items: Result<Vec<super::Organization>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for OrganizationResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl OrganizationResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Organization>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationResultsPage> for super::OrganizationResultsPage {
            type Error = String;
            fn try_from(value: OrganizationResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct OrganizationRolePolicy {
            role_assignments: Result<Vec<super::OrganizationRoleRoleAssignment>, String>,
        }

        impl Default for OrganizationRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl OrganizationRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::OrganizationRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<OrganizationRolePolicy> for super::OrganizationRolePolicy {
            type Error = String;
            fn try_from(value: OrganizationRolePolicy) -> Result<Self, String> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        pub struct OrganizationRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::OrganizationRole, String>,
        }

        impl Default for OrganizationRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl OrganizationRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::OrganizationRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationRoleRoleAssignment>
            for super::OrganizationRoleRoleAssignment
        {
            type Error = String;
            fn try_from(value: OrganizationRoleRoleAssignment) -> Result<Self, String> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        pub struct OrganizationUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for OrganizationUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl OrganizationUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<OrganizationUpdate> for super::OrganizationUpdate {
            type Error = String;
            fn try_from(value: OrganizationUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct PhysicalDisk {
            disk_type: Result<super::PhysicalDiskType, String>,
            id: Result<uuid::Uuid, String>,
            model: Result<String, String>,
            serial: Result<String, String>,
            sled_id: Result<Option<uuid::Uuid>, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vendor: Result<String, String>,
        }

        impl Default for PhysicalDisk {
            fn default() -> Self {
                Self {
                    disk_type: Err("no value supplied for disk_type".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    model: Err("no value supplied for model".to_string()),
                    serial: Err("no value supplied for serial".to_string()),
                    sled_id: Ok(Default::default()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vendor: Err("no value supplied for vendor".to_string()),
                }
            }
        }

        impl PhysicalDisk {
            pub fn disk_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::PhysicalDiskType>,
                T::Error: std::fmt::Display,
            {
                self.disk_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_type: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn model<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.model = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for model: {}", e));
                self
            }
            pub fn serial<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.serial = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for serial: {}", e));
                self
            }
            pub fn sled_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<uuid::Uuid>>,
                T::Error: std::fmt::Display,
            {
                self.sled_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for sled_id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vendor<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.vendor = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vendor: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<PhysicalDisk> for super::PhysicalDisk {
            type Error = String;
            fn try_from(value: PhysicalDisk) -> Result<Self, String> {
                Ok(Self {
                    disk_type: value.disk_type?,
                    id: value.id?,
                    model: value.model?,
                    serial: value.serial?,
                    sled_id: value.sled_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vendor: value.vendor?,
                })
            }
        }

        pub struct PhysicalDiskResultsPage {
            items: Result<Vec<super::PhysicalDisk>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for PhysicalDiskResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl PhysicalDiskResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::PhysicalDisk>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<PhysicalDiskResultsPage> for super::PhysicalDiskResultsPage {
            type Error = String;
            fn try_from(value: PhysicalDiskResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Project {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            organization_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Project {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    organization_id: Err("no value supplied for organization_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Project {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn organization_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.organization_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for organization_id: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Project> for super::Project {
            type Error = String;
            fn try_from(value: Project) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    organization_id: value.organization_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct ProjectCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for ProjectCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl ProjectCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectCreate> for super::ProjectCreate {
            type Error = String;
            fn try_from(value: ProjectCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct ProjectResultsPage {
            items: Result<Vec<super::Project>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for ProjectResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl ProjectResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Project>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectResultsPage> for super::ProjectResultsPage {
            type Error = String;
            fn try_from(value: ProjectResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct ProjectRolePolicy {
            role_assignments: Result<Vec<super::ProjectRoleRoleAssignment>, String>,
        }

        impl Default for ProjectRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl ProjectRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::ProjectRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<ProjectRolePolicy> for super::ProjectRolePolicy {
            type Error = String;
            fn try_from(value: ProjectRolePolicy) -> Result<Self, String> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        pub struct ProjectRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::ProjectRole, String>,
        }

        impl Default for ProjectRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl ProjectRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ProjectRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectRoleRoleAssignment> for super::ProjectRoleRoleAssignment {
            type Error = String;
            fn try_from(value: ProjectRoleRoleAssignment) -> Result<Self, String> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        pub struct ProjectUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for ProjectUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl ProjectUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<ProjectUpdate> for super::ProjectUpdate {
            type Error = String;
            fn try_from(value: ProjectUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct Rack {
            id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Rack {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Rack {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Rack> for super::Rack {
            type Error = String;
            fn try_from(value: Rack) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct RackResultsPage {
            items: Result<Vec<super::Rack>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for RackResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RackResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Rack>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RackResultsPage> for super::RackResultsPage {
            type Error = String;
            fn try_from(value: RackResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Role {
            description: Result<String, String>,
            name: Result<super::RoleName, String>,
        }

        impl Default for Role {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl Role {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RoleName>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Role> for super::Role {
            type Error = String;
            fn try_from(value: Role) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct RoleResultsPage {
            items: Result<Vec<super::Role>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for RoleResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RoleResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Role>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RoleResultsPage> for super::RoleResultsPage {
            type Error = String;
            fn try_from(value: RoleResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct RouterRoute {
            description: Result<String, String>,
            destination: Result<super::RouteDestination, String>,
            id: Result<uuid::Uuid, String>,
            kind: Result<super::RouterRouteKind, String>,
            name: Result<super::Name, String>,
            target: Result<super::RouteTarget, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_router_id: Result<uuid::Uuid, String>,
        }

        impl Default for RouterRoute {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    destination: Err("no value supplied for destination".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    target: Err("no value supplied for target".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_router_id: Err("no value supplied for vpc_router_id".to_string()),
                }
            }
        }

        impl RouterRoute {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteDestination>,
                T::Error: std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouterRouteKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteTarget>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_router_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_router_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for vpc_router_id: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<RouterRoute> for super::RouterRoute {
            type Error = String;
            fn try_from(value: RouterRoute) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    target: value.target?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_router_id: value.vpc_router_id?,
                })
            }
        }

        pub struct RouterRouteCreate {
            description: Result<String, String>,
            destination: Result<super::RouteDestination, String>,
            name: Result<super::Name, String>,
            target: Result<super::RouteTarget, String>,
        }

        impl Default for RouterRouteCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    destination: Err("no value supplied for destination".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl RouterRouteCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteDestination>,
                T::Error: std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteTarget>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RouterRouteCreate> for super::RouterRouteCreate {
            type Error = String;
            fn try_from(value: RouterRouteCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    name: value.name?,
                    target: value.target?,
                })
            }
        }

        pub struct RouterRouteResultsPage {
            items: Result<Vec<super::RouterRoute>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for RouterRouteResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl RouterRouteResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::RouterRoute>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RouterRouteResultsPage> for super::RouterRouteResultsPage {
            type Error = String;
            fn try_from(value: RouterRouteResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct RouterRouteUpdate {
            description: Result<Option<String>, String>,
            destination: Result<super::RouteDestination, String>,
            name: Result<Option<super::Name>, String>,
            target: Result<super::RouteTarget, String>,
        }

        impl Default for RouterRouteUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    destination: Err("no value supplied for destination".to_string()),
                    name: Ok(Default::default()),
                    target: Err("no value supplied for target".to_string()),
                }
            }
        }

        impl RouterRouteUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn destination<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteDestination>,
                T::Error: std::fmt::Display,
            {
                self.destination = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for destination: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn target<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::RouteTarget>,
                T::Error: std::fmt::Display,
            {
                self.target = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for target: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<RouterRouteUpdate> for super::RouterRouteUpdate {
            type Error = String;
            fn try_from(value: RouterRouteUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    destination: value.destination?,
                    name: value.name?,
                    target: value.target?,
                })
            }
        }

        pub struct Saga {
            id: Result<uuid::Uuid, String>,
            state: Result<super::SagaState, String>,
        }

        impl Default for Saga {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    state: Err("no value supplied for state".to_string()),
                }
            }
        }

        impl Saga {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SagaState>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<Saga> for super::Saga {
            type Error = String;
            fn try_from(value: Saga) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    state: value.state?,
                })
            }
        }

        pub struct SagaResultsPage {
            items: Result<Vec<super::Saga>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SagaResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SagaResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Saga>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SagaResultsPage> for super::SagaResultsPage {
            type Error = String;
            fn try_from(value: SagaResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct SamlIdentityProvider {
            acs_url: Result<String, String>,
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            idp_entity_id: Result<String, String>,
            name: Result<super::Name, String>,
            public_cert: Result<Option<String>, String>,
            slo_url: Result<String, String>,
            sp_client_id: Result<String, String>,
            technical_contact_email: Result<String, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for SamlIdentityProvider {
            fn default() -> Self {
                Self {
                    acs_url: Err("no value supplied for acs_url".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    idp_entity_id: Err("no value supplied for idp_entity_id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_cert: Ok(Default::default()),
                    slo_url: Err("no value supplied for slo_url".to_string()),
                    sp_client_id: Err("no value supplied for sp_client_id".to_string()),
                    technical_contact_email: Err(
                        "no value supplied for technical_contact_email".to_string()
                    ),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SamlIdentityProvider {
            pub fn acs_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.acs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for acs_url: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn idp_entity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.idp_entity_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idp_entity_id: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_cert<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.public_cert = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_cert: {}", e));
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {}", e));
                self
            }
            pub fn sp_client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.sp_client_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sp_client_id: {}", e)
                });
                self
            }
            pub fn technical_contact_email<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.technical_contact_email = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for technical_contact_email: {}",
                        e
                    )
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<SamlIdentityProvider> for super::SamlIdentityProvider {
            type Error = String;
            fn try_from(value: SamlIdentityProvider) -> Result<Self, String> {
                Ok(Self {
                    acs_url: value.acs_url?,
                    description: value.description?,
                    id: value.id?,
                    idp_entity_id: value.idp_entity_id?,
                    name: value.name?,
                    public_cert: value.public_cert?,
                    slo_url: value.slo_url?,
                    sp_client_id: value.sp_client_id?,
                    technical_contact_email: value.technical_contact_email?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct SamlIdentityProviderCreate {
            acs_url: Result<String, String>,
            description: Result<String, String>,
            group_attribute_name: Result<Option<String>, String>,
            idp_entity_id: Result<String, String>,
            idp_metadata_source: Result<super::IdpMetadataSource, String>,
            name: Result<super::Name, String>,
            signing_keypair: Result<Option<super::DerEncodedKeyPair>, String>,
            slo_url: Result<String, String>,
            sp_client_id: Result<String, String>,
            technical_contact_email: Result<String, String>,
        }

        impl Default for SamlIdentityProviderCreate {
            fn default() -> Self {
                Self {
                    acs_url: Err("no value supplied for acs_url".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    group_attribute_name: Ok(Default::default()),
                    idp_entity_id: Err("no value supplied for idp_entity_id".to_string()),
                    idp_metadata_source: Err(
                        "no value supplied for idp_metadata_source".to_string()
                    ),
                    name: Err("no value supplied for name".to_string()),
                    signing_keypair: Ok(Default::default()),
                    slo_url: Err("no value supplied for slo_url".to_string()),
                    sp_client_id: Err("no value supplied for sp_client_id".to_string()),
                    technical_contact_email: Err(
                        "no value supplied for technical_contact_email".to_string()
                    ),
                }
            }
        }

        impl SamlIdentityProviderCreate {
            pub fn acs_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.acs_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for acs_url: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn group_attribute_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.group_attribute_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for group_attribute_name: {}",
                        e
                    )
                });
                self
            }
            pub fn idp_entity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.idp_entity_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for idp_entity_id: {}", e)
                });
                self
            }
            pub fn idp_metadata_source<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdpMetadataSource>,
                T::Error: std::fmt::Display,
            {
                self.idp_metadata_source = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for idp_metadata_source: {}",
                        e
                    )
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn signing_keypair<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::DerEncodedKeyPair>>,
                T::Error: std::fmt::Display,
            {
                self.signing_keypair = value.try_into().map_err(|e| {
                    format!("error converting supplied value for signing_keypair: {}", e)
                });
                self
            }
            pub fn slo_url<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.slo_url = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for slo_url: {}", e));
                self
            }
            pub fn sp_client_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.sp_client_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for sp_client_id: {}", e)
                });
                self
            }
            pub fn technical_contact_email<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.technical_contact_email = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for technical_contact_email: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<SamlIdentityProviderCreate> for super::SamlIdentityProviderCreate {
            type Error = String;
            fn try_from(value: SamlIdentityProviderCreate) -> Result<Self, String> {
                Ok(Self {
                    acs_url: value.acs_url?,
                    description: value.description?,
                    group_attribute_name: value.group_attribute_name?,
                    idp_entity_id: value.idp_entity_id?,
                    idp_metadata_source: value.idp_metadata_source?,
                    name: value.name?,
                    signing_keypair: value.signing_keypair?,
                    slo_url: value.slo_url?,
                    sp_client_id: value.sp_client_id?,
                    technical_contact_email: value.technical_contact_email?,
                })
            }
        }

        pub struct Silo {
            description: Result<String, String>,
            discoverable: Result<bool, String>,
            id: Result<uuid::Uuid, String>,
            identity_mode: Result<super::SiloIdentityMode, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Silo {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    discoverable: Err("no value supplied for discoverable".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    identity_mode: Err("no value supplied for identity_mode".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Silo {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn discoverable<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.discoverable = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discoverable: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn identity_mode<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SiloIdentityMode>,
                T::Error: std::fmt::Display,
            {
                self.identity_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_mode: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Silo> for super::Silo {
            type Error = String;
            fn try_from(value: Silo) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    discoverable: value.discoverable?,
                    id: value.id?,
                    identity_mode: value.identity_mode?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct SiloCreate {
            admin_group_name: Result<Option<String>, String>,
            description: Result<String, String>,
            discoverable: Result<bool, String>,
            identity_mode: Result<super::SiloIdentityMode, String>,
            name: Result<super::Name, String>,
        }

        impl Default for SiloCreate {
            fn default() -> Self {
                Self {
                    admin_group_name: Ok(Default::default()),
                    description: Err("no value supplied for description".to_string()),
                    discoverable: Err("no value supplied for discoverable".to_string()),
                    identity_mode: Err("no value supplied for identity_mode".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl SiloCreate {
            pub fn admin_group_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.admin_group_name = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for admin_group_name: {}",
                        e
                    )
                });
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn discoverable<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<bool>,
                T::Error: std::fmt::Display,
            {
                self.discoverable = value.try_into().map_err(|e| {
                    format!("error converting supplied value for discoverable: {}", e)
                });
                self
            }
            pub fn identity_mode<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SiloIdentityMode>,
                T::Error: std::fmt::Display,
            {
                self.identity_mode = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_mode: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SiloCreate> for super::SiloCreate {
            type Error = String;
            fn try_from(value: SiloCreate) -> Result<Self, String> {
                Ok(Self {
                    admin_group_name: value.admin_group_name?,
                    description: value.description?,
                    discoverable: value.discoverable?,
                    identity_mode: value.identity_mode?,
                    name: value.name?,
                })
            }
        }

        pub struct SiloResultsPage {
            items: Result<Vec<super::Silo>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SiloResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SiloResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Silo>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SiloResultsPage> for super::SiloResultsPage {
            type Error = String;
            fn try_from(value: SiloResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct SiloRolePolicy {
            role_assignments: Result<Vec<super::SiloRoleRoleAssignment>, String>,
        }

        impl Default for SiloRolePolicy {
            fn default() -> Self {
                Self {
                    role_assignments: Err("no value supplied for role_assignments".to_string()),
                }
            }
        }

        impl SiloRolePolicy {
            pub fn role_assignments<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SiloRoleRoleAssignment>>,
                T::Error: std::fmt::Display,
            {
                self.role_assignments = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for role_assignments: {}",
                        e
                    )
                });
                self
            }
        }

        impl std::convert::TryFrom<SiloRolePolicy> for super::SiloRolePolicy {
            type Error = String;
            fn try_from(value: SiloRolePolicy) -> Result<Self, String> {
                Ok(Self {
                    role_assignments: value.role_assignments?,
                })
            }
        }

        pub struct SiloRoleRoleAssignment {
            identity_id: Result<uuid::Uuid, String>,
            identity_type: Result<super::IdentityType, String>,
            role_name: Result<super::SiloRole, String>,
        }

        impl Default for SiloRoleRoleAssignment {
            fn default() -> Self {
                Self {
                    identity_id: Err("no value supplied for identity_id".to_string()),
                    identity_type: Err("no value supplied for identity_type".to_string()),
                    role_name: Err("no value supplied for role_name".to_string()),
                }
            }
        }

        impl SiloRoleRoleAssignment {
            pub fn identity_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.identity_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for identity_id: {}", e));
                self
            }
            pub fn identity_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::IdentityType>,
                T::Error: std::fmt::Display,
            {
                self.identity_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for identity_type: {}", e)
                });
                self
            }
            pub fn role_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SiloRole>,
                T::Error: std::fmt::Display,
            {
                self.role_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for role_name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SiloRoleRoleAssignment> for super::SiloRoleRoleAssignment {
            type Error = String;
            fn try_from(value: SiloRoleRoleAssignment) -> Result<Self, String> {
                Ok(Self {
                    identity_id: value.identity_id?,
                    identity_type: value.identity_type?,
                    role_name: value.role_name?,
                })
            }
        }

        pub struct Sled {
            baseboard: Result<super::Baseboard, String>,
            id: Result<uuid::Uuid, String>,
            rack_id: Result<uuid::Uuid, String>,
            service_address: Result<String, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Sled {
            fn default() -> Self {
                Self {
                    baseboard: Err("no value supplied for baseboard".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    rack_id: Err("no value supplied for rack_id".to_string()),
                    service_address: Err("no value supplied for service_address".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Sled {
            pub fn baseboard<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Baseboard>,
                T::Error: std::fmt::Display,
            {
                self.baseboard = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for baseboard: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn rack_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.rack_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rack_id: {}", e));
                self
            }
            pub fn service_address<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.service_address = value.try_into().map_err(|e| {
                    format!("error converting supplied value for service_address: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Sled> for super::Sled {
            type Error = String;
            fn try_from(value: Sled) -> Result<Self, String> {
                Ok(Self {
                    baseboard: value.baseboard?,
                    id: value.id?,
                    rack_id: value.rack_id?,
                    service_address: value.service_address?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct SledResultsPage {
            items: Result<Vec<super::Sled>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SledResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SledResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Sled>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SledResultsPage> for super::SledResultsPage {
            type Error = String;
            fn try_from(value: SledResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct Snapshot {
            description: Result<String, String>,
            disk_id: Result<uuid::Uuid, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            size: Result<super::ByteCount, String>,
            state: Result<super::SnapshotState, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Snapshot {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk_id: Err("no value supplied for disk_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    size: Err("no value supplied for size".to_string()),
                    state: Err("no value supplied for state".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Snapshot {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.disk_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk_id: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn size<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::ByteCount>,
                T::Error: std::fmt::Display,
            {
                self.size = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for size: {}", e));
                self
            }
            pub fn state<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SnapshotState>,
                T::Error: std::fmt::Display,
            {
                self.state = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for state: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Snapshot> for super::Snapshot {
            type Error = String;
            fn try_from(value: Snapshot) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    disk_id: value.disk_id?,
                    id: value.id?,
                    name: value.name?,
                    project_id: value.project_id?,
                    size: value.size?,
                    state: value.state?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct SnapshotCreate {
            description: Result<String, String>,
            disk: Result<super::Name, String>,
            name: Result<super::Name, String>,
        }

        impl Default for SnapshotCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    disk: Err("no value supplied for disk".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl SnapshotCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn disk<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.disk = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for disk: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SnapshotCreate> for super::SnapshotCreate {
            type Error = String;
            fn try_from(value: SnapshotCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    disk: value.disk?,
                    name: value.name?,
                })
            }
        }

        pub struct SnapshotResultsPage {
            items: Result<Vec<super::Snapshot>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SnapshotResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SnapshotResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Snapshot>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SnapshotResultsPage> for super::SnapshotResultsPage {
            type Error = String;
            fn try_from(value: SnapshotResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct SpoofLoginBody {
            username: Result<String, String>,
        }

        impl Default for SpoofLoginBody {
            fn default() -> Self {
                Self {
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }

        impl SpoofLoginBody {
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SpoofLoginBody> for super::SpoofLoginBody {
            type Error = String;
            fn try_from(value: SpoofLoginBody) -> Result<Self, String> {
                Ok(Self {
                    username: value.username?,
                })
            }
        }

        pub struct SshKey {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            public_key: Result<String, String>,
            silo_user_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for SshKey {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                    silo_user_id: Err("no value supplied for silo_user_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl SshKey {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
            pub fn silo_user_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.silo_user_id = value.try_into().map_err(|e| {
                    format!("error converting supplied value for silo_user_id: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<SshKey> for super::SshKey {
            type Error = String;
            fn try_from(value: SshKey) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    public_key: value.public_key?,
                    silo_user_id: value.silo_user_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct SshKeyCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
            public_key: Result<String, String>,
        }

        impl Default for SshKeyCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    public_key: Err("no value supplied for public_key".to_string()),
                }
            }
        }

        impl SshKeyCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn public_key<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.public_key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for public_key: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SshKeyCreate> for super::SshKeyCreate {
            type Error = String;
            fn try_from(value: SshKeyCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                    public_key: value.public_key?,
                })
            }
        }

        pub struct SshKeyResultsPage {
            items: Result<Vec<super::SshKey>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SshKeyResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SshKeyResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SshKey>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SshKeyResultsPage> for super::SshKeyResultsPage {
            type Error = String;
            fn try_from(value: SshKeyResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct SystemUpdate {
            id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for SystemUpdate {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl SystemUpdate {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SystemUpdate> for super::SystemUpdate {
            type Error = String;
            fn try_from(value: SystemUpdate) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        pub struct SystemUpdateResultsPage {
            items: Result<Vec<super::SystemUpdate>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for SystemUpdateResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl SystemUpdateResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::SystemUpdate>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SystemUpdateResultsPage> for super::SystemUpdateResultsPage {
            type Error = String;
            fn try_from(value: SystemUpdateResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct SystemUpdateStart {
            version: Result<super::SemverVersion, String>,
        }

        impl Default for SystemUpdateStart {
            fn default() -> Self {
                Self {
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl SystemUpdateStart {
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<SystemUpdateStart> for super::SystemUpdateStart {
            type Error = String;
            fn try_from(value: SystemUpdateStart) -> Result<Self, String> {
                Ok(Self {
                    version: value.version?,
                })
            }
        }

        pub struct SystemVersion {
            status: Result<super::UpdateStatus, String>,
            version_range: Result<super::VersionRange, String>,
        }

        impl Default for SystemVersion {
            fn default() -> Self {
                Self {
                    status: Err("no value supplied for status".to_string()),
                    version_range: Err("no value supplied for version_range".to_string()),
                }
            }
        }

        impl SystemVersion {
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn version_range<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VersionRange>,
                T::Error: std::fmt::Display,
            {
                self.version_range = value.try_into().map_err(|e| {
                    format!("error converting supplied value for version_range: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<SystemVersion> for super::SystemVersion {
            type Error = String;
            fn try_from(value: SystemVersion) -> Result<Self, String> {
                Ok(Self {
                    status: value.status?,
                    version_range: value.version_range?,
                })
            }
        }

        pub struct TimeseriesSchema {
            created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            datum_type: Result<super::DatumType, String>,
            field_schema: Result<Vec<super::FieldSchema>, String>,
            timeseries_name: Result<super::TimeseriesName, String>,
        }

        impl Default for TimeseriesSchema {
            fn default() -> Self {
                Self {
                    created: Err("no value supplied for created".to_string()),
                    datum_type: Err("no value supplied for datum_type".to_string()),
                    field_schema: Err("no value supplied for field_schema".to_string()),
                    timeseries_name: Err("no value supplied for timeseries_name".to_string()),
                }
            }
        }

        impl TimeseriesSchema {
            pub fn created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.created = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created: {}", e));
                self
            }
            pub fn datum_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::DatumType>,
                T::Error: std::fmt::Display,
            {
                self.datum_type = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datum_type: {}", e));
                self
            }
            pub fn field_schema<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::FieldSchema>>,
                T::Error: std::fmt::Display,
            {
                self.field_schema = value.try_into().map_err(|e| {
                    format!("error converting supplied value for field_schema: {}", e)
                });
                self
            }
            pub fn timeseries_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::TimeseriesName>,
                T::Error: std::fmt::Display,
            {
                self.timeseries_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for timeseries_name: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<TimeseriesSchema> for super::TimeseriesSchema {
            type Error = String;
            fn try_from(value: TimeseriesSchema) -> Result<Self, String> {
                Ok(Self {
                    created: value.created?,
                    datum_type: value.datum_type?,
                    field_schema: value.field_schema?,
                    timeseries_name: value.timeseries_name?,
                })
            }
        }

        pub struct TimeseriesSchemaResultsPage {
            items: Result<Vec<super::TimeseriesSchema>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for TimeseriesSchemaResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl TimeseriesSchemaResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::TimeseriesSchema>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<TimeseriesSchemaResultsPage> for super::TimeseriesSchemaResultsPage {
            type Error = String;
            fn try_from(value: TimeseriesSchemaResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct UpdateDeployment {
            id: Result<uuid::Uuid, String>,
            status: Result<super::UpdateStatus, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for UpdateDeployment {
            fn default() -> Self {
                Self {
                    id: Err("no value supplied for id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl UpdateDeployment {
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateDeployment> for super::UpdateDeployment {
            type Error = String;
            fn try_from(value: UpdateDeployment) -> Result<Self, String> {
                Ok(Self {
                    id: value.id?,
                    status: value.status?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        pub struct UpdateDeploymentResultsPage {
            items: Result<Vec<super::UpdateDeployment>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UpdateDeploymentResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UpdateDeploymentResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::UpdateDeployment>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateDeploymentResultsPage> for super::UpdateDeploymentResultsPage {
            type Error = String;
            fn try_from(value: UpdateDeploymentResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct UpdateableComponent {
            component_type: Result<super::UpdateableComponentType, String>,
            device_id: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            status: Result<super::UpdateStatus, String>,
            system_version: Result<super::SemverVersion, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            version: Result<super::SemverVersion, String>,
        }

        impl Default for UpdateableComponent {
            fn default() -> Self {
                Self {
                    component_type: Err("no value supplied for component_type".to_string()),
                    device_id: Err("no value supplied for device_id".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    system_version: Err("no value supplied for system_version".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    version: Err("no value supplied for version".to_string()),
                }
            }
        }

        impl UpdateableComponent {
            pub fn component_type<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateableComponentType>,
                T::Error: std::fmt::Display,
            {
                self.component_type = value.try_into().map_err(|e| {
                    format!("error converting supplied value for component_type: {}", e)
                });
                self
            }
            pub fn device_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.device_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for device_id: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UpdateStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn system_version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.system_version = value.try_into().map_err(|e| {
                    format!("error converting supplied value for system_version: {}", e)
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn version<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.version = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for version: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateableComponent> for super::UpdateableComponent {
            type Error = String;
            fn try_from(value: UpdateableComponent) -> Result<Self, String> {
                Ok(Self {
                    component_type: value.component_type?,
                    device_id: value.device_id?,
                    id: value.id?,
                    status: value.status?,
                    system_version: value.system_version?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    version: value.version?,
                })
            }
        }

        pub struct UpdateableComponentResultsPage {
            items: Result<Vec<super::UpdateableComponent>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UpdateableComponentResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UpdateableComponentResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::UpdateableComponent>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UpdateableComponentResultsPage>
            for super::UpdateableComponentResultsPage
        {
            type Error = String;
            fn try_from(value: UpdateableComponentResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct User {
            display_name: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            silo_id: Result<uuid::Uuid, String>,
        }

        impl Default for User {
            fn default() -> Self {
                Self {
                    display_name: Err("no value supplied for display_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    silo_id: Err("no value supplied for silo_id".to_string()),
                }
            }
        }

        impl User {
            pub fn display_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.display_name = value.try_into().map_err(|e| {
                    format!("error converting supplied value for display_name: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn silo_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.silo_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for silo_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<User> for super::User {
            type Error = String;
            fn try_from(value: User) -> Result<Self, String> {
                Ok(Self {
                    display_name: value.display_name?,
                    id: value.id?,
                    silo_id: value.silo_id?,
                })
            }
        }

        pub struct UserBuiltin {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for UserBuiltin {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl UserBuiltin {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<UserBuiltin> for super::UserBuiltin {
            type Error = String;
            fn try_from(value: UserBuiltin) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct UserBuiltinResultsPage {
            items: Result<Vec<super::UserBuiltin>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UserBuiltinResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UserBuiltinResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::UserBuiltin>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserBuiltinResultsPage> for super::UserBuiltinResultsPage {
            type Error = String;
            fn try_from(value: UserBuiltinResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct UserCreate {
            external_id: Result<super::UserId, String>,
            password: Result<super::UserPassword, String>,
        }

        impl Default for UserCreate {
            fn default() -> Self {
                Self {
                    external_id: Err("no value supplied for external_id".to_string()),
                    password: Err("no value supplied for password".to_string()),
                }
            }
        }

        impl UserCreate {
            pub fn external_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UserId>,
                T::Error: std::fmt::Display,
            {
                self.external_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for external_id: {}", e));
                self
            }
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UserPassword>,
                T::Error: std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserCreate> for super::UserCreate {
            type Error = String;
            fn try_from(value: UserCreate) -> Result<Self, String> {
                Ok(Self {
                    external_id: value.external_id?,
                    password: value.password?,
                })
            }
        }

        pub struct UserResultsPage {
            items: Result<Vec<super::User>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for UserResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl UserResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::User>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UserResultsPage> for super::UserResultsPage {
            type Error = String;
            fn try_from(value: UserResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct UsernamePasswordCredentials {
            password: Result<super::Password, String>,
            username: Result<super::UserId, String>,
        }

        impl Default for UsernamePasswordCredentials {
            fn default() -> Self {
                Self {
                    password: Err("no value supplied for password".to_string()),
                    username: Err("no value supplied for username".to_string()),
                }
            }
        }

        impl UsernamePasswordCredentials {
            pub fn password<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Password>,
                T::Error: std::fmt::Display,
            {
                self.password = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for password: {}", e));
                self
            }
            pub fn username<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::UserId>,
                T::Error: std::fmt::Display,
            {
                self.username = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for username: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<UsernamePasswordCredentials> for super::UsernamePasswordCredentials {
            type Error = String;
            fn try_from(value: UsernamePasswordCredentials) -> Result<Self, String> {
                Ok(Self {
                    password: value.password?,
                    username: value.username?,
                })
            }
        }

        pub struct VersionRange {
            high: Result<super::SemverVersion, String>,
            low: Result<super::SemverVersion, String>,
        }

        impl Default for VersionRange {
            fn default() -> Self {
                Self {
                    high: Err("no value supplied for high".to_string()),
                    low: Err("no value supplied for low".to_string()),
                }
            }
        }

        impl VersionRange {
            pub fn high<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.high = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for high: {}", e));
                self
            }
            pub fn low<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::SemverVersion>,
                T::Error: std::fmt::Display,
            {
                self.low = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for low: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VersionRange> for super::VersionRange {
            type Error = String;
            fn try_from(value: VersionRange) -> Result<Self, String> {
                Ok(Self {
                    high: value.high?,
                    low: value.low?,
                })
            }
        }

        pub struct Vpc {
            description: Result<String, String>,
            dns_name: Result<super::Name, String>,
            id: Result<uuid::Uuid, String>,
            ipv6_prefix: Result<super::Ipv6Net, String>,
            name: Result<super::Name, String>,
            project_id: Result<uuid::Uuid, String>,
            system_router_id: Result<uuid::Uuid, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
        }

        impl Default for Vpc {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    dns_name: Err("no value supplied for dns_name".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    ipv6_prefix: Err("no value supplied for ipv6_prefix".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    project_id: Err("no value supplied for project_id".to_string()),
                    system_router_id: Err("no value supplied for system_router_id".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                }
            }
        }

        impl Vpc {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ipv6_prefix<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv6Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_prefix: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn project_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.project_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for project_id: {}", e));
                self
            }
            pub fn system_router_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.system_router_id = value.try_into().map_err(|e| {
                    format!(
                        "error converting supplied value for system_router_id: {}",
                        e
                    )
                });
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
        }

        impl std::convert::TryFrom<Vpc> for super::Vpc {
            type Error = String;
            fn try_from(value: Vpc) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    id: value.id?,
                    ipv6_prefix: value.ipv6_prefix?,
                    name: value.name?,
                    project_id: value.project_id?,
                    system_router_id: value.system_router_id?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                })
            }
        }

        pub struct VpcCreate {
            description: Result<String, String>,
            dns_name: Result<super::Name, String>,
            ipv6_prefix: Result<Option<super::Ipv6Net>, String>,
            name: Result<super::Name, String>,
        }

        impl Default for VpcCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    dns_name: Err("no value supplied for dns_name".to_string()),
                    ipv6_prefix: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn ipv6_prefix<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Ipv6Net>>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_prefix = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_prefix: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcCreate> for super::VpcCreate {
            type Error = String;
            fn try_from(value: VpcCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    ipv6_prefix: value.ipv6_prefix?,
                    name: value.name?,
                })
            }
        }

        pub struct VpcFirewallRule {
            action: Result<super::VpcFirewallRuleAction, String>,
            description: Result<String, String>,
            direction: Result<super::VpcFirewallRuleDirection, String>,
            filters: Result<super::VpcFirewallRuleFilter, String>,
            id: Result<uuid::Uuid, String>,
            name: Result<super::Name, String>,
            priority: Result<u16, String>,
            status: Result<super::VpcFirewallRuleStatus, String>,
            targets: Result<Vec<super::VpcFirewallRuleTarget>, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for VpcFirewallRule {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    direction: Err("no value supplied for direction".to_string()),
                    filters: Err("no value supplied for filters".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    targets: Err("no value supplied for targets".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcFirewallRule {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleAction>,
                T::Error: std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn direction<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleDirection>,
                T::Error: std::fmt::Display,
            {
                self.direction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for direction: {}", e));
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleFilter>,
                T::Error: std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for filters: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u16>,
                T::Error: std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn targets<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRuleTarget>>,
                T::Error: std::fmt::Display,
            {
                self.targets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for targets: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRule> for super::VpcFirewallRule {
            type Error = String;
            fn try_from(value: VpcFirewallRule) -> Result<Self, String> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    direction: value.direction?,
                    filters: value.filters?,
                    id: value.id?,
                    name: value.name?,
                    priority: value.priority?,
                    status: value.status?,
                    targets: value.targets?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        pub struct VpcFirewallRuleFilter {
            hosts: Result<Option<Vec<super::VpcFirewallRuleHostFilter>>, String>,
            ports: Result<Option<Vec<super::L4PortRange>>, String>,
            protocols: Result<Option<Vec<super::VpcFirewallRuleProtocol>>, String>,
        }

        impl Default for VpcFirewallRuleFilter {
            fn default() -> Self {
                Self {
                    hosts: Ok(Default::default()),
                    ports: Ok(Default::default()),
                    protocols: Ok(Default::default()),
                }
            }
        }

        impl VpcFirewallRuleFilter {
            pub fn hosts<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<Vec<super::VpcFirewallRuleHostFilter>>>,
                T::Error: std::fmt::Display,
            {
                self.hosts = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for hosts: {}", e));
                self
            }
            pub fn ports<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<Vec<super::L4PortRange>>>,
                T::Error: std::fmt::Display,
            {
                self.ports = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ports: {}", e));
                self
            }
            pub fn protocols<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<Vec<super::VpcFirewallRuleProtocol>>>,
                T::Error: std::fmt::Display,
            {
                self.protocols = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for protocols: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRuleFilter> for super::VpcFirewallRuleFilter {
            type Error = String;
            fn try_from(value: VpcFirewallRuleFilter) -> Result<Self, String> {
                Ok(Self {
                    hosts: value.hosts?,
                    ports: value.ports?,
                    protocols: value.protocols?,
                })
            }
        }

        pub struct VpcFirewallRuleUpdate {
            action: Result<super::VpcFirewallRuleAction, String>,
            description: Result<String, String>,
            direction: Result<super::VpcFirewallRuleDirection, String>,
            filters: Result<super::VpcFirewallRuleFilter, String>,
            name: Result<super::Name, String>,
            priority: Result<u16, String>,
            status: Result<super::VpcFirewallRuleStatus, String>,
            targets: Result<Vec<super::VpcFirewallRuleTarget>, String>,
        }

        impl Default for VpcFirewallRuleUpdate {
            fn default() -> Self {
                Self {
                    action: Err("no value supplied for action".to_string()),
                    description: Err("no value supplied for description".to_string()),
                    direction: Err("no value supplied for direction".to_string()),
                    filters: Err("no value supplied for filters".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    priority: Err("no value supplied for priority".to_string()),
                    status: Err("no value supplied for status".to_string()),
                    targets: Err("no value supplied for targets".to_string()),
                }
            }
        }

        impl VpcFirewallRuleUpdate {
            pub fn action<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleAction>,
                T::Error: std::fmt::Display,
            {
                self.action = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for action: {}", e));
                self
            }
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn direction<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleDirection>,
                T::Error: std::fmt::Display,
            {
                self.direction = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for direction: {}", e));
                self
            }
            pub fn filters<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleFilter>,
                T::Error: std::fmt::Display,
            {
                self.filters = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for filters: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn priority<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<u16>,
                T::Error: std::fmt::Display,
            {
                self.priority = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for priority: {}", e));
                self
            }
            pub fn status<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcFirewallRuleStatus>,
                T::Error: std::fmt::Display,
            {
                self.status = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for status: {}", e));
                self
            }
            pub fn targets<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRuleTarget>>,
                T::Error: std::fmt::Display,
            {
                self.targets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for targets: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRuleUpdate> for super::VpcFirewallRuleUpdate {
            type Error = String;
            fn try_from(value: VpcFirewallRuleUpdate) -> Result<Self, String> {
                Ok(Self {
                    action: value.action?,
                    description: value.description?,
                    direction: value.direction?,
                    filters: value.filters?,
                    name: value.name?,
                    priority: value.priority?,
                    status: value.status?,
                    targets: value.targets?,
                })
            }
        }

        pub struct VpcFirewallRuleUpdateParams {
            rules: Result<Vec<super::VpcFirewallRuleUpdate>, String>,
        }

        impl Default for VpcFirewallRuleUpdateParams {
            fn default() -> Self {
                Self {
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }

        impl VpcFirewallRuleUpdateParams {
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRuleUpdate>>,
                T::Error: std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRuleUpdateParams> for super::VpcFirewallRuleUpdateParams {
            type Error = String;
            fn try_from(value: VpcFirewallRuleUpdateParams) -> Result<Self, String> {
                Ok(Self {
                    rules: value.rules?,
                })
            }
        }

        pub struct VpcFirewallRules {
            rules: Result<Vec<super::VpcFirewallRule>, String>,
        }

        impl Default for VpcFirewallRules {
            fn default() -> Self {
                Self {
                    rules: Err("no value supplied for rules".to_string()),
                }
            }
        }

        impl VpcFirewallRules {
            pub fn rules<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcFirewallRule>>,
                T::Error: std::fmt::Display,
            {
                self.rules = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for rules: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcFirewallRules> for super::VpcFirewallRules {
            type Error = String;
            fn try_from(value: VpcFirewallRules) -> Result<Self, String> {
                Ok(Self {
                    rules: value.rules?,
                })
            }
        }

        pub struct VpcResultsPage {
            items: Result<Vec<super::Vpc>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for VpcResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::Vpc>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcResultsPage> for super::VpcResultsPage {
            type Error = String;
            fn try_from(value: VpcResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct VpcRouter {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            kind: Result<super::VpcRouterKind, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for VpcRouter {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    kind: Err("no value supplied for kind".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcRouter {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn kind<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::VpcRouterKind>,
                T::Error: std::fmt::Display,
            {
                self.kind = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for kind: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouter> for super::VpcRouter {
            type Error = String;
            fn try_from(value: VpcRouter) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    kind: value.kind?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        pub struct VpcRouterCreate {
            description: Result<String, String>,
            name: Result<super::Name, String>,
        }

        impl Default for VpcRouterCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcRouterCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouterCreate> for super::VpcRouterCreate {
            type Error = String;
            fn try_from(value: VpcRouterCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct VpcRouterResultsPage {
            items: Result<Vec<super::VpcRouter>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for VpcRouterResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcRouterResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcRouter>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouterResultsPage> for super::VpcRouterResultsPage {
            type Error = String;
            fn try_from(value: VpcRouterResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct VpcRouterUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for VpcRouterUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcRouterUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcRouterUpdate> for super::VpcRouterUpdate {
            type Error = String;
            fn try_from(value: VpcRouterUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct VpcSubnet {
            description: Result<String, String>,
            id: Result<uuid::Uuid, String>,
            ipv4_block: Result<super::Ipv4Net, String>,
            ipv6_block: Result<super::Ipv6Net, String>,
            name: Result<super::Name, String>,
            time_created: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            time_modified: Result<chrono::DateTime<chrono::offset::Utc>, String>,
            vpc_id: Result<uuid::Uuid, String>,
        }

        impl Default for VpcSubnet {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    ipv4_block: Err("no value supplied for ipv4_block".to_string()),
                    ipv6_block: Err("no value supplied for ipv6_block".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    time_created: Err("no value supplied for time_created".to_string()),
                    time_modified: Err("no value supplied for time_modified".to_string()),
                    vpc_id: Err("no value supplied for vpc_id".to_string()),
                }
            }
        }

        impl VpcSubnet {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn ipv4_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv4Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv4_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4_block: {}", e));
                self
            }
            pub fn ipv6_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv6Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_block: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn time_created<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_created = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_created: {}", e)
                });
                self
            }
            pub fn time_modified<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
                T::Error: std::fmt::Display,
            {
                self.time_modified = value.try_into().map_err(|e| {
                    format!("error converting supplied value for time_modified: {}", e)
                });
                self
            }
            pub fn vpc_id<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<uuid::Uuid>,
                T::Error: std::fmt::Display,
            {
                self.vpc_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for vpc_id: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnet> for super::VpcSubnet {
            type Error = String;
            fn try_from(value: VpcSubnet) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    id: value.id?,
                    ipv4_block: value.ipv4_block?,
                    ipv6_block: value.ipv6_block?,
                    name: value.name?,
                    time_created: value.time_created?,
                    time_modified: value.time_modified?,
                    vpc_id: value.vpc_id?,
                })
            }
        }

        pub struct VpcSubnetCreate {
            description: Result<String, String>,
            ipv4_block: Result<super::Ipv4Net, String>,
            ipv6_block: Result<Option<super::Ipv6Net>, String>,
            name: Result<super::Name, String>,
        }

        impl Default for VpcSubnetCreate {
            fn default() -> Self {
                Self {
                    description: Err("no value supplied for description".to_string()),
                    ipv4_block: Err("no value supplied for ipv4_block".to_string()),
                    ipv6_block: Ok(Default::default()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }

        impl VpcSubnetCreate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<String>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn ipv4_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Ipv4Net>,
                T::Error: std::fmt::Display,
            {
                self.ipv4_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv4_block: {}", e));
                self
            }
            pub fn ipv6_block<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Ipv6Net>>,
                T::Error: std::fmt::Display,
            {
                self.ipv6_block = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for ipv6_block: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<super::Name>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnetCreate> for super::VpcSubnetCreate {
            type Error = String;
            fn try_from(value: VpcSubnetCreate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    ipv4_block: value.ipv4_block?,
                    ipv6_block: value.ipv6_block?,
                    name: value.name?,
                })
            }
        }

        pub struct VpcSubnetResultsPage {
            items: Result<Vec<super::VpcSubnet>, String>,
            next_page: Result<Option<String>, String>,
        }

        impl Default for VpcSubnetResultsPage {
            fn default() -> Self {
                Self {
                    items: Err("no value supplied for items".to_string()),
                    next_page: Ok(Default::default()),
                }
            }
        }

        impl VpcSubnetResultsPage {
            pub fn items<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Vec<super::VpcSubnet>>,
                T::Error: std::fmt::Display,
            {
                self.items = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for items: {}", e));
                self
            }
            pub fn next_page<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.next_page = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for next_page: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnetResultsPage> for super::VpcSubnetResultsPage {
            type Error = String;
            fn try_from(value: VpcSubnetResultsPage) -> Result<Self, String> {
                Ok(Self {
                    items: value.items?,
                    next_page: value.next_page?,
                })
            }
        }

        pub struct VpcSubnetUpdate {
            description: Result<Option<String>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for VpcSubnetUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcSubnetUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcSubnetUpdate> for super::VpcSubnetUpdate {
            type Error = String;
            fn try_from(value: VpcSubnetUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    name: value.name?,
                })
            }
        }

        pub struct VpcUpdate {
            description: Result<Option<String>, String>,
            dns_name: Result<Option<super::Name>, String>,
            name: Result<Option<super::Name>, String>,
        }

        impl Default for VpcUpdate {
            fn default() -> Self {
                Self {
                    description: Ok(Default::default()),
                    dns_name: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }

        impl VpcUpdate {
            pub fn description<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<String>>,
                T::Error: std::fmt::Display,
            {
                self.description = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for description: {}", e));
                self
            }
            pub fn dns_name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.dns_name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for dns_name: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: std::convert::TryInto<Option<super::Name>>,
                T::Error: std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }

        impl std::convert::TryFrom<VpcUpdate> for super::VpcUpdate {
            type Error = String;
            fn try_from(value: VpcUpdate) -> Result<Self, String> {
                Ok(Self {
                    description: value.description?,
                    dns_name: value.dns_name?,
                    name: value.name?,
                })
            }
        }
    }

    mod defaults {
        pub(super) fn default_bool<const V: bool>() -> bool {
            V
        }

        pub(super) fn instance_create_network_interfaces(
        ) -> super::InstanceNetworkInterfaceAttachment {
            super::InstanceNetworkInterfaceAttachment::Default
        }
    }
}

#[derive(Clone, Debug)]
#[doc = "Client for Oxide Region API\n\nAPI for interacting with the Oxide control plane"]
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}

impl Client {
    #[doc = r" Create a new client."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new(baseurl: &str) -> Self {
        let dur = std::time::Duration::from_secs(15);
        let client = reqwest::ClientBuilder::new()
            .connect_timeout(dur)
            .timeout(dur)
            .build()
            .unwrap();
        Self::new_with_client(baseurl, client)
    }

    #[doc = r" Construct a new client with an existing `reqwest::Client`,"]
    #[doc = r" allowing more control over its configuration."]
    #[doc = r""]
    #[doc = r" `baseurl` is the base URL provided to the internal"]
    #[doc = r" `reqwest::Client`, and should include a scheme and hostname,"]
    #[doc = r" as well as port and a path stem if applicable."]
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }

    #[doc = r" Return the base URL to which requests are made."]
    pub fn baseurl(&self) -> &String {
        &self.baseurl
    }

    #[doc = r" Return the internal `reqwest::Client` used to make requests."]
    pub fn client(&self) -> &reqwest::Client {
        &self.client
    }
}

pub trait ClientDisksExt {
    #[doc = "Fetch a disk by id\n\nUse `GET /v1/disks/{disk}` instead\n\nSends a `GET` request to `/by-id/disks/{id}`\n\n```ignore\nlet response = client.disk_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn disk_view_by_id(&self) -> builder::DiskViewById;
    #[doc = "List disks\n\nUse `GET /v1/disks` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.disk_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn disk_list(&self) -> builder::DiskList;
    #[doc = "Use `POST /v1/disks` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/disks`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.disk_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn disk_create(&self) -> builder::DiskCreate;
    #[doc = "Fetch a disk\n\nUse `GET /v1/disks/{disk}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}`\n\n```ignore\nlet response = client.disk_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .disk_name(disk_name)\n    .send()\n    .await;\n```"]
    fn disk_view(&self) -> builder::DiskView;
    #[doc = "Use `DELETE /v1/disks/{disk}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}`\n\n```ignore\nlet response = client.disk_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .disk_name(disk_name)\n    .send()\n    .await;\n```"]
    fn disk_delete(&self) -> builder::DiskDelete;
    #[doc = "Fetch disk metrics\n\nUse `/v1/disks/{disk}/{metric}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}/metrics/{metric_name}`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `disk_name`\n- `metric_name`\n- `end_time`: An exclusive end time of metrics.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `start_time`: An inclusive start time of metrics.\n```ignore\nlet response = client.disk_metrics_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .disk_name(disk_name)\n    .metric_name(metric_name)\n    .end_time(end_time)\n    .limit(limit)\n    .page_token(page_token)\n    .start_time(start_time)\n    .send()\n    .await;\n```"]
    fn disk_metrics_list(&self) -> builder::DiskMetricsList;
    #[doc = "List disks\n\nSends a `GET` request to `/v1/disks`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.disk_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn disk_list_v1(&self) -> builder::DiskListV1;
    #[doc = "Create a disk\n\nSends a `POST` request to `/v1/disks`\n\n```ignore\nlet response = client.disk_create_v1()\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn disk_create_v1(&self) -> builder::DiskCreateV1;
    #[doc = "Fetch a disk\n\nSends a `GET` request to `/v1/disks/{disk}`\n\n```ignore\nlet response = client.disk_view_v1()\n    .disk(disk)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn disk_view_v1(&self) -> builder::DiskViewV1;
    #[doc = "Delete a disk\n\nSends a `DELETE` request to `/v1/disks/{disk}`\n\n```ignore\nlet response = client.disk_delete_v1()\n    .disk(disk)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn disk_delete_v1(&self) -> builder::DiskDeleteV1;
    #[doc = "Fetch disk metrics\n\nSends a `GET` request to `/v1/disks/{disk}/metrics/{metric}`\n\nArguments:\n- `disk`\n- `metric`\n- `end_time`: An exclusive end time of metrics.\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `start_time`: An inclusive start time of metrics.\n```ignore\nlet response = client.disk_metrics_list_v1()\n    .disk(disk)\n    .metric(metric)\n    .end_time(end_time)\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .start_time(start_time)\n    .send()\n    .await;\n```"]
    fn disk_metrics_list_v1(&self) -> builder::DiskMetricsListV1;
}

impl ClientDisksExt for Client {
    fn disk_view_by_id(&self) -> builder::DiskViewById {
        builder::DiskViewById::new(self)
    }

    fn disk_list(&self) -> builder::DiskList {
        builder::DiskList::new(self)
    }

    fn disk_create(&self) -> builder::DiskCreate {
        builder::DiskCreate::new(self)
    }

    fn disk_view(&self) -> builder::DiskView {
        builder::DiskView::new(self)
    }

    fn disk_delete(&self) -> builder::DiskDelete {
        builder::DiskDelete::new(self)
    }

    fn disk_metrics_list(&self) -> builder::DiskMetricsList {
        builder::DiskMetricsList::new(self)
    }

    fn disk_list_v1(&self) -> builder::DiskListV1 {
        builder::DiskListV1::new(self)
    }

    fn disk_create_v1(&self) -> builder::DiskCreateV1 {
        builder::DiskCreateV1::new(self)
    }

    fn disk_view_v1(&self) -> builder::DiskViewV1 {
        builder::DiskViewV1::new(self)
    }

    fn disk_delete_v1(&self) -> builder::DiskDeleteV1 {
        builder::DiskDeleteV1::new(self)
    }

    fn disk_metrics_list_v1(&self) -> builder::DiskMetricsListV1 {
        builder::DiskMetricsListV1::new(self)
    }
}

pub trait ClientHiddenExt {
    #[doc = "Start an OAuth 2.0 Device Authorization Grant\n\nThis endpoint is designed to be accessed from an *unauthenticated* API client. It generates and records a `device_code` and `user_code` which must be verified and confirmed prior to a token being granted.\n\nSends a `POST` request to `/device/auth`\n\n```ignore\nlet response = client.device_auth_request()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn device_auth_request(&self) -> builder::DeviceAuthRequest;
    #[doc = "Confirm an OAuth 2.0 Device Authorization Grant\n\nThis endpoint is designed to be accessed by the user agent (browser), not the client requesting the token. So we do not actually return the token here; it will be returned in response to the poll on `/device/token`.\n\nSends a `POST` request to `/device/confirm`\n\n```ignore\nlet response = client.device_auth_confirm()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn device_auth_confirm(&self) -> builder::DeviceAuthConfirm;
    #[doc = "Request a device access token\n\nThis endpoint should be polled by the client until the user code is verified and the grant is confirmed.\n\nSends a `POST` request to `/device/token`\n\n```ignore\nlet response = client.device_access_token()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn device_access_token(&self) -> builder::DeviceAccessToken;
    #[doc = "Sends a `POST` request to `/login`\n\n```ignore\nlet response = client.login_spoof()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn login_spoof(&self) -> builder::LoginSpoof;
    #[doc = "Sends a `POST` request to `/logout`\n\n```ignore\nlet response = client.logout()\n    .send()\n    .await;\n```"]
    fn logout(&self) -> builder::Logout;
    #[doc = "Fetch the user associated with the current session\n\nUse `GET /v1/me` instead\n\nSends a `GET` request to `/session/me`\n\n```ignore\nlet response = client.session_me()\n    .send()\n    .await;\n```"]
    fn session_me(&self) -> builder::SessionMe;
    #[doc = "Fetch the silo\u{a0}groups the current user belongs to\n\nUse `GET /v1/me/groups` instead\n\nSends a `GET` request to `/session/me/groups`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.session_me_groups()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn session_me_groups(&self) -> builder::SessionMeGroups;
}

impl ClientHiddenExt for Client {
    fn device_auth_request(&self) -> builder::DeviceAuthRequest {
        builder::DeviceAuthRequest::new(self)
    }

    fn device_auth_confirm(&self) -> builder::DeviceAuthConfirm {
        builder::DeviceAuthConfirm::new(self)
    }

    fn device_access_token(&self) -> builder::DeviceAccessToken {
        builder::DeviceAccessToken::new(self)
    }

    fn login_spoof(&self) -> builder::LoginSpoof {
        builder::LoginSpoof::new(self)
    }

    fn logout(&self) -> builder::Logout {
        builder::Logout::new(self)
    }

    fn session_me(&self) -> builder::SessionMe {
        builder::SessionMe::new(self)
    }

    fn session_me_groups(&self) -> builder::SessionMeGroups {
        builder::SessionMeGroups::new(self)
    }
}

pub trait ClientImagesExt {
    #[doc = "Fetch an image by id\n\nSends a `GET` request to `/by-id/images/{id}`\n\n```ignore\nlet response = client.image_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn image_view_by_id(&self) -> builder::ImageViewById;
    #[doc = "List images\n\nList images in a project. The images are returned sorted by creation date, with the most recent images appearing first. Use `GET /v1/images` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/images`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.image_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn image_list(&self) -> builder::ImageList;
    #[doc = "Create an image\n\nCreate a new image in a project.\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/images`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.image_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn image_create(&self) -> builder::ImageCreate;
    #[doc = "Fetch an image\n\nFetch the details for a specific image in a project.\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/images/{image_name}`\n\n```ignore\nlet response = client.image_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .image_name(image_name)\n    .send()\n    .await;\n```"]
    fn image_view(&self) -> builder::ImageView;
    #[doc = "Delete an image\n\nPermanently delete an image from a project. This operation cannot be undone. Any instances in the project using the image will continue to run, however new instances can not be created with this image.\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/images/{image_name}`\n\n```ignore\nlet response = client.image_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .image_name(image_name)\n    .send()\n    .await;\n```"]
    fn image_delete(&self) -> builder::ImageDelete;
    #[doc = "List images\n\nList images which are global or scoped to the specified project. The images are returned sorted by creation date, with the most recent images appearing first.\n\nSends a `GET` request to `/v1/images`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.image_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn image_list_v1(&self) -> builder::ImageListV1;
    #[doc = "Create an image\n\nCreate a new image in a project.\n\nSends a `POST` request to `/v1/images`\n\n```ignore\nlet response = client.image_create_v1()\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn image_create_v1(&self) -> builder::ImageCreateV1;
    #[doc = "Fetch an image\n\nFetch the details for a specific image in a project.\n\nSends a `GET` request to `/v1/images/{image}`\n\n```ignore\nlet response = client.image_view_v1()\n    .image(image)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn image_view_v1(&self) -> builder::ImageViewV1;
    #[doc = "Delete an image\n\nPermanently delete an image from a project. This operation cannot be undone. Any instances in the project using the image will continue to run, however new instances can not be created with this image.\n\nSends a `DELETE` request to `/v1/images/{image}`\n\n```ignore\nlet response = client.image_delete_v1()\n    .image(image)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn image_delete_v1(&self) -> builder::ImageDeleteV1;
}

impl ClientImagesExt for Client {
    fn image_view_by_id(&self) -> builder::ImageViewById {
        builder::ImageViewById::new(self)
    }

    fn image_list(&self) -> builder::ImageList {
        builder::ImageList::new(self)
    }

    fn image_create(&self) -> builder::ImageCreate {
        builder::ImageCreate::new(self)
    }

    fn image_view(&self) -> builder::ImageView {
        builder::ImageView::new(self)
    }

    fn image_delete(&self) -> builder::ImageDelete {
        builder::ImageDelete::new(self)
    }

    fn image_list_v1(&self) -> builder::ImageListV1 {
        builder::ImageListV1::new(self)
    }

    fn image_create_v1(&self) -> builder::ImageCreateV1 {
        builder::ImageCreateV1::new(self)
    }

    fn image_view_v1(&self) -> builder::ImageViewV1 {
        builder::ImageViewV1::new(self)
    }

    fn image_delete_v1(&self) -> builder::ImageDeleteV1 {
        builder::ImageDeleteV1::new(self)
    }
}

pub trait ClientInstancesExt {
    #[doc = "Fetch an instance by id\n\nUse `GET /v1/instances/{instance}` instead\n\nSends a `GET` request to `/by-id/instances/{id}`\n\n```ignore\nlet response = client.instance_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn instance_view_by_id(&self) -> builder::InstanceViewById;
    #[doc = "Fetch a network interface by id\n\nUse `GET /v1/network-interfaces/{interface}` instead\n\nSends a `GET` request to `/by-id/network-interfaces/{id}`\n\n```ignore\nlet response = client.instance_network_interface_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_view_by_id(&self) -> builder::InstanceNetworkInterfaceViewById;
    #[doc = "List instances\n\nUse `GET /v1/instances` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.instance_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn instance_list(&self) -> builder::InstanceList;
    #[doc = "Create an instance\n\nUse `POST /v1/instances` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.instance_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_create(&self) -> builder::InstanceCreate;
    #[doc = "Fetch an instance\n\nUse `GET /v1/instances/{instance}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}`\n\n```ignore\nlet response = client.instance_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_view(&self) -> builder::InstanceView;
    #[doc = "Delete an instance\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}`\n\n```ignore\nlet response = client.instance_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_delete(&self) -> builder::InstanceDelete;
    #[doc = "List an instance's disks\n\nUse `GET /v1/instances/{instance}/disks` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.instance_disk_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn instance_disk_list(&self) -> builder::InstanceDiskList;
    #[doc = "Attach a disk to an instance\n\nUse `POST /v1/instances/{instance}/disks/attach` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/attach`\n\n```ignore\nlet response = client.instance_disk_attach()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_disk_attach(&self) -> builder::InstanceDiskAttach;
    #[doc = "Detach a disk from an instance\n\nUse `POST /v1/disks/{disk}/detach` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/detach`\n\n```ignore\nlet response = client.instance_disk_detach()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_disk_detach(&self) -> builder::InstanceDiskDetach;
    #[doc = "List external IP addresses\n\nUse `/v1/instances/{instance}/external-ips` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/external-ips`\n\n```ignore\nlet response = client.instance_external_ip_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_external_ip_list(&self) -> builder::InstanceExternalIpList;
    #[doc = "Migrate an instance\n\nUse `POST /v1/instances/{instance}/migrate` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/migrate`\n\n```ignore\nlet response = client.instance_migrate()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_migrate(&self) -> builder::InstanceMigrate;
    #[doc = "List network interfaces\n\nUse `GET /v1/network-interfaces` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.instance_network_interface_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_list(&self) -> builder::InstanceNetworkInterfaceList;
    #[doc = "Create a network interface\n\nUse `POST /v1/network-interfaces` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`\n\n```ignore\nlet response = client.instance_network_interface_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_create(&self) -> builder::InstanceNetworkInterfaceCreate;
    #[doc = "Fetch a network interface\n\nUse `GET /v1/network-interfaces/{interface}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`\n\n```ignore\nlet response = client.instance_network_interface_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .interface_name(interface_name)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_view(&self) -> builder::InstanceNetworkInterfaceView;
    #[doc = "Update a network interface\n\nUse `PUT /v1/network-interfaces/{interface}` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`\n\n```ignore\nlet response = client.instance_network_interface_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .interface_name(interface_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_update(&self) -> builder::InstanceNetworkInterfaceUpdate;
    #[doc = "Delete a network interface\n\nNote that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A new primary interface must be designated first. The primary interface can be deleted if there are no secondary interfaces.\nUse `DELETE /v1/network-interfaces/{interface}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`\n\n```ignore\nlet response = client.instance_network_interface_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .interface_name(interface_name)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_delete(&self) -> builder::InstanceNetworkInterfaceDelete;
    #[doc = "Reboot an instance\n\nUse `POST /v1/instances/{instance}/reboot` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/reboot`\n\n```ignore\nlet response = client.instance_reboot()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_reboot(&self) -> builder::InstanceReboot;
    #[doc = "Fetch an instance's serial console\n\nUse `GET /v1/instances/{instance}/serial-console` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/serial-console`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `instance_name`\n- `from_start`: Character index in the serial buffer from which to read, counting the bytes output since instance start. If this is not provided, `most_recent` must be provided, and if this *is* provided, `most_recent` must *not* be provided.\n- `max_bytes`: Maximum number of bytes of buffered serial console contents to return. If the requested range runs to the end of the available buffer, the data returned will be shorter than `max_bytes`.\n- `most_recent`: Character index in the serial buffer from which to read, counting *backward* from the most recently buffered data retrieved from the instance. (See note on `from_start` about mutual exclusivity)\n```ignore\nlet response = client.instance_serial_console()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .from_start(from_start)\n    .max_bytes(max_bytes)\n    .most_recent(most_recent)\n    .send()\n    .await;\n```"]
    fn instance_serial_console(&self) -> builder::InstanceSerialConsole;
    #[doc = "Connect to an instance's serial console\n\nUse `GET /v1/instances/{instance}/serial-console/stream` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/serial-console/stream`\n\n```ignore\nlet response = client.instance_serial_console_stream()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_serial_console_stream(&self) -> builder::InstanceSerialConsoleStream;
    #[doc = "Boot an instance\n\nUse `POST /v1/instances/{instance}/start` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/start`\n\n```ignore\nlet response = client.instance_start()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_start(&self) -> builder::InstanceStart;
    #[doc = "Halt an instance\n\nUse `POST /v1/instances/{instance}/stop` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/stop`\n\n```ignore\nlet response = client.instance_stop()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .instance_name(instance_name)\n    .send()\n    .await;\n```"]
    fn instance_stop(&self) -> builder::InstanceStop;
    #[doc = "List instances\n\nSends a `GET` request to `/v1/instances`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.instance_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn instance_list_v1(&self) -> builder::InstanceListV1;
    #[doc = "Create an instance\n\nSends a `POST` request to `/v1/instances`\n\n```ignore\nlet response = client.instance_create_v1()\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_create_v1(&self) -> builder::InstanceCreateV1;
    #[doc = "Fetch an instance\n\nSends a `GET` request to `/v1/instances/{instance}`\n\n```ignore\nlet response = client.instance_view_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_view_v1(&self) -> builder::InstanceViewV1;
    #[doc = "Delete an instance\n\nSends a `DELETE` request to `/v1/instances/{instance}`\n\n```ignore\nlet response = client.instance_delete_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_delete_v1(&self) -> builder::InstanceDeleteV1;
    #[doc = "List an instance's disks\n\nSends a `GET` request to `/v1/instances/{instance}/disks`\n\nArguments:\n- `instance`\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.instance_disk_list_v1()\n    .instance(instance)\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn instance_disk_list_v1(&self) -> builder::InstanceDiskListV1;
    #[doc = "Attach a disk to an instance\n\nSends a `POST` request to `/v1/instances/{instance}/disks/attach`\n\n```ignore\nlet response = client.instance_disk_attach_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_disk_attach_v1(&self) -> builder::InstanceDiskAttachV1;
    #[doc = "Detach a disk from an instance\n\nSends a `POST` request to `/v1/instances/{instance}/disks/detach`\n\n```ignore\nlet response = client.instance_disk_detach_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_disk_detach_v1(&self) -> builder::InstanceDiskDetachV1;
    #[doc = "List external IP addresses\n\nSends a `GET` request to `/v1/instances/{instance}/external-ips`\n\n```ignore\nlet response = client.instance_external_ip_list_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_external_ip_list_v1(&self) -> builder::InstanceExternalIpListV1;
    #[doc = "Migrate an instance\n\nSends a `POST` request to `/v1/instances/{instance}/migrate`\n\n```ignore\nlet response = client.instance_migrate_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_migrate_v1(&self) -> builder::InstanceMigrateV1;
    #[doc = "Reboot an instance\n\nSends a `POST` request to `/v1/instances/{instance}/reboot`\n\n```ignore\nlet response = client.instance_reboot_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_reboot_v1(&self) -> builder::InstanceRebootV1;
    #[doc = "Fetch an instance's serial console\n\nSends a `GET` request to `/v1/instances/{instance}/serial-console`\n\nArguments:\n- `instance`\n- `from_start`: Character index in the serial buffer from which to read, counting the bytes output since instance start. If this is not provided, `most_recent` must be provided, and if this *is* provided, `most_recent` must *not* be provided.\n- `max_bytes`: Maximum number of bytes of buffered serial console contents to return. If the requested range runs to the end of the available buffer, the data returned will be shorter than `max_bytes`.\n- `most_recent`: Character index in the serial buffer from which to read, counting *backward* from the most recently buffered data retrieved from the instance. (See note on `from_start` about mutual exclusivity)\n- `organization`\n- `project`\n```ignore\nlet response = client.instance_serial_console_v1()\n    .instance(instance)\n    .from_start(from_start)\n    .max_bytes(max_bytes)\n    .most_recent(most_recent)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_serial_console_v1(&self) -> builder::InstanceSerialConsoleV1;
    #[doc = "Stream an instance's serial console\n\nSends a `GET` request to `/v1/instances/{instance}/serial-console/stream`\n\n```ignore\nlet response = client.instance_serial_console_stream_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_serial_console_stream_v1(&self) -> builder::InstanceSerialConsoleStreamV1;
    #[doc = "Boot an instance\n\nSends a `POST` request to `/v1/instances/{instance}/start`\n\n```ignore\nlet response = client.instance_start_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_start_v1(&self) -> builder::InstanceStartV1;
    #[doc = "Stop an instance\n\nSends a `POST` request to `/v1/instances/{instance}/stop`\n\n```ignore\nlet response = client.instance_stop_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_stop_v1(&self) -> builder::InstanceStopV1;
    #[doc = "List network interfaces\n\nSends a `GET` request to `/v1/network-interfaces`\n\nArguments:\n- `instance`\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.instance_network_interface_list_v1()\n    .instance(instance)\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_list_v1(&self) -> builder::InstanceNetworkInterfaceListV1;
    #[doc = "Create a network interface\n\nSends a `POST` request to `/v1/network-interfaces`\n\n```ignore\nlet response = client.instance_network_interface_create_v1()\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_create_v1(&self) -> builder::InstanceNetworkInterfaceCreateV1;
    #[doc = "Fetch a network interface\n\nSends a `GET` request to `/v1/network-interfaces/{interface}`\n\n```ignore\nlet response = client.instance_network_interface_view_v1()\n    .interface(interface)\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_view_v1(&self) -> builder::InstanceNetworkInterfaceViewV1;
    #[doc = "Update a network interface\n\nSends a `PUT` request to `/v1/network-interfaces/{interface}`\n\n```ignore\nlet response = client.instance_network_interface_update_v1()\n    .interface(interface)\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_update_v1(&self) -> builder::InstanceNetworkInterfaceUpdateV1;
    #[doc = "Delete a network interface\n\nNote that the primary interface for an instance cannot be deleted if there are any secondary interfaces. A new primary interface must be designated first. The primary interface can be deleted if there are no secondary interfaces.\n\nSends a `DELETE` request to `/v1/network-interfaces/{interface}`\n\n```ignore\nlet response = client.instance_network_interface_delete_v1()\n    .interface(interface)\n    .instance(instance)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn instance_network_interface_delete_v1(&self) -> builder::InstanceNetworkInterfaceDeleteV1;
}

impl ClientInstancesExt for Client {
    fn instance_view_by_id(&self) -> builder::InstanceViewById {
        builder::InstanceViewById::new(self)
    }

    fn instance_network_interface_view_by_id(&self) -> builder::InstanceNetworkInterfaceViewById {
        builder::InstanceNetworkInterfaceViewById::new(self)
    }

    fn instance_list(&self) -> builder::InstanceList {
        builder::InstanceList::new(self)
    }

    fn instance_create(&self) -> builder::InstanceCreate {
        builder::InstanceCreate::new(self)
    }

    fn instance_view(&self) -> builder::InstanceView {
        builder::InstanceView::new(self)
    }

    fn instance_delete(&self) -> builder::InstanceDelete {
        builder::InstanceDelete::new(self)
    }

    fn instance_disk_list(&self) -> builder::InstanceDiskList {
        builder::InstanceDiskList::new(self)
    }

    fn instance_disk_attach(&self) -> builder::InstanceDiskAttach {
        builder::InstanceDiskAttach::new(self)
    }

    fn instance_disk_detach(&self) -> builder::InstanceDiskDetach {
        builder::InstanceDiskDetach::new(self)
    }

    fn instance_external_ip_list(&self) -> builder::InstanceExternalIpList {
        builder::InstanceExternalIpList::new(self)
    }

    fn instance_migrate(&self) -> builder::InstanceMigrate {
        builder::InstanceMigrate::new(self)
    }

    fn instance_network_interface_list(&self) -> builder::InstanceNetworkInterfaceList {
        builder::InstanceNetworkInterfaceList::new(self)
    }

    fn instance_network_interface_create(&self) -> builder::InstanceNetworkInterfaceCreate {
        builder::InstanceNetworkInterfaceCreate::new(self)
    }

    fn instance_network_interface_view(&self) -> builder::InstanceNetworkInterfaceView {
        builder::InstanceNetworkInterfaceView::new(self)
    }

    fn instance_network_interface_update(&self) -> builder::InstanceNetworkInterfaceUpdate {
        builder::InstanceNetworkInterfaceUpdate::new(self)
    }

    fn instance_network_interface_delete(&self) -> builder::InstanceNetworkInterfaceDelete {
        builder::InstanceNetworkInterfaceDelete::new(self)
    }

    fn instance_reboot(&self) -> builder::InstanceReboot {
        builder::InstanceReboot::new(self)
    }

    fn instance_serial_console(&self) -> builder::InstanceSerialConsole {
        builder::InstanceSerialConsole::new(self)
    }

    fn instance_serial_console_stream(&self) -> builder::InstanceSerialConsoleStream {
        builder::InstanceSerialConsoleStream::new(self)
    }

    fn instance_start(&self) -> builder::InstanceStart {
        builder::InstanceStart::new(self)
    }

    fn instance_stop(&self) -> builder::InstanceStop {
        builder::InstanceStop::new(self)
    }

    fn instance_list_v1(&self) -> builder::InstanceListV1 {
        builder::InstanceListV1::new(self)
    }

    fn instance_create_v1(&self) -> builder::InstanceCreateV1 {
        builder::InstanceCreateV1::new(self)
    }

    fn instance_view_v1(&self) -> builder::InstanceViewV1 {
        builder::InstanceViewV1::new(self)
    }

    fn instance_delete_v1(&self) -> builder::InstanceDeleteV1 {
        builder::InstanceDeleteV1::new(self)
    }

    fn instance_disk_list_v1(&self) -> builder::InstanceDiskListV1 {
        builder::InstanceDiskListV1::new(self)
    }

    fn instance_disk_attach_v1(&self) -> builder::InstanceDiskAttachV1 {
        builder::InstanceDiskAttachV1::new(self)
    }

    fn instance_disk_detach_v1(&self) -> builder::InstanceDiskDetachV1 {
        builder::InstanceDiskDetachV1::new(self)
    }

    fn instance_external_ip_list_v1(&self) -> builder::InstanceExternalIpListV1 {
        builder::InstanceExternalIpListV1::new(self)
    }

    fn instance_migrate_v1(&self) -> builder::InstanceMigrateV1 {
        builder::InstanceMigrateV1::new(self)
    }

    fn instance_reboot_v1(&self) -> builder::InstanceRebootV1 {
        builder::InstanceRebootV1::new(self)
    }

    fn instance_serial_console_v1(&self) -> builder::InstanceSerialConsoleV1 {
        builder::InstanceSerialConsoleV1::new(self)
    }

    fn instance_serial_console_stream_v1(&self) -> builder::InstanceSerialConsoleStreamV1 {
        builder::InstanceSerialConsoleStreamV1::new(self)
    }

    fn instance_start_v1(&self) -> builder::InstanceStartV1 {
        builder::InstanceStartV1::new(self)
    }

    fn instance_stop_v1(&self) -> builder::InstanceStopV1 {
        builder::InstanceStopV1::new(self)
    }

    fn instance_network_interface_list_v1(&self) -> builder::InstanceNetworkInterfaceListV1 {
        builder::InstanceNetworkInterfaceListV1::new(self)
    }

    fn instance_network_interface_create_v1(&self) -> builder::InstanceNetworkInterfaceCreateV1 {
        builder::InstanceNetworkInterfaceCreateV1::new(self)
    }

    fn instance_network_interface_view_v1(&self) -> builder::InstanceNetworkInterfaceViewV1 {
        builder::InstanceNetworkInterfaceViewV1::new(self)
    }

    fn instance_network_interface_update_v1(&self) -> builder::InstanceNetworkInterfaceUpdateV1 {
        builder::InstanceNetworkInterfaceUpdateV1::new(self)
    }

    fn instance_network_interface_delete_v1(&self) -> builder::InstanceNetworkInterfaceDeleteV1 {
        builder::InstanceNetworkInterfaceDeleteV1::new(self)
    }
}

pub trait ClientLoginExt {
    #[doc = "Authenticate a user (i.e., log in) via username and password\n\nSends a `POST` request to `/login/{silo_name}/local`\n\n```ignore\nlet response = client.login_local()\n    .silo_name(silo_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn login_local(&self) -> builder::LoginLocal;
    #[doc = "Prompt user login\n\nEither display a page asking a user for their credentials, or redirect them to their identity provider.\n\nSends a `GET` request to `/login/{silo_name}/saml/{provider_name}`\n\n```ignore\nlet response = client.login_saml_begin()\n    .silo_name(silo_name)\n    .provider_name(provider_name)\n    .send()\n    .await;\n```"]
    fn login_saml_begin(&self) -> builder::LoginSamlBegin;
    #[doc = "Authenticate a user (i.e., log in) via SAML\n\nSends a `POST` request to `/login/{silo_name}/saml/{provider_name}`\n\n```ignore\nlet response = client.login_saml()\n    .silo_name(silo_name)\n    .provider_name(provider_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn login_saml(&self) -> builder::LoginSaml;
}

impl ClientLoginExt for Client {
    fn login_local(&self) -> builder::LoginLocal {
        builder::LoginLocal::new(self)
    }

    fn login_saml_begin(&self) -> builder::LoginSamlBegin {
        builder::LoginSamlBegin::new(self)
    }

    fn login_saml(&self) -> builder::LoginSaml {
        builder::LoginSaml::new(self)
    }
}

pub trait ClientMetricsExt {
    #[doc = "List timeseries schema\n\nSends a `GET` request to `/timeseries/schema`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n```ignore\nlet response = client.timeseries_schema_get()\n    .limit(limit)\n    .page_token(page_token)\n    .send()\n    .await;\n```"]
    fn timeseries_schema_get(&self) -> builder::TimeseriesSchemaGet;
}

impl ClientMetricsExt for Client {
    fn timeseries_schema_get(&self) -> builder::TimeseriesSchemaGet {
        builder::TimeseriesSchemaGet::new(self)
    }
}

pub trait ClientOrganizationsExt {
    #[doc = "Fetch an organization by id\n\nUse `GET /v1/organizations/{organization}` instead\n\nSends a `GET` request to `/by-id/organizations/{id}`\n\n```ignore\nlet response = client.organization_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn organization_view_by_id(&self) -> builder::OrganizationViewById;
    #[doc = "List organizations\n\nUse `GET /v1/organizations` instead\n\nSends a `GET` request to `/organizations`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.organization_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn organization_list(&self) -> builder::OrganizationList;
    #[doc = "Create an organization\n\nUse `POST /v1/organizations` instead\n\nSends a `POST` request to `/organizations`\n\n```ignore\nlet response = client.organization_create()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn organization_create(&self) -> builder::OrganizationCreate;
    #[doc = "Fetch an organization\n\nUse `GET /v1/organizations/{organization}` instead\n\nSends a `GET` request to `/organizations/{organization_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n```ignore\nlet response = client.organization_view()\n    .organization_name(organization_name)\n    .send()\n    .await;\n```"]
    fn organization_view(&self) -> builder::OrganizationView;
    #[doc = "Update an organization\n\nUse `PUT /v1/organizations/{organization}` instead\n\nSends a `PUT` request to `/organizations/{organization_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `body`\n```ignore\nlet response = client.organization_update()\n    .organization_name(organization_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn organization_update(&self) -> builder::OrganizationUpdate;
    #[doc = "Delete an organization\n\nUse `DELETE /v1/organizations/{organization}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n```ignore\nlet response = client.organization_delete()\n    .organization_name(organization_name)\n    .send()\n    .await;\n```"]
    fn organization_delete(&self) -> builder::OrganizationDelete;
    #[doc = "Fetch an organization's IAM policy\n\nUse `GET /v1/organizations/{organization}/policy` instead\n\nSends a `GET` request to `/organizations/{organization_name}/policy`\n\nArguments:\n- `organization_name`: The organization's unique name.\n```ignore\nlet response = client.organization_policy_view()\n    .organization_name(organization_name)\n    .send()\n    .await;\n```"]
    fn organization_policy_view(&self) -> builder::OrganizationPolicyView;
    #[doc = "Update an organization's IAM policy\n\nUse `PUT /v1/organizations/{organization}/policy` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/policy`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `body`\n```ignore\nlet response = client.organization_policy_update()\n    .organization_name(organization_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn organization_policy_update(&self) -> builder::OrganizationPolicyUpdate;
    #[doc = "List organizations\n\nSends a `GET` request to `/v1/organizations`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.organization_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn organization_list_v1(&self) -> builder::OrganizationListV1;
    #[doc = "Create an organization\n\nSends a `POST` request to `/v1/organizations`\n\n```ignore\nlet response = client.organization_create_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn organization_create_v1(&self) -> builder::OrganizationCreateV1;
    #[doc = "Fetch an organization\n\nSends a `GET` request to `/v1/organizations/{organization}`\n\n```ignore\nlet response = client.organization_view_v1()\n    .organization(organization)\n    .send()\n    .await;\n```"]
    fn organization_view_v1(&self) -> builder::OrganizationViewV1;
    #[doc = "Update an organization\n\nSends a `PUT` request to `/v1/organizations/{organization}`\n\n```ignore\nlet response = client.organization_update_v1()\n    .organization(organization)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn organization_update_v1(&self) -> builder::OrganizationUpdateV1;
    #[doc = "Delete an organization\n\nSends a `DELETE` request to `/v1/organizations/{organization}`\n\n```ignore\nlet response = client.organization_delete_v1()\n    .organization(organization)\n    .send()\n    .await;\n```"]
    fn organization_delete_v1(&self) -> builder::OrganizationDeleteV1;
    #[doc = "Fetch an organization's IAM policy\n\nSends a `GET` request to `/v1/organizations/{organization}/policy`\n\n```ignore\nlet response = client.organization_policy_view_v1()\n    .organization(organization)\n    .send()\n    .await;\n```"]
    fn organization_policy_view_v1(&self) -> builder::OrganizationPolicyViewV1;
    #[doc = "Update an organization's IAM policy\n\nSends a `PUT` request to `/v1/organizations/{organization}/policy`\n\n```ignore\nlet response = client.organization_policy_update_v1()\n    .organization(organization)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn organization_policy_update_v1(&self) -> builder::OrganizationPolicyUpdateV1;
}

impl ClientOrganizationsExt for Client {
    fn organization_view_by_id(&self) -> builder::OrganizationViewById {
        builder::OrganizationViewById::new(self)
    }

    fn organization_list(&self) -> builder::OrganizationList {
        builder::OrganizationList::new(self)
    }

    fn organization_create(&self) -> builder::OrganizationCreate {
        builder::OrganizationCreate::new(self)
    }

    fn organization_view(&self) -> builder::OrganizationView {
        builder::OrganizationView::new(self)
    }

    fn organization_update(&self) -> builder::OrganizationUpdate {
        builder::OrganizationUpdate::new(self)
    }

    fn organization_delete(&self) -> builder::OrganizationDelete {
        builder::OrganizationDelete::new(self)
    }

    fn organization_policy_view(&self) -> builder::OrganizationPolicyView {
        builder::OrganizationPolicyView::new(self)
    }

    fn organization_policy_update(&self) -> builder::OrganizationPolicyUpdate {
        builder::OrganizationPolicyUpdate::new(self)
    }

    fn organization_list_v1(&self) -> builder::OrganizationListV1 {
        builder::OrganizationListV1::new(self)
    }

    fn organization_create_v1(&self) -> builder::OrganizationCreateV1 {
        builder::OrganizationCreateV1::new(self)
    }

    fn organization_view_v1(&self) -> builder::OrganizationViewV1 {
        builder::OrganizationViewV1::new(self)
    }

    fn organization_update_v1(&self) -> builder::OrganizationUpdateV1 {
        builder::OrganizationUpdateV1::new(self)
    }

    fn organization_delete_v1(&self) -> builder::OrganizationDeleteV1 {
        builder::OrganizationDeleteV1::new(self)
    }

    fn organization_policy_view_v1(&self) -> builder::OrganizationPolicyViewV1 {
        builder::OrganizationPolicyViewV1::new(self)
    }

    fn organization_policy_update_v1(&self) -> builder::OrganizationPolicyUpdateV1 {
        builder::OrganizationPolicyUpdateV1::new(self)
    }
}

pub trait ClientPolicyExt {
    #[doc = "Fetch the top-level IAM policy\n\nUse `GET /v1/system/policy` instead\n\nSends a `GET` request to `/system/policy`\n\n```ignore\nlet response = client.system_policy_view()\n    .send()\n    .await;\n```"]
    fn system_policy_view(&self) -> builder::SystemPolicyView;
    #[doc = "Update the top-level IAM policy\n\nUse 'PUT /v1/system/policy' instead\n\nSends a `PUT` request to `/system/policy`\n\n```ignore\nlet response = client.system_policy_update()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn system_policy_update(&self) -> builder::SystemPolicyUpdate;
    #[doc = "Fetch the top-level IAM policy\n\nSends a `GET` request to `/v1/system/policy`\n\n```ignore\nlet response = client.system_policy_view_v1()\n    .send()\n    .await;\n```"]
    fn system_policy_view_v1(&self) -> builder::SystemPolicyViewV1;
    #[doc = "Update the top-level IAM policy\n\nSends a `PUT` request to `/v1/system/policy`\n\n```ignore\nlet response = client.system_policy_update_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn system_policy_update_v1(&self) -> builder::SystemPolicyUpdateV1;
}

impl ClientPolicyExt for Client {
    fn system_policy_view(&self) -> builder::SystemPolicyView {
        builder::SystemPolicyView::new(self)
    }

    fn system_policy_update(&self) -> builder::SystemPolicyUpdate {
        builder::SystemPolicyUpdate::new(self)
    }

    fn system_policy_view_v1(&self) -> builder::SystemPolicyViewV1 {
        builder::SystemPolicyViewV1::new(self)
    }

    fn system_policy_update_v1(&self) -> builder::SystemPolicyUpdateV1 {
        builder::SystemPolicyUpdateV1::new(self)
    }
}

pub trait ClientProjectsExt {
    #[doc = "Fetch a project by id\n\nUse `GET /v1/projects/{project}` instead\n\nSends a `GET` request to `/by-id/projects/{id}`\n\n```ignore\nlet response = client.project_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn project_view_by_id(&self) -> builder::ProjectViewById;
    #[doc = "List projects\n\nUse `GET /v1/projects` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.project_list()\n    .organization_name(organization_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn project_list(&self) -> builder::ProjectList;
    #[doc = "Create a project\n\nUse `POST /v1/projects` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `body`\n```ignore\nlet response = client.project_create()\n    .organization_name(organization_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn project_create(&self) -> builder::ProjectCreate;
    #[doc = "Fetch a project\n\nUse `GET /v1/projects/{project}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n```ignore\nlet response = client.project_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .send()\n    .await;\n```"]
    fn project_view(&self) -> builder::ProjectView;
    #[doc = "Update a project\n\nUse `PUT /v1/projects/{project}` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.project_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn project_update(&self) -> builder::ProjectUpdate;
    #[doc = "Delete a project\n\nUse `DELETE /v1/projects/{project}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n```ignore\nlet response = client.project_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .send()\n    .await;\n```"]
    fn project_delete(&self) -> builder::ProjectDelete;
    #[doc = "Fetch a project's IAM policy\n\nUse `GET /v1/projects/{project}/policy` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/policy`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n```ignore\nlet response = client.project_policy_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .send()\n    .await;\n```"]
    fn project_policy_view(&self) -> builder::ProjectPolicyView;
    #[doc = "Update a project's IAM policy\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/policy`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.project_policy_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn project_policy_update(&self) -> builder::ProjectPolicyUpdate;
    #[doc = "List projects\n\nSends a `GET` request to `/v1/projects`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.project_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn project_list_v1(&self) -> builder::ProjectListV1;
    #[doc = "Create a project\n\nSends a `POST` request to `/v1/projects`\n\n```ignore\nlet response = client.project_create_v1()\n    .organization(organization)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn project_create_v1(&self) -> builder::ProjectCreateV1;
    #[doc = "Fetch a project\n\nSends a `GET` request to `/v1/projects/{project}`\n\n```ignore\nlet response = client.project_view_v1()\n    .project(project)\n    .organization(organization)\n    .send()\n    .await;\n```"]
    fn project_view_v1(&self) -> builder::ProjectViewV1;
    #[doc = "Update a project\n\nSends a `PUT` request to `/v1/projects/{project}`\n\n```ignore\nlet response = client.project_update_v1()\n    .project(project)\n    .organization(organization)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn project_update_v1(&self) -> builder::ProjectUpdateV1;
    #[doc = "Delete a project\n\nSends a `DELETE` request to `/v1/projects/{project}`\n\n```ignore\nlet response = client.project_delete_v1()\n    .project(project)\n    .organization(organization)\n    .send()\n    .await;\n```"]
    fn project_delete_v1(&self) -> builder::ProjectDeleteV1;
    #[doc = "Fetch a project's IAM policy\n\nSends a `GET` request to `/v1/projects/{project}/policy`\n\n```ignore\nlet response = client.project_policy_view_v1()\n    .project(project)\n    .organization(organization)\n    .send()\n    .await;\n```"]
    fn project_policy_view_v1(&self) -> builder::ProjectPolicyViewV1;
    #[doc = "Update a project's IAM policy\n\nSends a `PUT` request to `/v1/projects/{project}/policy`\n\n```ignore\nlet response = client.project_policy_update_v1()\n    .project(project)\n    .organization(organization)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn project_policy_update_v1(&self) -> builder::ProjectPolicyUpdateV1;
}

impl ClientProjectsExt for Client {
    fn project_view_by_id(&self) -> builder::ProjectViewById {
        builder::ProjectViewById::new(self)
    }

    fn project_list(&self) -> builder::ProjectList {
        builder::ProjectList::new(self)
    }

    fn project_create(&self) -> builder::ProjectCreate {
        builder::ProjectCreate::new(self)
    }

    fn project_view(&self) -> builder::ProjectView {
        builder::ProjectView::new(self)
    }

    fn project_update(&self) -> builder::ProjectUpdate {
        builder::ProjectUpdate::new(self)
    }

    fn project_delete(&self) -> builder::ProjectDelete {
        builder::ProjectDelete::new(self)
    }

    fn project_policy_view(&self) -> builder::ProjectPolicyView {
        builder::ProjectPolicyView::new(self)
    }

    fn project_policy_update(&self) -> builder::ProjectPolicyUpdate {
        builder::ProjectPolicyUpdate::new(self)
    }

    fn project_list_v1(&self) -> builder::ProjectListV1 {
        builder::ProjectListV1::new(self)
    }

    fn project_create_v1(&self) -> builder::ProjectCreateV1 {
        builder::ProjectCreateV1::new(self)
    }

    fn project_view_v1(&self) -> builder::ProjectViewV1 {
        builder::ProjectViewV1::new(self)
    }

    fn project_update_v1(&self) -> builder::ProjectUpdateV1 {
        builder::ProjectUpdateV1::new(self)
    }

    fn project_delete_v1(&self) -> builder::ProjectDeleteV1 {
        builder::ProjectDeleteV1::new(self)
    }

    fn project_policy_view_v1(&self) -> builder::ProjectPolicyViewV1 {
        builder::ProjectPolicyViewV1::new(self)
    }

    fn project_policy_update_v1(&self) -> builder::ProjectPolicyUpdateV1 {
        builder::ProjectPolicyUpdateV1::new(self)
    }
}

pub trait ClientRolesExt {
    #[doc = "List built-in roles\n\nSends a `GET` request to `/roles`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n```ignore\nlet response = client.role_list()\n    .limit(limit)\n    .page_token(page_token)\n    .send()\n    .await;\n```"]
    fn role_list(&self) -> builder::RoleList;
    #[doc = "Fetch a built-in role\n\nSends a `GET` request to `/roles/{role_name}`\n\nArguments:\n- `role_name`: The built-in role's unique name.\n```ignore\nlet response = client.role_view()\n    .role_name(role_name)\n    .send()\n    .await;\n```"]
    fn role_view(&self) -> builder::RoleView;
}

impl ClientRolesExt for Client {
    fn role_list(&self) -> builder::RoleList {
        builder::RoleList::new(self)
    }

    fn role_view(&self) -> builder::RoleView {
        builder::RoleView::new(self)
    }
}

pub trait ClientSessionExt {
    #[doc = "List SSH public keys\n\nLists SSH public keys for the currently authenticated user.\n\nSends a `GET` request to `/session/me/sshkeys`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.session_sshkey_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn session_sshkey_list(&self) -> builder::SessionSshkeyList;
    #[doc = "Create an SSH public key\n\nCreate an SSH public key for the currently authenticated user.\n\nSends a `POST` request to `/session/me/sshkeys`\n\n```ignore\nlet response = client.session_sshkey_create()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn session_sshkey_create(&self) -> builder::SessionSshkeyCreate;
    #[doc = "Fetch an SSH public key\n\nFetch an SSH public key associated with the currently authenticated user. Use `GET /v1/me/ssh-keys` instead\n\nSends a `GET` request to `/session/me/sshkeys/{ssh_key_name}`\n\n```ignore\nlet response = client.session_sshkey_view()\n    .ssh_key_name(ssh_key_name)\n    .send()\n    .await;\n```"]
    fn session_sshkey_view(&self) -> builder::SessionSshkeyView;
    #[doc = "Delete an SSH public key\n\nDelete an SSH public key associated with the currently authenticated user.\n\nSends a `DELETE` request to `/session/me/sshkeys/{ssh_key_name}`\n\n```ignore\nlet response = client.session_sshkey_delete()\n    .ssh_key_name(ssh_key_name)\n    .send()\n    .await;\n```"]
    fn session_sshkey_delete(&self) -> builder::SessionSshkeyDelete;
    #[doc = "Fetch the user associated with the current session\n\nSends a `GET` request to `/v1/me`\n\n```ignore\nlet response = client.current_user_view_v1()\n    .send()\n    .await;\n```"]
    fn current_user_view_v1(&self) -> builder::CurrentUserViewV1;
    #[doc = "Fetch the silo\u{a0}groups the current user belongs to\n\nSends a `GET` request to `/v1/me/groups`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.current_user_groups_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn current_user_groups_v1(&self) -> builder::CurrentUserGroupsV1;
    #[doc = "List SSH public keys\n\nLists SSH public keys for the currently authenticated user.\n\nSends a `GET` request to `/v1/me/ssh-keys`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.current_user_ssh_key_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn current_user_ssh_key_list_v1(&self) -> builder::CurrentUserSshKeyListV1;
    #[doc = "Create an SSH public key\n\nCreate an SSH public key for the currently authenticated user.\n\nSends a `POST` request to `/v1/me/ssh-keys`\n\n```ignore\nlet response = client.current_user_ssh_key_create_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn current_user_ssh_key_create_v1(&self) -> builder::CurrentUserSshKeyCreateV1;
    #[doc = "Fetch an SSH public key\n\nFetch an SSH public key associated with the currently authenticated user.\n\nSends a `GET` request to `/v1/me/ssh-keys/{ssh_key}`\n\n```ignore\nlet response = client.current_user_ssh_key_view_v1()\n    .ssh_key(ssh_key)\n    .send()\n    .await;\n```"]
    fn current_user_ssh_key_view_v1(&self) -> builder::CurrentUserSshKeyViewV1;
    #[doc = "Delete an SSH public key\n\nDelete an SSH public key associated with the currently authenticated user.\n\nSends a `DELETE` request to `/v1/me/ssh-keys/{ssh_key}`\n\n```ignore\nlet response = client.current_user_ssh_key_delete_v1()\n    .ssh_key(ssh_key)\n    .send()\n    .await;\n```"]
    fn current_user_ssh_key_delete_v1(&self) -> builder::CurrentUserSshKeyDeleteV1;
}

impl ClientSessionExt for Client {
    fn session_sshkey_list(&self) -> builder::SessionSshkeyList {
        builder::SessionSshkeyList::new(self)
    }

    fn session_sshkey_create(&self) -> builder::SessionSshkeyCreate {
        builder::SessionSshkeyCreate::new(self)
    }

    fn session_sshkey_view(&self) -> builder::SessionSshkeyView {
        builder::SessionSshkeyView::new(self)
    }

    fn session_sshkey_delete(&self) -> builder::SessionSshkeyDelete {
        builder::SessionSshkeyDelete::new(self)
    }

    fn current_user_view_v1(&self) -> builder::CurrentUserViewV1 {
        builder::CurrentUserViewV1::new(self)
    }

    fn current_user_groups_v1(&self) -> builder::CurrentUserGroupsV1 {
        builder::CurrentUserGroupsV1::new(self)
    }

    fn current_user_ssh_key_list_v1(&self) -> builder::CurrentUserSshKeyListV1 {
        builder::CurrentUserSshKeyListV1::new(self)
    }

    fn current_user_ssh_key_create_v1(&self) -> builder::CurrentUserSshKeyCreateV1 {
        builder::CurrentUserSshKeyCreateV1::new(self)
    }

    fn current_user_ssh_key_view_v1(&self) -> builder::CurrentUserSshKeyViewV1 {
        builder::CurrentUserSshKeyViewV1::new(self)
    }

    fn current_user_ssh_key_delete_v1(&self) -> builder::CurrentUserSshKeyDeleteV1 {
        builder::CurrentUserSshKeyDeleteV1::new(self)
    }
}

pub trait ClientSilosExt {
    #[doc = "List groups\n\nUse `GET /v1/groups` instead\n\nSends a `GET` request to `/groups`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.group_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn group_list(&self) -> builder::GroupList;
    #[doc = "Fetch the current silo's IAM policy\n\nUse `GET /v1/policy` instead\n\nSends a `GET` request to `/policy`\n\n```ignore\nlet response = client.policy_view()\n    .send()\n    .await;\n```"]
    fn policy_view(&self) -> builder::PolicyView;
    #[doc = "Update the current silo's IAM policy\n\nUse `PUT /v1/policy` instead\n\nSends a `PUT` request to `/policy`\n\n```ignore\nlet response = client.policy_update()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn policy_update(&self) -> builder::PolicyUpdate;
    #[doc = "List users\n\nUse `GET /v1/users` instead\n\nSends a `GET` request to `/users`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.user_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn user_list(&self) -> builder::UserList;
    #[doc = "List groups\n\nSends a `GET` request to `/v1/groups`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.group_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn group_list_v1(&self) -> builder::GroupListV1;
    #[doc = "Fetch group\n\nSends a `GET` request to `/v1/groups/{group}`\n\n```ignore\nlet response = client.group_view()\n    .group(group)\n    .send()\n    .await;\n```"]
    fn group_view(&self) -> builder::GroupView;
    #[doc = "Fetch the current silo's IAM policy\n\nSends a `GET` request to `/v1/policy`\n\n```ignore\nlet response = client.policy_view_v1()\n    .send()\n    .await;\n```"]
    fn policy_view_v1(&self) -> builder::PolicyViewV1;
    #[doc = "Update the current silo's IAM policy\n\nSends a `PUT` request to `/v1/policy`\n\n```ignore\nlet response = client.policy_update_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn policy_update_v1(&self) -> builder::PolicyUpdateV1;
    #[doc = "List users\n\nSends a `GET` request to `/v1/users`\n\nArguments:\n- `group`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.user_list_v1()\n    .group(group)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn user_list_v1(&self) -> builder::UserListV1;
}

impl ClientSilosExt for Client {
    fn group_list(&self) -> builder::GroupList {
        builder::GroupList::new(self)
    }

    fn policy_view(&self) -> builder::PolicyView {
        builder::PolicyView::new(self)
    }

    fn policy_update(&self) -> builder::PolicyUpdate {
        builder::PolicyUpdate::new(self)
    }

    fn user_list(&self) -> builder::UserList {
        builder::UserList::new(self)
    }

    fn group_list_v1(&self) -> builder::GroupListV1 {
        builder::GroupListV1::new(self)
    }

    fn group_view(&self) -> builder::GroupView {
        builder::GroupView::new(self)
    }

    fn policy_view_v1(&self) -> builder::PolicyViewV1 {
        builder::PolicyViewV1::new(self)
    }

    fn policy_update_v1(&self) -> builder::PolicyUpdateV1 {
        builder::PolicyUpdateV1::new(self)
    }

    fn user_list_v1(&self) -> builder::UserListV1 {
        builder::UserListV1::new(self)
    }
}

pub trait ClientSnapshotsExt {
    #[doc = "Fetch a snapshot by id\n\nUse `GET /v1/snapshots/{snapshot}` instead.\n\nSends a `GET` request to `/by-id/snapshots/{id}`\n\n```ignore\nlet response = client.snapshot_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn snapshot_view_by_id(&self) -> builder::SnapshotViewById;
    #[doc = "List snapshots\n\nUse `GET /v1/snapshots` instead.\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/snapshots`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.snapshot_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn snapshot_list(&self) -> builder::SnapshotList;
    #[doc = "Create a snapshot\n\nUse `POST /v1/snapshots` instead.\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/snapshots`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.snapshot_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn snapshot_create(&self) -> builder::SnapshotCreate;
    #[doc = "Fetch a snapshot\n\nUse `GET /v1/snapshots/{snapshot}` instead.\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/snapshots/{snapshot_name}`\n\n```ignore\nlet response = client.snapshot_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .snapshot_name(snapshot_name)\n    .send()\n    .await;\n```"]
    fn snapshot_view(&self) -> builder::SnapshotView;
    #[doc = "Delete a snapshot\n\nUse `DELETE /v1/snapshots/{snapshot}` instead.\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/snapshots/{snapshot_name}`\n\n```ignore\nlet response = client.snapshot_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .snapshot_name(snapshot_name)\n    .send()\n    .await;\n```"]
    fn snapshot_delete(&self) -> builder::SnapshotDelete;
    #[doc = "List snapshots\n\nSends a `GET` request to `/v1/snapshots`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.snapshot_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn snapshot_list_v1(&self) -> builder::SnapshotListV1;
    #[doc = "Create a snapshot\n\nCreates a point-in-time snapshot from a disk.\n\nSends a `POST` request to `/v1/snapshots`\n\n```ignore\nlet response = client.snapshot_create_v1()\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn snapshot_create_v1(&self) -> builder::SnapshotCreateV1;
    #[doc = "Fetch a snapshot\n\nSends a `GET` request to `/v1/snapshots/{snapshot}`\n\n```ignore\nlet response = client.snapshot_view_v1()\n    .snapshot(snapshot)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn snapshot_view_v1(&self) -> builder::SnapshotViewV1;
    #[doc = "Delete a snapshot\n\nSends a `DELETE` request to `/v1/snapshots/{snapshot}`\n\n```ignore\nlet response = client.snapshot_delete_v1()\n    .snapshot(snapshot)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn snapshot_delete_v1(&self) -> builder::SnapshotDeleteV1;
}

impl ClientSnapshotsExt for Client {
    fn snapshot_view_by_id(&self) -> builder::SnapshotViewById {
        builder::SnapshotViewById::new(self)
    }

    fn snapshot_list(&self) -> builder::SnapshotList {
        builder::SnapshotList::new(self)
    }

    fn snapshot_create(&self) -> builder::SnapshotCreate {
        builder::SnapshotCreate::new(self)
    }

    fn snapshot_view(&self) -> builder::SnapshotView {
        builder::SnapshotView::new(self)
    }

    fn snapshot_delete(&self) -> builder::SnapshotDelete {
        builder::SnapshotDelete::new(self)
    }

    fn snapshot_list_v1(&self) -> builder::SnapshotListV1 {
        builder::SnapshotListV1::new(self)
    }

    fn snapshot_create_v1(&self) -> builder::SnapshotCreateV1 {
        builder::SnapshotCreateV1::new(self)
    }

    fn snapshot_view_v1(&self) -> builder::SnapshotViewV1 {
        builder::SnapshotViewV1::new(self)
    }

    fn snapshot_delete_v1(&self) -> builder::SnapshotDeleteV1 {
        builder::SnapshotDeleteV1::new(self)
    }
}

pub trait ClientSystemExt {
    #[doc = "Fetch a system-wide image by id\n\nSends a `GET` request to `/system/by-id/images/{id}`\n\n```ignore\nlet response = client.system_image_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn system_image_view_by_id(&self) -> builder::SystemImageViewById;
    #[doc = "Fetch an IP pool by id\n\nUse `GET /v1/system/ip-pools/{pool}` instead\n\nSends a `GET` request to `/system/by-id/ip-pools/{id}`\n\n```ignore\nlet response = client.ip_pool_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn ip_pool_view_by_id(&self) -> builder::IpPoolViewById;
    #[doc = "Fetch a silo by id\n\nUse `GET /v1/system/silos/{id}` instead.\n\nSends a `GET` request to `/system/by-id/silos/{id}`\n\n```ignore\nlet response = client.silo_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn silo_view_by_id(&self) -> builder::SiloViewById;
    #[doc = "List system-wide certificates\n\nReturns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first. Use `GET /v1/system/certificates` instead\n\nSends a `GET` request to `/system/certificates`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.certificate_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn certificate_list(&self) -> builder::CertificateList;
    #[doc = "Create a new system-wide x.509 certificate\n\nThis certificate is automatically used by the Oxide Control plane to serve external connections. Use `POST /v1/system/certificates` instead\n\nSends a `POST` request to `/system/certificates`\n\n```ignore\nlet response = client.certificate_create()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn certificate_create(&self) -> builder::CertificateCreate;
    #[doc = "Fetch a certificate\n\nReturns the details of a specific certificate Use `GET /v1/system/certificates/{certificate}` instead\n\nSends a `GET` request to `/system/certificates/{certificate}`\n\n```ignore\nlet response = client.certificate_view()\n    .certificate(certificate)\n    .send()\n    .await;\n```"]
    fn certificate_view(&self) -> builder::CertificateView;
    #[doc = "Delete a certificate\n\nPermanently delete a certificate. This operation cannot be undone. Use `DELETE /v1/system/certificates/{certificate}` instead\n\nSends a `DELETE` request to `/system/certificates/{certificate}`\n\n```ignore\nlet response = client.certificate_delete()\n    .certificate(certificate)\n    .send()\n    .await;\n```"]
    fn certificate_delete(&self) -> builder::CertificateDelete;
    #[doc = "List physical disks\n\nUse `GET /v1/system/hardware/disks` instead\n\nSends a `GET` request to `/system/hardware/disks`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.physical_disk_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn physical_disk_list(&self) -> builder::PhysicalDiskList;
    #[doc = "List racks\n\nUse `GET /v1/system/hardware/racks` instead\n\nSends a `GET` request to `/system/hardware/racks`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.rack_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn rack_list(&self) -> builder::RackList;
    #[doc = "Fetch a rack\n\nUse `GET /v1/system/hardware/racks/{rack_id}` instead\n\nSends a `GET` request to `/system/hardware/racks/{rack_id}`\n\nArguments:\n- `rack_id`: The rack's unique ID.\n```ignore\nlet response = client.rack_view()\n    .rack_id(rack_id)\n    .send()\n    .await;\n```"]
    fn rack_view(&self) -> builder::RackView;
    #[doc = "List sleds\n\nUse `GET /v1/system/hardware/sleds instead`\n\nSends a `GET` request to `/system/hardware/sleds`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.sled_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn sled_list(&self) -> builder::SledList;
    #[doc = "Fetch a sled\n\nUse `GET /v1/system/hardware/sleds/{sled_id}` instead\n\nSends a `GET` request to `/system/hardware/sleds/{sled_id}`\n\nArguments:\n- `sled_id`: The sled's unique ID.\n```ignore\nlet response = client.sled_view()\n    .sled_id(sled_id)\n    .send()\n    .await;\n```"]
    fn sled_view(&self) -> builder::SledView;
    #[doc = "List physical disks attached to sleds\n\nUse `GET /v1/system/hardware/sleds/{sled_id}/disks` instead\n\nSends a `GET` request to `/system/hardware/sleds/{sled_id}/disks`\n\nArguments:\n- `sled_id`: The sled's unique ID.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.sled_physical_disk_list()\n    .sled_id(sled_id)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn sled_physical_disk_list(&self) -> builder::SledPhysicalDiskList;
    #[doc = "List system-wide images\n\nReturns a list of all the system-wide images. System-wide images are returned sorted by creation date, with the most recent images appearing first.\n\nSends a `GET` request to `/system/images`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.system_image_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn system_image_list(&self) -> builder::SystemImageList;
    #[doc = "Create a system-wide image\n\nCreate a new system-wide image. This image can then be used by any user in any silo as a base for instances.\n\nSends a `POST` request to `/system/images`\n\n```ignore\nlet response = client.system_image_create()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn system_image_create(&self) -> builder::SystemImageCreate;
    #[doc = "Fetch a system-wide image\n\nReturns the details of a specific system-wide image.\n\nSends a `GET` request to `/system/images/{image_name}`\n\n```ignore\nlet response = client.system_image_view()\n    .image_name(image_name)\n    .send()\n    .await;\n```"]
    fn system_image_view(&self) -> builder::SystemImageView;
    #[doc = "Delete a system-wide image\n\nPermanently delete a system-wide image. This operation cannot be undone. Any instances using the system-wide image will continue to run, however new instances can not be created with this image.\n\nSends a `DELETE` request to `/system/images/{image_name}`\n\n```ignore\nlet response = client.system_image_delete()\n    .image_name(image_name)\n    .send()\n    .await;\n```"]
    fn system_image_delete(&self) -> builder::SystemImageDelete;
    #[doc = "List IP pools\n\nUse `GET /v1/system/ip-pools` instead\n\nSends a `GET` request to `/system/ip-pools`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.ip_pool_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn ip_pool_list(&self) -> builder::IpPoolList;
    #[doc = "Create an IP pool\n\nUse `POST /v1/system/ip-pools` instead\n\nSends a `POST` request to `/system/ip-pools`\n\n```ignore\nlet response = client.ip_pool_create()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_create(&self) -> builder::IpPoolCreate;
    #[doc = "Fetch an IP pool\n\nUse `GET /v1/system/ip-pools/{pool}` instead\n\nSends a `GET` request to `/system/ip-pools/{pool_name}`\n\n```ignore\nlet response = client.ip_pool_view()\n    .pool_name(pool_name)\n    .send()\n    .await;\n```"]
    fn ip_pool_view(&self) -> builder::IpPoolView;
    #[doc = "Update an IP Pool\n\nUse `PUT /v1/system/ip-pools/{pool}` instead\n\nSends a `PUT` request to `/system/ip-pools/{pool_name}`\n\n```ignore\nlet response = client.ip_pool_update()\n    .pool_name(pool_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_update(&self) -> builder::IpPoolUpdate;
    #[doc = "Delete an IP Pool\n\nUse `DELETE /v1/system/ip-pools/{pool}` instead\n\nSends a `DELETE` request to `/system/ip-pools/{pool_name}`\n\n```ignore\nlet response = client.ip_pool_delete()\n    .pool_name(pool_name)\n    .send()\n    .await;\n```"]
    fn ip_pool_delete(&self) -> builder::IpPoolDelete;
    #[doc = "List ranges for an IP pool\n\nRanges are ordered by their first address. Use `GET /v1/system/ip-pools/{pool}/ranges` instead\n\nSends a `GET` request to `/system/ip-pools/{pool_name}/ranges`\n\nArguments:\n- `pool_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n```ignore\nlet response = client.ip_pool_range_list()\n    .pool_name(pool_name)\n    .limit(limit)\n    .page_token(page_token)\n    .send()\n    .await;\n```"]
    fn ip_pool_range_list(&self) -> builder::IpPoolRangeList;
    #[doc = "Add a range to an IP pool\n\nUse `POST /v1/system/ip-pools/{pool}/ranges/add` instead\n\nSends a `POST` request to `/system/ip-pools/{pool_name}/ranges/add`\n\n```ignore\nlet response = client.ip_pool_range_add()\n    .pool_name(pool_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_range_add(&self) -> builder::IpPoolRangeAdd;
    #[doc = "Remove a range from an IP pool\n\nUse `POST /v1/system/ip-pools/{pool}/ranges/remove` instead.\n\nSends a `POST` request to `/system/ip-pools/{pool_name}/ranges/remove`\n\n```ignore\nlet response = client.ip_pool_range_remove()\n    .pool_name(pool_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_range_remove(&self) -> builder::IpPoolRangeRemove;
    #[doc = "Fetch the IP pool used for Oxide services\n\nUse `GET /v1/system/ip-pools-service` instead\n\nSends a `GET` request to `/system/ip-pools-service`\n\n```ignore\nlet response = client.ip_pool_service_view()\n    .send()\n    .await;\n```"]
    fn ip_pool_service_view(&self) -> builder::IpPoolServiceView;
    #[doc = "List ranges for the IP pool used for Oxide services\n\nRanges are ordered by their first address. Use `GET /v1/system/ip-pools-service/ranges` instead.\n\nSends a `GET` request to `/system/ip-pools-service/ranges`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n```ignore\nlet response = client.ip_pool_service_range_list()\n    .limit(limit)\n    .page_token(page_token)\n    .send()\n    .await;\n```"]
    fn ip_pool_service_range_list(&self) -> builder::IpPoolServiceRangeList;
    #[doc = "Add a range to an IP pool used for Oxide services\n\nUse `POST /v1/system/ip-pools-service/ranges/add` instead\n\nSends a `POST` request to `/system/ip-pools-service/ranges/add`\n\n```ignore\nlet response = client.ip_pool_service_range_add()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_service_range_add(&self) -> builder::IpPoolServiceRangeAdd;
    #[doc = "Remove a range from an IP pool used for Oxide services\n\nUse `POST /v1/system/ip-pools-service/ranges/remove` instead\n\nSends a `POST` request to `/system/ip-pools-service/ranges/remove`\n\n```ignore\nlet response = client.ip_pool_service_range_remove()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_service_range_remove(&self) -> builder::IpPoolServiceRangeRemove;
    #[doc = "Access metrics data\n\nSends a `GET` request to `/system/metrics/{metric_name}`\n\nArguments:\n- `metric_name`\n- `end_time`: An exclusive end time of metrics.\n- `id`: The UUID of the container being queried\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `start_time`: An inclusive start time of metrics.\n```ignore\nlet response = client.system_metric()\n    .metric_name(metric_name)\n    .end_time(end_time)\n    .id(id)\n    .limit(limit)\n    .page_token(page_token)\n    .start_time(start_time)\n    .send()\n    .await;\n```"]
    fn system_metric(&self) -> builder::SystemMetric;
    #[doc = "List sagas\n\nUse `GET v1/system/sagas` instead\n\nSends a `GET` request to `/system/sagas`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.saga_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn saga_list(&self) -> builder::SagaList;
    #[doc = "Fetch a saga\n\nUse `GET v1/system/sagas/{saga_id}` instead\n\nSends a `GET` request to `/system/sagas/{saga_id}`\n\n```ignore\nlet response = client.saga_view()\n    .saga_id(saga_id)\n    .send()\n    .await;\n```"]
    fn saga_view(&self) -> builder::SagaView;
    #[doc = "List silos\n\nLists silos that are discoverable based on the current permissions. Use `GET /v1/system/silos` instead\n\nSends a `GET` request to `/system/silos`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.silo_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn silo_list(&self) -> builder::SiloList;
    #[doc = "Create a silo\n\nUse `POST /v1/system/silos` instead\n\nSends a `POST` request to `/system/silos`\n\n```ignore\nlet response = client.silo_create()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn silo_create(&self) -> builder::SiloCreate;
    #[doc = "Fetch a silo\n\nFetch a silo by name. Use `GET /v1/system/silos/{silo}` instead.\n\nSends a `GET` request to `/system/silos/{silo_name}`\n\nArguments:\n- `silo_name`: The silo's unique name.\n```ignore\nlet response = client.silo_view()\n    .silo_name(silo_name)\n    .send()\n    .await;\n```"]
    fn silo_view(&self) -> builder::SiloView;
    #[doc = "Delete a silo\n\nDelete a silo by name. Use `DELETE /v1/system/silos/{silo}` instead.\n\nSends a `DELETE` request to `/system/silos/{silo_name}`\n\nArguments:\n- `silo_name`: The silo's unique name.\n```ignore\nlet response = client.silo_delete()\n    .silo_name(silo_name)\n    .send()\n    .await;\n```"]
    fn silo_delete(&self) -> builder::SiloDelete;
    #[doc = "List a silo's IDPs\n\nUse `/v1/system/silos/{silo}/identity-providers` instead.\n\nSends a `GET` request to `/system/silos/{silo_name}/identity-providers`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.silo_identity_provider_list()\n    .silo_name(silo_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn silo_identity_provider_list(&self) -> builder::SiloIdentityProviderList;
    #[doc = "Create a user\n\nUsers can only be created in Silos with `provision_type` == `Fixed`. Otherwise, Silo users are just-in-time (JIT) provisioned when a user first logs in using an external Identity Provider.\n\nSends a `POST` request to `/system/silos/{silo_name}/identity-providers/local/users`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `body`\n```ignore\nlet response = client.local_idp_user_create()\n    .silo_name(silo_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn local_idp_user_create(&self) -> builder::LocalIdpUserCreate;
    #[doc = "Delete a user\n\nUse `DELETE /v1/system/identity-providers/local/users/{user_id}` instead\n\nSends a `DELETE` request to `/system/silos/{silo_name}/identity-providers/local/users/{user_id}`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `user_id`: The user's internal id\n```ignore\nlet response = client.local_idp_user_delete()\n    .silo_name(silo_name)\n    .user_id(user_id)\n    .send()\n    .await;\n```"]
    fn local_idp_user_delete(&self) -> builder::LocalIdpUserDelete;
    #[doc = "Set or invalidate a user's password\n\nPasswords can only be updated for users in Silos with identity mode `LocalOnly`. Use `POST /v1/system/identity-providers/local/users/{user_id}/set-password` instead\n\nSends a `POST` request to `/system/silos/{silo_name}/identity-providers/local/users/{user_id}/set-password`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `user_id`: The user's internal id\n- `body`\n```ignore\nlet response = client.local_idp_user_set_password()\n    .silo_name(silo_name)\n    .user_id(user_id)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn local_idp_user_set_password(&self) -> builder::LocalIdpUserSetPassword;
    #[doc = "Create a SAML IDP\n\nUse `POST /v1/system/identity-providers/saml` instead.\n\nSends a `POST` request to `/system/silos/{silo_name}/identity-providers/saml`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `body`\n```ignore\nlet response = client.saml_identity_provider_create()\n    .silo_name(silo_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn saml_identity_provider_create(&self) -> builder::SamlIdentityProviderCreate;
    #[doc = "Fetch a SAML IDP\n\nUse `GET /v1/system/identity-providers/saml/{provider_name}` instead\n\nSends a `GET` request to `/system/silos/{silo_name}/identity-providers/saml/{provider_name}`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `provider_name`: The SAML identity provider's name\n```ignore\nlet response = client.saml_identity_provider_view()\n    .silo_name(silo_name)\n    .provider_name(provider_name)\n    .send()\n    .await;\n```"]
    fn saml_identity_provider_view(&self) -> builder::SamlIdentityProviderView;
    #[doc = "Fetch a silo's IAM policy\n\nUse `GET /v1/system/silos/{silo}/policy` instead.\n\nSends a `GET` request to `/system/silos/{silo_name}/policy`\n\nArguments:\n- `silo_name`: The silo's unique name.\n```ignore\nlet response = client.silo_policy_view()\n    .silo_name(silo_name)\n    .send()\n    .await;\n```"]
    fn silo_policy_view(&self) -> builder::SiloPolicyView;
    #[doc = "Update a silo's IAM policy\n\nUse `PUT /v1/system/silos/{silo}/policy` instead\n\nSends a `PUT` request to `/system/silos/{silo_name}/policy`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `body`\n```ignore\nlet response = client.silo_policy_update()\n    .silo_name(silo_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn silo_policy_update(&self) -> builder::SiloPolicyUpdate;
    #[doc = "List users in a silo\n\nUse `GET /v1/system/users` instead.\n\nSends a `GET` request to `/system/silos/{silo_name}/users/all`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.silo_users_list()\n    .silo_name(silo_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn silo_users_list(&self) -> builder::SiloUsersList;
    #[doc = "Fetch a user\n\nUse `GET /v1/system/users/{user_id}` instead\n\nSends a `GET` request to `/system/silos/{silo_name}/users/id/{user_id}`\n\nArguments:\n- `silo_name`: The silo's unique name.\n- `user_id`: The user's internal id\n```ignore\nlet response = client.silo_user_view()\n    .silo_name(silo_name)\n    .user_id(user_id)\n    .send()\n    .await;\n```"]
    fn silo_user_view(&self) -> builder::SiloUserView;
    #[doc = "List built-in users\n\nSends a `GET` request to `/system/user`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.system_user_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn system_user_list(&self) -> builder::SystemUserList;
    #[doc = "Fetch a built-in user\n\nSends a `GET` request to `/system/user/{user_name}`\n\nArguments:\n- `user_name`: The built-in user's unique name.\n```ignore\nlet response = client.system_user_view()\n    .user_name(user_name)\n    .send()\n    .await;\n```"]
    fn system_user_view(&self) -> builder::SystemUserView;
    #[doc = "List system-wide certificates\n\nReturns a list of all the system-wide certificates. System-wide certificates are returned sorted by creation date, with the most recent certificates appearing first.\n\nSends a `GET` request to `/v1/system/certificates`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.certificate_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn certificate_list_v1(&self) -> builder::CertificateListV1;
    #[doc = "Create a new system-wide x.509 certificate\n\nThis certificate is automatically used by the Oxide Control plane to serve external connections.\n\nSends a `POST` request to `/v1/system/certificates`\n\n```ignore\nlet response = client.certificate_create_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn certificate_create_v1(&self) -> builder::CertificateCreateV1;
    #[doc = "Fetch a certificate\n\nReturns the details of a specific certificate\n\nSends a `GET` request to `/v1/system/certificates/{certificate}`\n\n```ignore\nlet response = client.certificate_view_v1()\n    .certificate(certificate)\n    .send()\n    .await;\n```"]
    fn certificate_view_v1(&self) -> builder::CertificateViewV1;
    #[doc = "Delete a certificate\n\nPermanently delete a certificate. This operation cannot be undone.\n\nSends a `DELETE` request to `/v1/system/certificates/{certificate}`\n\n```ignore\nlet response = client.certificate_delete_v1()\n    .certificate(certificate)\n    .send()\n    .await;\n```"]
    fn certificate_delete_v1(&self) -> builder::CertificateDeleteV1;
    #[doc = "List physical disks\n\nSends a `GET` request to `/v1/system/hardware/disks`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.physical_disk_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn physical_disk_list_v1(&self) -> builder::PhysicalDiskListV1;
    #[doc = "List racks\n\nSends a `GET` request to `/v1/system/hardware/racks`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.rack_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn rack_list_v1(&self) -> builder::RackListV1;
    #[doc = "Fetch a rack\n\nSends a `GET` request to `/v1/system/hardware/racks/{rack_id}`\n\nArguments:\n- `rack_id`: The rack's unique ID.\n```ignore\nlet response = client.rack_view_v1()\n    .rack_id(rack_id)\n    .send()\n    .await;\n```"]
    fn rack_view_v1(&self) -> builder::RackViewV1;
    #[doc = "List sleds\n\nSends a `GET` request to `/v1/system/hardware/sleds`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.sled_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn sled_list_v1(&self) -> builder::SledListV1;
    #[doc = "Fetch a sled\n\nSends a `GET` request to `/v1/system/hardware/sleds/{sled_id}`\n\nArguments:\n- `sled_id`: The sled's unique ID.\n```ignore\nlet response = client.sled_view_v1()\n    .sled_id(sled_id)\n    .send()\n    .await;\n```"]
    fn sled_view_v1(&self) -> builder::SledViewV1;
    #[doc = "List physical disks attached to sleds\n\nSends a `GET` request to `/v1/system/hardware/sleds/{sled_id}/disks`\n\nArguments:\n- `sled_id`: The sled's unique ID.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.sled_physical_disk_list_v1()\n    .sled_id(sled_id)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn sled_physical_disk_list_v1(&self) -> builder::SledPhysicalDiskListV1;
    #[doc = "List a silo's IDPs_name\n\nSends a `GET` request to `/v1/system/identity-providers`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `silo`\n- `sort_by`\n```ignore\nlet response = client.silo_identity_provider_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .silo(silo)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn silo_identity_provider_list_v1(&self) -> builder::SiloIdentityProviderListV1;
    #[doc = "Create a user\n\nUsers can only be created in Silos with `provision_type` == `Fixed`. Otherwise, Silo users are just-in-time (JIT) provisioned when a user first logs in using an external Identity Provider. Use `POST /v1/system/identity-providers/local/users` instead\n\nSends a `POST` request to `/v1/system/identity-providers/local/users`\n\n```ignore\nlet response = client.local_idp_user_create_v1()\n    .silo(silo)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn local_idp_user_create_v1(&self) -> builder::LocalIdpUserCreateV1;
    #[doc = "Delete a user\n\nSends a `DELETE` request to `/v1/system/identity-providers/local/users/{user_id}`\n\nArguments:\n- `user_id`: The user's internal id\n- `silo`\n```ignore\nlet response = client.local_idp_user_delete_v1()\n    .user_id(user_id)\n    .silo(silo)\n    .send()\n    .await;\n```"]
    fn local_idp_user_delete_v1(&self) -> builder::LocalIdpUserDeleteV1;
    #[doc = "Set or invalidate a user's password\n\nPasswords can only be updated for users in Silos with identity mode `LocalOnly`.\n\nSends a `POST` request to `/v1/system/identity-providers/local/users/{user_id}/set-password`\n\nArguments:\n- `user_id`: The user's internal id\n- `silo`\n- `body`\n```ignore\nlet response = client.local_idp_user_set_password_v1()\n    .user_id(user_id)\n    .silo(silo)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn local_idp_user_set_password_v1(&self) -> builder::LocalIdpUserSetPasswordV1;
    #[doc = "Create a SAML IDP\n\nSends a `POST` request to `/v1/system/identity-providers/saml`\n\n```ignore\nlet response = client.saml_identity_provider_create_v1()\n    .silo(silo)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn saml_identity_provider_create_v1(&self) -> builder::SamlIdentityProviderCreateV1;
    #[doc = "Fetch a SAML IDP\n\nSends a `GET` request to `/v1/system/identity-providers/saml/{provider}`\n\n```ignore\nlet response = client.saml_identity_provider_view_v1()\n    .provider(provider)\n    .silo(silo)\n    .send()\n    .await;\n```"]
    fn saml_identity_provider_view_v1(&self) -> builder::SamlIdentityProviderViewV1;
    #[doc = "List IP pools\n\nSends a `GET` request to `/v1/system/ip-pools`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.ip_pool_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn ip_pool_list_v1(&self) -> builder::IpPoolListV1;
    #[doc = "Create an IP pool\n\nSends a `POST` request to `/v1/system/ip-pools`\n\n```ignore\nlet response = client.ip_pool_create_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_create_v1(&self) -> builder::IpPoolCreateV1;
    #[doc = "Fetch an IP pool\n\nSends a `GET` request to `/v1/system/ip-pools/{pool}`\n\n```ignore\nlet response = client.ip_pool_view_v1()\n    .pool(pool)\n    .send()\n    .await;\n```"]
    fn ip_pool_view_v1(&self) -> builder::IpPoolViewV1;
    #[doc = "Update an IP Pool\n\nSends a `PUT` request to `/v1/system/ip-pools/{pool}`\n\n```ignore\nlet response = client.ip_pool_update_v1()\n    .pool(pool)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_update_v1(&self) -> builder::IpPoolUpdateV1;
    #[doc = "Delete an IP Pool\n\nSends a `DELETE` request to `/v1/system/ip-pools/{pool}`\n\n```ignore\nlet response = client.ip_pool_delete_v1()\n    .pool(pool)\n    .send()\n    .await;\n```"]
    fn ip_pool_delete_v1(&self) -> builder::IpPoolDeleteV1;
    #[doc = "List ranges for an IP pool\n\nRanges are ordered by their first address.\n\nSends a `GET` request to `/v1/system/ip-pools/{pool}/ranges`\n\nArguments:\n- `pool`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n```ignore\nlet response = client.ip_pool_range_list_v1()\n    .pool(pool)\n    .limit(limit)\n    .page_token(page_token)\n    .send()\n    .await;\n```"]
    fn ip_pool_range_list_v1(&self) -> builder::IpPoolRangeListV1;
    #[doc = "Add a range to an IP pool\n\nSends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/add`\n\n```ignore\nlet response = client.ip_pool_range_add_v1()\n    .pool(pool)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_range_add_v1(&self) -> builder::IpPoolRangeAddV1;
    #[doc = "Remove a range from an IP pool\n\nSends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/remove`\n\n```ignore\nlet response = client.ip_pool_range_remove_v1()\n    .pool(pool)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_range_remove_v1(&self) -> builder::IpPoolRangeRemoveV1;
    #[doc = "Fetch the IP pool used for Oxide services\n\nSends a `GET` request to `/v1/system/ip-pools-service`\n\n```ignore\nlet response = client.ip_pool_service_view_v1()\n    .send()\n    .await;\n```"]
    fn ip_pool_service_view_v1(&self) -> builder::IpPoolServiceViewV1;
    #[doc = "List ranges for the IP pool used for Oxide services\n\nRanges are ordered by their first address.\n\nSends a `GET` request to `/v1/system/ip-pools-service/ranges`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n```ignore\nlet response = client.ip_pool_service_range_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .send()\n    .await;\n```"]
    fn ip_pool_service_range_list_v1(&self) -> builder::IpPoolServiceRangeListV1;
    #[doc = "Add a range to an IP pool used for Oxide services\n\nSends a `POST` request to `/v1/system/ip-pools-service/ranges/add`\n\n```ignore\nlet response = client.ip_pool_service_range_add_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_service_range_add_v1(&self) -> builder::IpPoolServiceRangeAddV1;
    #[doc = "Remove a range from an IP pool used for Oxide services\n\nSends a `POST` request to `/v1/system/ip-pools-service/ranges/remove`\n\n```ignore\nlet response = client.ip_pool_service_range_remove_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn ip_pool_service_range_remove_v1(&self) -> builder::IpPoolServiceRangeRemoveV1;
    #[doc = "List sagas\n\nSends a `GET` request to `/v1/system/sagas`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.saga_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn saga_list_v1(&self) -> builder::SagaListV1;
    #[doc = "Fetch a saga\n\nSends a `GET` request to `/v1/system/sagas/{saga_id}`\n\n```ignore\nlet response = client.saga_view_v1()\n    .saga_id(saga_id)\n    .send()\n    .await;\n```"]
    fn saga_view_v1(&self) -> builder::SagaViewV1;
    #[doc = "List silos\n\nLists silos that are discoverable based on the current permissions.\n\nSends a `GET` request to `/v1/system/silos`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.silo_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn silo_list_v1(&self) -> builder::SiloListV1;
    #[doc = "Create a silo\n\nSends a `POST` request to `/v1/system/silos`\n\n```ignore\nlet response = client.silo_create_v1()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn silo_create_v1(&self) -> builder::SiloCreateV1;
    #[doc = "Fetch a silo\n\nFetch a silo by name.\n\nSends a `GET` request to `/v1/system/silos/{silo}`\n\n```ignore\nlet response = client.silo_view_v1()\n    .silo(silo)\n    .send()\n    .await;\n```"]
    fn silo_view_v1(&self) -> builder::SiloViewV1;
    #[doc = "Delete a silo\n\nDelete a silo by name.\n\nSends a `DELETE` request to `/v1/system/silos/{silo}`\n\n```ignore\nlet response = client.silo_delete_v1()\n    .silo(silo)\n    .send()\n    .await;\n```"]
    fn silo_delete_v1(&self) -> builder::SiloDeleteV1;
    #[doc = "Fetch a silo's IAM policy\n\nSends a `GET` request to `/v1/system/silos/{silo}/policy`\n\n```ignore\nlet response = client.silo_policy_view_v1()\n    .silo(silo)\n    .send()\n    .await;\n```"]
    fn silo_policy_view_v1(&self) -> builder::SiloPolicyViewV1;
    #[doc = "Update a silo's IAM policy\n\nSends a `PUT` request to `/v1/system/silos/{silo}/policy`\n\n```ignore\nlet response = client.silo_policy_update_v1()\n    .silo(silo)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn silo_policy_update_v1(&self) -> builder::SiloPolicyUpdateV1;
    #[doc = "View version and update status of component tree\n\nSends a `GET` request to `/v1/system/update/components`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.system_component_version_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn system_component_version_list(&self) -> builder::SystemComponentVersionList;
    #[doc = "List all update deployments\n\nSends a `GET` request to `/v1/system/update/deployments`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.update_deployments_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn update_deployments_list(&self) -> builder::UpdateDeploymentsList;
    #[doc = "Fetch a system update deployment\n\nSends a `GET` request to `/v1/system/update/deployments/{id}`\n\n```ignore\nlet response = client.update_deployment_view()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn update_deployment_view(&self) -> builder::UpdateDeploymentView;
    #[doc = "Refresh update data\n\nSends a `POST` request to `/v1/system/update/refresh`\n\n```ignore\nlet response = client.system_update_refresh()\n    .send()\n    .await;\n```"]
    fn system_update_refresh(&self) -> builder::SystemUpdateRefresh;
    #[doc = "Start system update\n\nSends a `POST` request to `/v1/system/update/start`\n\n```ignore\nlet response = client.system_update_start()\n    .body(body)\n    .send()\n    .await;\n```"]
    fn system_update_start(&self) -> builder::SystemUpdateStart;
    #[doc = "Stop system update\n\nIf there is no update in progress, do nothing.\n\nSends a `POST` request to `/v1/system/update/stop`\n\n```ignore\nlet response = client.system_update_stop()\n    .send()\n    .await;\n```"]
    fn system_update_stop(&self) -> builder::SystemUpdateStop;
    #[doc = "List all updates\n\nSends a `GET` request to `/v1/system/update/updates`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.system_update_list()\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn system_update_list(&self) -> builder::SystemUpdateList;
    #[doc = "View system update\n\nSends a `GET` request to `/v1/system/update/updates/{version}`\n\n```ignore\nlet response = client.system_update_view()\n    .version(version)\n    .send()\n    .await;\n```"]
    fn system_update_view(&self) -> builder::SystemUpdateView;
    #[doc = "View system update component tree\n\nSends a `GET` request to `/v1/system/update/updates/{version}/components`\n\n```ignore\nlet response = client.system_update_components_list()\n    .version(version)\n    .send()\n    .await;\n```"]
    fn system_update_components_list(&self) -> builder::SystemUpdateComponentsList;
    #[doc = "View system version and update status\n\nSends a `GET` request to `/v1/system/update/version`\n\n```ignore\nlet response = client.system_version()\n    .send()\n    .await;\n```"]
    fn system_version(&self) -> builder::SystemVersion;
    #[doc = "List users in a silo\n\nSends a `GET` request to `/v1/system/users`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `silo`\n- `sort_by`\n```ignore\nlet response = client.silo_user_list_v1()\n    .limit(limit)\n    .page_token(page_token)\n    .silo(silo)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn silo_user_list_v1(&self) -> builder::SiloUserListV1;
    #[doc = "Fetch a user\n\nSends a `GET` request to `/v1/system/users/{user_id}`\n\nArguments:\n- `user_id`: The user's internal id\n- `silo`\n```ignore\nlet response = client.silo_user_view_v1()\n    .user_id(user_id)\n    .silo(silo)\n    .send()\n    .await;\n```"]
    fn silo_user_view_v1(&self) -> builder::SiloUserViewV1;
}

impl ClientSystemExt for Client {
    fn system_image_view_by_id(&self) -> builder::SystemImageViewById {
        builder::SystemImageViewById::new(self)
    }

    fn ip_pool_view_by_id(&self) -> builder::IpPoolViewById {
        builder::IpPoolViewById::new(self)
    }

    fn silo_view_by_id(&self) -> builder::SiloViewById {
        builder::SiloViewById::new(self)
    }

    fn certificate_list(&self) -> builder::CertificateList {
        builder::CertificateList::new(self)
    }

    fn certificate_create(&self) -> builder::CertificateCreate {
        builder::CertificateCreate::new(self)
    }

    fn certificate_view(&self) -> builder::CertificateView {
        builder::CertificateView::new(self)
    }

    fn certificate_delete(&self) -> builder::CertificateDelete {
        builder::CertificateDelete::new(self)
    }

    fn physical_disk_list(&self) -> builder::PhysicalDiskList {
        builder::PhysicalDiskList::new(self)
    }

    fn rack_list(&self) -> builder::RackList {
        builder::RackList::new(self)
    }

    fn rack_view(&self) -> builder::RackView {
        builder::RackView::new(self)
    }

    fn sled_list(&self) -> builder::SledList {
        builder::SledList::new(self)
    }

    fn sled_view(&self) -> builder::SledView {
        builder::SledView::new(self)
    }

    fn sled_physical_disk_list(&self) -> builder::SledPhysicalDiskList {
        builder::SledPhysicalDiskList::new(self)
    }

    fn system_image_list(&self) -> builder::SystemImageList {
        builder::SystemImageList::new(self)
    }

    fn system_image_create(&self) -> builder::SystemImageCreate {
        builder::SystemImageCreate::new(self)
    }

    fn system_image_view(&self) -> builder::SystemImageView {
        builder::SystemImageView::new(self)
    }

    fn system_image_delete(&self) -> builder::SystemImageDelete {
        builder::SystemImageDelete::new(self)
    }

    fn ip_pool_list(&self) -> builder::IpPoolList {
        builder::IpPoolList::new(self)
    }

    fn ip_pool_create(&self) -> builder::IpPoolCreate {
        builder::IpPoolCreate::new(self)
    }

    fn ip_pool_view(&self) -> builder::IpPoolView {
        builder::IpPoolView::new(self)
    }

    fn ip_pool_update(&self) -> builder::IpPoolUpdate {
        builder::IpPoolUpdate::new(self)
    }

    fn ip_pool_delete(&self) -> builder::IpPoolDelete {
        builder::IpPoolDelete::new(self)
    }

    fn ip_pool_range_list(&self) -> builder::IpPoolRangeList {
        builder::IpPoolRangeList::new(self)
    }

    fn ip_pool_range_add(&self) -> builder::IpPoolRangeAdd {
        builder::IpPoolRangeAdd::new(self)
    }

    fn ip_pool_range_remove(&self) -> builder::IpPoolRangeRemove {
        builder::IpPoolRangeRemove::new(self)
    }

    fn ip_pool_service_view(&self) -> builder::IpPoolServiceView {
        builder::IpPoolServiceView::new(self)
    }

    fn ip_pool_service_range_list(&self) -> builder::IpPoolServiceRangeList {
        builder::IpPoolServiceRangeList::new(self)
    }

    fn ip_pool_service_range_add(&self) -> builder::IpPoolServiceRangeAdd {
        builder::IpPoolServiceRangeAdd::new(self)
    }

    fn ip_pool_service_range_remove(&self) -> builder::IpPoolServiceRangeRemove {
        builder::IpPoolServiceRangeRemove::new(self)
    }

    fn system_metric(&self) -> builder::SystemMetric {
        builder::SystemMetric::new(self)
    }

    fn saga_list(&self) -> builder::SagaList {
        builder::SagaList::new(self)
    }

    fn saga_view(&self) -> builder::SagaView {
        builder::SagaView::new(self)
    }

    fn silo_list(&self) -> builder::SiloList {
        builder::SiloList::new(self)
    }

    fn silo_create(&self) -> builder::SiloCreate {
        builder::SiloCreate::new(self)
    }

    fn silo_view(&self) -> builder::SiloView {
        builder::SiloView::new(self)
    }

    fn silo_delete(&self) -> builder::SiloDelete {
        builder::SiloDelete::new(self)
    }

    fn silo_identity_provider_list(&self) -> builder::SiloIdentityProviderList {
        builder::SiloIdentityProviderList::new(self)
    }

    fn local_idp_user_create(&self) -> builder::LocalIdpUserCreate {
        builder::LocalIdpUserCreate::new(self)
    }

    fn local_idp_user_delete(&self) -> builder::LocalIdpUserDelete {
        builder::LocalIdpUserDelete::new(self)
    }

    fn local_idp_user_set_password(&self) -> builder::LocalIdpUserSetPassword {
        builder::LocalIdpUserSetPassword::new(self)
    }

    fn saml_identity_provider_create(&self) -> builder::SamlIdentityProviderCreate {
        builder::SamlIdentityProviderCreate::new(self)
    }

    fn saml_identity_provider_view(&self) -> builder::SamlIdentityProviderView {
        builder::SamlIdentityProviderView::new(self)
    }

    fn silo_policy_view(&self) -> builder::SiloPolicyView {
        builder::SiloPolicyView::new(self)
    }

    fn silo_policy_update(&self) -> builder::SiloPolicyUpdate {
        builder::SiloPolicyUpdate::new(self)
    }

    fn silo_users_list(&self) -> builder::SiloUsersList {
        builder::SiloUsersList::new(self)
    }

    fn silo_user_view(&self) -> builder::SiloUserView {
        builder::SiloUserView::new(self)
    }

    fn system_user_list(&self) -> builder::SystemUserList {
        builder::SystemUserList::new(self)
    }

    fn system_user_view(&self) -> builder::SystemUserView {
        builder::SystemUserView::new(self)
    }

    fn certificate_list_v1(&self) -> builder::CertificateListV1 {
        builder::CertificateListV1::new(self)
    }

    fn certificate_create_v1(&self) -> builder::CertificateCreateV1 {
        builder::CertificateCreateV1::new(self)
    }

    fn certificate_view_v1(&self) -> builder::CertificateViewV1 {
        builder::CertificateViewV1::new(self)
    }

    fn certificate_delete_v1(&self) -> builder::CertificateDeleteV1 {
        builder::CertificateDeleteV1::new(self)
    }

    fn physical_disk_list_v1(&self) -> builder::PhysicalDiskListV1 {
        builder::PhysicalDiskListV1::new(self)
    }

    fn rack_list_v1(&self) -> builder::RackListV1 {
        builder::RackListV1::new(self)
    }

    fn rack_view_v1(&self) -> builder::RackViewV1 {
        builder::RackViewV1::new(self)
    }

    fn sled_list_v1(&self) -> builder::SledListV1 {
        builder::SledListV1::new(self)
    }

    fn sled_view_v1(&self) -> builder::SledViewV1 {
        builder::SledViewV1::new(self)
    }

    fn sled_physical_disk_list_v1(&self) -> builder::SledPhysicalDiskListV1 {
        builder::SledPhysicalDiskListV1::new(self)
    }

    fn silo_identity_provider_list_v1(&self) -> builder::SiloIdentityProviderListV1 {
        builder::SiloIdentityProviderListV1::new(self)
    }

    fn local_idp_user_create_v1(&self) -> builder::LocalIdpUserCreateV1 {
        builder::LocalIdpUserCreateV1::new(self)
    }

    fn local_idp_user_delete_v1(&self) -> builder::LocalIdpUserDeleteV1 {
        builder::LocalIdpUserDeleteV1::new(self)
    }

    fn local_idp_user_set_password_v1(&self) -> builder::LocalIdpUserSetPasswordV1 {
        builder::LocalIdpUserSetPasswordV1::new(self)
    }

    fn saml_identity_provider_create_v1(&self) -> builder::SamlIdentityProviderCreateV1 {
        builder::SamlIdentityProviderCreateV1::new(self)
    }

    fn saml_identity_provider_view_v1(&self) -> builder::SamlIdentityProviderViewV1 {
        builder::SamlIdentityProviderViewV1::new(self)
    }

    fn ip_pool_list_v1(&self) -> builder::IpPoolListV1 {
        builder::IpPoolListV1::new(self)
    }

    fn ip_pool_create_v1(&self) -> builder::IpPoolCreateV1 {
        builder::IpPoolCreateV1::new(self)
    }

    fn ip_pool_view_v1(&self) -> builder::IpPoolViewV1 {
        builder::IpPoolViewV1::new(self)
    }

    fn ip_pool_update_v1(&self) -> builder::IpPoolUpdateV1 {
        builder::IpPoolUpdateV1::new(self)
    }

    fn ip_pool_delete_v1(&self) -> builder::IpPoolDeleteV1 {
        builder::IpPoolDeleteV1::new(self)
    }

    fn ip_pool_range_list_v1(&self) -> builder::IpPoolRangeListV1 {
        builder::IpPoolRangeListV1::new(self)
    }

    fn ip_pool_range_add_v1(&self) -> builder::IpPoolRangeAddV1 {
        builder::IpPoolRangeAddV1::new(self)
    }

    fn ip_pool_range_remove_v1(&self) -> builder::IpPoolRangeRemoveV1 {
        builder::IpPoolRangeRemoveV1::new(self)
    }

    fn ip_pool_service_view_v1(&self) -> builder::IpPoolServiceViewV1 {
        builder::IpPoolServiceViewV1::new(self)
    }

    fn ip_pool_service_range_list_v1(&self) -> builder::IpPoolServiceRangeListV1 {
        builder::IpPoolServiceRangeListV1::new(self)
    }

    fn ip_pool_service_range_add_v1(&self) -> builder::IpPoolServiceRangeAddV1 {
        builder::IpPoolServiceRangeAddV1::new(self)
    }

    fn ip_pool_service_range_remove_v1(&self) -> builder::IpPoolServiceRangeRemoveV1 {
        builder::IpPoolServiceRangeRemoveV1::new(self)
    }

    fn saga_list_v1(&self) -> builder::SagaListV1 {
        builder::SagaListV1::new(self)
    }

    fn saga_view_v1(&self) -> builder::SagaViewV1 {
        builder::SagaViewV1::new(self)
    }

    fn silo_list_v1(&self) -> builder::SiloListV1 {
        builder::SiloListV1::new(self)
    }

    fn silo_create_v1(&self) -> builder::SiloCreateV1 {
        builder::SiloCreateV1::new(self)
    }

    fn silo_view_v1(&self) -> builder::SiloViewV1 {
        builder::SiloViewV1::new(self)
    }

    fn silo_delete_v1(&self) -> builder::SiloDeleteV1 {
        builder::SiloDeleteV1::new(self)
    }

    fn silo_policy_view_v1(&self) -> builder::SiloPolicyViewV1 {
        builder::SiloPolicyViewV1::new(self)
    }

    fn silo_policy_update_v1(&self) -> builder::SiloPolicyUpdateV1 {
        builder::SiloPolicyUpdateV1::new(self)
    }

    fn system_component_version_list(&self) -> builder::SystemComponentVersionList {
        builder::SystemComponentVersionList::new(self)
    }

    fn update_deployments_list(&self) -> builder::UpdateDeploymentsList {
        builder::UpdateDeploymentsList::new(self)
    }

    fn update_deployment_view(&self) -> builder::UpdateDeploymentView {
        builder::UpdateDeploymentView::new(self)
    }

    fn system_update_refresh(&self) -> builder::SystemUpdateRefresh {
        builder::SystemUpdateRefresh::new(self)
    }

    fn system_update_start(&self) -> builder::SystemUpdateStart {
        builder::SystemUpdateStart::new(self)
    }

    fn system_update_stop(&self) -> builder::SystemUpdateStop {
        builder::SystemUpdateStop::new(self)
    }

    fn system_update_list(&self) -> builder::SystemUpdateList {
        builder::SystemUpdateList::new(self)
    }

    fn system_update_view(&self) -> builder::SystemUpdateView {
        builder::SystemUpdateView::new(self)
    }

    fn system_update_components_list(&self) -> builder::SystemUpdateComponentsList {
        builder::SystemUpdateComponentsList::new(self)
    }

    fn system_version(&self) -> builder::SystemVersion {
        builder::SystemVersion::new(self)
    }

    fn silo_user_list_v1(&self) -> builder::SiloUserListV1 {
        builder::SiloUserListV1::new(self)
    }

    fn silo_user_view_v1(&self) -> builder::SiloUserViewV1 {
        builder::SiloUserViewV1::new(self)
    }
}

pub trait ClientVpcsExt {
    #[doc = "Fetch a route by id\n\nUse `GET /v1/vpc-router-routes/{route}` instead\n\nSends a `GET` request to `/by-id/vpc-router-routes/{id}`\n\n```ignore\nlet response = client.vpc_router_route_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_view_by_id(&self) -> builder::VpcRouterRouteViewById;
    #[doc = "Get a router by id\n\nUse `GET /v1/vpc-routers/{router}` instead\n\nSends a `GET` request to `/by-id/vpc-routers/{id}`\n\n```ignore\nlet response = client.vpc_router_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn vpc_router_view_by_id(&self) -> builder::VpcRouterViewById;
    #[doc = "Fetch a subnet by id\n\nUse `GET /v1/vpc-subnets/{id}` instead\n\nSends a `GET` request to `/by-id/vpc-subnets/{id}`\n\n```ignore\nlet response = client.vpc_subnet_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_view_by_id(&self) -> builder::VpcSubnetViewById;
    #[doc = "Fetch a VPC\n\nUse `GET /v1/vpcs/{id}` instead\n\nSends a `GET` request to `/by-id/vpcs/{id}`\n\n```ignore\nlet response = client.vpc_view_by_id()\n    .id(id)\n    .send()\n    .await;\n```"]
    fn vpc_view_by_id(&self) -> builder::VpcViewById;
    #[doc = "List VPCs\n\nUse `GET /v1/vpcs` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.vpc_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn vpc_list(&self) -> builder::VpcList;
    #[doc = "Create a VPC\n\nUse `POST /v1/vpcs` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs`\n\nArguments:\n- `organization_name`: The organization's unique name.\n- `project_name`: The project's unique name within the organization.\n- `body`\n```ignore\nlet response = client.vpc_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_create(&self) -> builder::VpcCreate;
    #[doc = "Fetch a VPC\n\nUse `GET /v1/vpcs/{vpc}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`\n\n```ignore\nlet response = client.vpc_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .send()\n    .await;\n```"]
    fn vpc_view(&self) -> builder::VpcView;
    #[doc = "Update a VPC\n\nUse `PUT /v1/vpcs/{vpc}` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`\n\n```ignore\nlet response = client.vpc_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_update(&self) -> builder::VpcUpdate;
    #[doc = "Delete a VPC\n\nUse `DELETE /v1/vpcs/{vpc}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`\n\n```ignore\nlet response = client.vpc_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .send()\n    .await;\n```"]
    fn vpc_delete(&self) -> builder::VpcDelete;
    #[doc = "List firewall rules\n\nUse `GET /v1/vpc-firewall-rules` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules`\n\n```ignore\nlet response = client.vpc_firewall_rules_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .send()\n    .await;\n```"]
    fn vpc_firewall_rules_view(&self) -> builder::VpcFirewallRulesView;
    #[doc = "Replace firewall rules\n\nUse `PUT /v1/vpc-firewall-rules` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules`\n\n```ignore\nlet response = client.vpc_firewall_rules_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_firewall_rules_update(&self) -> builder::VpcFirewallRulesUpdate;
    #[doc = "List routers\n\nUse `GET /v1/vpc-routers` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.vpc_router_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn vpc_router_list(&self) -> builder::VpcRouterList;
    #[doc = "Create a router\n\nUse `POST /v1/vpc-routers` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`\n\n```ignore\nlet response = client.vpc_router_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_create(&self) -> builder::VpcRouterCreate;
    #[doc = "Get a router\n\nUse `GET /v1/vpc-routers/{router}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`\n\n```ignore\nlet response = client.vpc_router_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .send()\n    .await;\n```"]
    fn vpc_router_view(&self) -> builder::VpcRouterView;
    #[doc = "Update a router\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`\n\n```ignore\nlet response = client.vpc_router_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_update(&self) -> builder::VpcRouterUpdate;
    #[doc = "Delete a router\n\nUse `DELETE /v1/vpc-routers/{router}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`\n\n```ignore\nlet response = client.vpc_router_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .send()\n    .await;\n```"]
    fn vpc_router_delete(&self) -> builder::VpcRouterDelete;
    #[doc = "List routes\n\nList the routes associated with a router in a particular VPC. Use `GET /v1/vpc-router-routes` instead.\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `router_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.vpc_router_route_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_list(&self) -> builder::VpcRouterRouteList;
    #[doc = "Create a router\n\nUse `POST /v1/vpc-router-routes` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`\n\n```ignore\nlet response = client.vpc_router_route_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_create(&self) -> builder::VpcRouterRouteCreate;
    #[doc = "Fetch a route\n\nUse `GET /v1/vpc-router-routes/{route}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`\n\n```ignore\nlet response = client.vpc_router_route_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .route_name(route_name)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_view(&self) -> builder::VpcRouterRouteView;
    #[doc = "Update a route\n\nUse `PUT /v1/vpc-router-routes/{route}` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`\n\n```ignore\nlet response = client.vpc_router_route_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .route_name(route_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_update(&self) -> builder::VpcRouterRouteUpdate;
    #[doc = "Delete a route\n\nUse `DELETE /v1/vpc-router-routes/{route}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`\n\n```ignore\nlet response = client.vpc_router_route_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .router_name(router_name)\n    .route_name(route_name)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_delete(&self) -> builder::VpcRouterRouteDelete;
    #[doc = "List subnets\n\nUse `GET /v1/vpc-subnets` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.vpc_subnet_list()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_list(&self) -> builder::VpcSubnetList;
    #[doc = "Create a subnet\n\nUse `POST /v1/vpc-subnets` instead\n\nSends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`\n\n```ignore\nlet response = client.vpc_subnet_create()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_create(&self) -> builder::VpcSubnetCreate;
    #[doc = "Fetch a subnet\n\nUse `GET /v1/vpc-subnets/{subnet}` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`\n\n```ignore\nlet response = client.vpc_subnet_view()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .subnet_name(subnet_name)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_view(&self) -> builder::VpcSubnetView;
    #[doc = "Update a subnet\n\nUse `PUT /v1/vpc-subnets/{subnet}` instead\n\nSends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`\n\n```ignore\nlet response = client.vpc_subnet_update()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .subnet_name(subnet_name)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_update(&self) -> builder::VpcSubnetUpdate;
    #[doc = "Delete a subnet\n\nUse `DELETE /v1/vpc-subnets/{subnet}` instead\n\nSends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`\n\n```ignore\nlet response = client.vpc_subnet_delete()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .subnet_name(subnet_name)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_delete(&self) -> builder::VpcSubnetDelete;
    #[doc = "List network interfaces for a VPC subnet\n\nUse `/v1/vpc-subnets/{subnet}/network-interfaces` instead\n\nSends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}/network-interfaces`\n\nArguments:\n- `organization_name`\n- `project_name`\n- `vpc_name`\n- `subnet_name`\n- `limit`: Maximum number of items returned by a single call\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `sort_by`\n```ignore\nlet response = client.vpc_subnet_list_network_interfaces()\n    .organization_name(organization_name)\n    .project_name(project_name)\n    .vpc_name(vpc_name)\n    .subnet_name(subnet_name)\n    .limit(limit)\n    .page_token(page_token)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_list_network_interfaces(&self) -> builder::VpcSubnetListNetworkInterfaces;
    #[doc = "List firewall rules\n\nSends a `GET` request to `/v1/vpc-firewall-rules`\n\n```ignore\nlet response = client.vpc_firewall_rules_view_v1()\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_firewall_rules_view_v1(&self) -> builder::VpcFirewallRulesViewV1;
    #[doc = "Replace firewall rules\n\nSends a `PUT` request to `/v1/vpc-firewall-rules`\n\n```ignore\nlet response = client.vpc_firewall_rules_update_v1()\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_firewall_rules_update_v1(&self) -> builder::VpcFirewallRulesUpdateV1;
    #[doc = "List routes\n\nList the routes associated with a router in a particular VPC.\n\nSends a `GET` request to `/v1/vpc-router-routes`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `router`\n- `sort_by`\n- `vpc`\n```ignore\nlet response = client.vpc_router_route_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .router(router)\n    .sort_by(sort_by)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_list_v1(&self) -> builder::VpcRouterRouteListV1;
    #[doc = "Create a router\n\nSends a `POST` request to `/v1/vpc-router-routes`\n\n```ignore\nlet response = client.vpc_router_route_create_v1()\n    .organization(organization)\n    .project(project)\n    .router(router)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_create_v1(&self) -> builder::VpcRouterRouteCreateV1;
    #[doc = "Fetch a route\n\nSends a `GET` request to `/v1/vpc-router-routes/{route}`\n\n```ignore\nlet response = client.vpc_router_route_view_v1()\n    .route(route)\n    .organization(organization)\n    .project(project)\n    .router(router)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_view_v1(&self) -> builder::VpcRouterRouteViewV1;
    #[doc = "Update a route\n\nSends a `PUT` request to `/v1/vpc-router-routes/{route}`\n\n```ignore\nlet response = client.vpc_router_route_update_v1()\n    .route(route)\n    .organization(organization)\n    .project(project)\n    .router(router)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_update_v1(&self) -> builder::VpcRouterRouteUpdateV1;
    #[doc = "Delete a route\n\nSends a `DELETE` request to `/v1/vpc-router-routes/{route}`\n\n```ignore\nlet response = client.vpc_router_route_delete_v1()\n    .route(route)\n    .organization(organization)\n    .project(project)\n    .router(router)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_router_route_delete_v1(&self) -> builder::VpcRouterRouteDeleteV1;
    #[doc = "List routers\n\nSends a `GET` request to `/v1/vpc-routers`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n- `vpc`\n```ignore\nlet response = client.vpc_router_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_router_list_v1(&self) -> builder::VpcRouterListV1;
    #[doc = "Create a VPC router\n\nSends a `POST` request to `/v1/vpc-routers`\n\n```ignore\nlet response = client.vpc_router_create_v1()\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_create_v1(&self) -> builder::VpcRouterCreateV1;
    #[doc = "Get a router\n\nSends a `GET` request to `/v1/vpc-routers/{router}`\n\n```ignore\nlet response = client.vpc_router_view_v1()\n    .router(router)\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_router_view_v1(&self) -> builder::VpcRouterViewV1;
    #[doc = "Update a router\n\nSends a `PUT` request to `/v1/vpc-routers/{router}`\n\n```ignore\nlet response = client.vpc_router_update_v1()\n    .router(router)\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_router_update_v1(&self) -> builder::VpcRouterUpdateV1;
    #[doc = "Delete a router\n\nSends a `DELETE` request to `/v1/vpc-routers/{router}`\n\n```ignore\nlet response = client.vpc_router_delete_v1()\n    .router(router)\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_router_delete_v1(&self) -> builder::VpcRouterDeleteV1;
    #[doc = "Fetch a subnet\n\nSends a `GET` request to `/v1/vpc-subnets`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n- `vpc`\n```ignore\nlet response = client.vpc_subnet_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_list_v1(&self) -> builder::VpcSubnetListV1;
    #[doc = "Create a subnet\n\nSends a `POST` request to `/v1/vpc-subnets`\n\n```ignore\nlet response = client.vpc_subnet_create_v1()\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_create_v1(&self) -> builder::VpcSubnetCreateV1;
    #[doc = "Fetch a subnet\n\nSends a `GET` request to `/v1/vpc-subnets/{subnet}`\n\n```ignore\nlet response = client.vpc_subnet_view_v1()\n    .subnet(subnet)\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_view_v1(&self) -> builder::VpcSubnetViewV1;
    #[doc = "Update a subnet\n\nSends a `PUT` request to `/v1/vpc-subnets/{subnet}`\n\n```ignore\nlet response = client.vpc_subnet_update_v1()\n    .subnet(subnet)\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_update_v1(&self) -> builder::VpcSubnetUpdateV1;
    #[doc = "Delete a subnet\n\nSends a `DELETE` request to `/v1/vpc-subnets/{subnet}`\n\n```ignore\nlet response = client.vpc_subnet_delete_v1()\n    .subnet(subnet)\n    .organization(organization)\n    .project(project)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_delete_v1(&self) -> builder::VpcSubnetDeleteV1;
    #[doc = "List network interfaces\n\nSends a `GET` request to `/v1/vpc-subnets/{subnet}/network-interfaces`\n\nArguments:\n- `subnet`\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n- `vpc`\n```ignore\nlet response = client.vpc_subnet_list_network_interfaces_v1()\n    .subnet(subnet)\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .vpc(vpc)\n    .send()\n    .await;\n```"]
    fn vpc_subnet_list_network_interfaces_v1(&self) -> builder::VpcSubnetListNetworkInterfacesV1;
    #[doc = "List VPCs\n\nSends a `GET` request to `/v1/vpcs`\n\nArguments:\n- `limit`: Maximum number of items returned by a single call\n- `organization`\n- `page_token`: Token returned by previous call to retrieve the subsequent page\n- `project`\n- `sort_by`\n```ignore\nlet response = client.vpc_list_v1()\n    .limit(limit)\n    .organization(organization)\n    .page_token(page_token)\n    .project(project)\n    .sort_by(sort_by)\n    .send()\n    .await;\n```"]
    fn vpc_list_v1(&self) -> builder::VpcListV1;
    #[doc = "Create a VPC\n\nSends a `POST` request to `/v1/vpcs`\n\n```ignore\nlet response = client.vpc_create_v1()\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_create_v1(&self) -> builder::VpcCreateV1;
    #[doc = "Fetch a VPC\n\nSends a `GET` request to `/v1/vpcs/{vpc}`\n\n```ignore\nlet response = client.vpc_view_v1()\n    .vpc(vpc)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn vpc_view_v1(&self) -> builder::VpcViewV1;
    #[doc = "Update a VPC\n\nSends a `PUT` request to `/v1/vpcs/{vpc}`\n\n```ignore\nlet response = client.vpc_update_v1()\n    .vpc(vpc)\n    .organization(organization)\n    .project(project)\n    .body(body)\n    .send()\n    .await;\n```"]
    fn vpc_update_v1(&self) -> builder::VpcUpdateV1;
    #[doc = "Delete a VPC\n\nSends a `DELETE` request to `/v1/vpcs/{vpc}`\n\n```ignore\nlet response = client.vpc_delete_v1()\n    .vpc(vpc)\n    .organization(organization)\n    .project(project)\n    .send()\n    .await;\n```"]
    fn vpc_delete_v1(&self) -> builder::VpcDeleteV1;
}

impl ClientVpcsExt for Client {
    fn vpc_router_route_view_by_id(&self) -> builder::VpcRouterRouteViewById {
        builder::VpcRouterRouteViewById::new(self)
    }

    fn vpc_router_view_by_id(&self) -> builder::VpcRouterViewById {
        builder::VpcRouterViewById::new(self)
    }

    fn vpc_subnet_view_by_id(&self) -> builder::VpcSubnetViewById {
        builder::VpcSubnetViewById::new(self)
    }

    fn vpc_view_by_id(&self) -> builder::VpcViewById {
        builder::VpcViewById::new(self)
    }

    fn vpc_list(&self) -> builder::VpcList {
        builder::VpcList::new(self)
    }

    fn vpc_create(&self) -> builder::VpcCreate {
        builder::VpcCreate::new(self)
    }

    fn vpc_view(&self) -> builder::VpcView {
        builder::VpcView::new(self)
    }

    fn vpc_update(&self) -> builder::VpcUpdate {
        builder::VpcUpdate::new(self)
    }

    fn vpc_delete(&self) -> builder::VpcDelete {
        builder::VpcDelete::new(self)
    }

    fn vpc_firewall_rules_view(&self) -> builder::VpcFirewallRulesView {
        builder::VpcFirewallRulesView::new(self)
    }

    fn vpc_firewall_rules_update(&self) -> builder::VpcFirewallRulesUpdate {
        builder::VpcFirewallRulesUpdate::new(self)
    }

    fn vpc_router_list(&self) -> builder::VpcRouterList {
        builder::VpcRouterList::new(self)
    }

    fn vpc_router_create(&self) -> builder::VpcRouterCreate {
        builder::VpcRouterCreate::new(self)
    }

    fn vpc_router_view(&self) -> builder::VpcRouterView {
        builder::VpcRouterView::new(self)
    }

    fn vpc_router_update(&self) -> builder::VpcRouterUpdate {
        builder::VpcRouterUpdate::new(self)
    }

    fn vpc_router_delete(&self) -> builder::VpcRouterDelete {
        builder::VpcRouterDelete::new(self)
    }

    fn vpc_router_route_list(&self) -> builder::VpcRouterRouteList {
        builder::VpcRouterRouteList::new(self)
    }

    fn vpc_router_route_create(&self) -> builder::VpcRouterRouteCreate {
        builder::VpcRouterRouteCreate::new(self)
    }

    fn vpc_router_route_view(&self) -> builder::VpcRouterRouteView {
        builder::VpcRouterRouteView::new(self)
    }

    fn vpc_router_route_update(&self) -> builder::VpcRouterRouteUpdate {
        builder::VpcRouterRouteUpdate::new(self)
    }

    fn vpc_router_route_delete(&self) -> builder::VpcRouterRouteDelete {
        builder::VpcRouterRouteDelete::new(self)
    }

    fn vpc_subnet_list(&self) -> builder::VpcSubnetList {
        builder::VpcSubnetList::new(self)
    }

    fn vpc_subnet_create(&self) -> builder::VpcSubnetCreate {
        builder::VpcSubnetCreate::new(self)
    }

    fn vpc_subnet_view(&self) -> builder::VpcSubnetView {
        builder::VpcSubnetView::new(self)
    }

    fn vpc_subnet_update(&self) -> builder::VpcSubnetUpdate {
        builder::VpcSubnetUpdate::new(self)
    }

    fn vpc_subnet_delete(&self) -> builder::VpcSubnetDelete {
        builder::VpcSubnetDelete::new(self)
    }

    fn vpc_subnet_list_network_interfaces(&self) -> builder::VpcSubnetListNetworkInterfaces {
        builder::VpcSubnetListNetworkInterfaces::new(self)
    }

    fn vpc_firewall_rules_view_v1(&self) -> builder::VpcFirewallRulesViewV1 {
        builder::VpcFirewallRulesViewV1::new(self)
    }

    fn vpc_firewall_rules_update_v1(&self) -> builder::VpcFirewallRulesUpdateV1 {
        builder::VpcFirewallRulesUpdateV1::new(self)
    }

    fn vpc_router_route_list_v1(&self) -> builder::VpcRouterRouteListV1 {
        builder::VpcRouterRouteListV1::new(self)
    }

    fn vpc_router_route_create_v1(&self) -> builder::VpcRouterRouteCreateV1 {
        builder::VpcRouterRouteCreateV1::new(self)
    }

    fn vpc_router_route_view_v1(&self) -> builder::VpcRouterRouteViewV1 {
        builder::VpcRouterRouteViewV1::new(self)
    }

    fn vpc_router_route_update_v1(&self) -> builder::VpcRouterRouteUpdateV1 {
        builder::VpcRouterRouteUpdateV1::new(self)
    }

    fn vpc_router_route_delete_v1(&self) -> builder::VpcRouterRouteDeleteV1 {
        builder::VpcRouterRouteDeleteV1::new(self)
    }

    fn vpc_router_list_v1(&self) -> builder::VpcRouterListV1 {
        builder::VpcRouterListV1::new(self)
    }

    fn vpc_router_create_v1(&self) -> builder::VpcRouterCreateV1 {
        builder::VpcRouterCreateV1::new(self)
    }

    fn vpc_router_view_v1(&self) -> builder::VpcRouterViewV1 {
        builder::VpcRouterViewV1::new(self)
    }

    fn vpc_router_update_v1(&self) -> builder::VpcRouterUpdateV1 {
        builder::VpcRouterUpdateV1::new(self)
    }

    fn vpc_router_delete_v1(&self) -> builder::VpcRouterDeleteV1 {
        builder::VpcRouterDeleteV1::new(self)
    }

    fn vpc_subnet_list_v1(&self) -> builder::VpcSubnetListV1 {
        builder::VpcSubnetListV1::new(self)
    }

    fn vpc_subnet_create_v1(&self) -> builder::VpcSubnetCreateV1 {
        builder::VpcSubnetCreateV1::new(self)
    }

    fn vpc_subnet_view_v1(&self) -> builder::VpcSubnetViewV1 {
        builder::VpcSubnetViewV1::new(self)
    }

    fn vpc_subnet_update_v1(&self) -> builder::VpcSubnetUpdateV1 {
        builder::VpcSubnetUpdateV1::new(self)
    }

    fn vpc_subnet_delete_v1(&self) -> builder::VpcSubnetDeleteV1 {
        builder::VpcSubnetDeleteV1::new(self)
    }

    fn vpc_subnet_list_network_interfaces_v1(&self) -> builder::VpcSubnetListNetworkInterfacesV1 {
        builder::VpcSubnetListNetworkInterfacesV1::new(self)
    }

    fn vpc_list_v1(&self) -> builder::VpcListV1 {
        builder::VpcListV1::new(self)
    }

    fn vpc_create_v1(&self) -> builder::VpcCreateV1 {
        builder::VpcCreateV1::new(self)
    }

    fn vpc_view_v1(&self) -> builder::VpcViewV1 {
        builder::VpcViewV1::new(self)
    }

    fn vpc_update_v1(&self) -> builder::VpcUpdateV1 {
        builder::VpcUpdateV1::new(self)
    }

    fn vpc_delete_v1(&self) -> builder::VpcDeleteV1 {
        builder::VpcDeleteV1::new(self)
    }
}

pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        encode_path, ByteStream, Error, HeaderMap, HeaderValue, RequestBuilderExt, ResponseValue,
    };
    #[doc = "Builder for [`ClientDisksExt::disk_view_by_id`]\n\n[`ClientDisksExt::disk_view_by_id`]: super::ClientDisksExt::disk_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct DiskViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> DiskViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/disks/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/disks/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_view_by_id`]\n\n[`ClientImagesExt::image_view_by_id`]: super::ClientImagesExt::image_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct ImageViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> ImageViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/images/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/images/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_view_by_id`]\n\n[`ClientInstancesExt::instance_view_by_id`]: super::ClientInstancesExt::instance_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct InstanceViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> InstanceViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/instances/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/instances/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_view_by_id`]\n\n[`ClientInstancesExt::instance_network_interface_view_by_id`]: super::ClientInstancesExt::instance_network_interface_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> InstanceNetworkInterfaceViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/network-interfaces/{id}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/network-interfaces/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_view_by_id`]\n\n[`ClientOrganizationsExt::organization_view_by_id`]: super::ClientOrganizationsExt::organization_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct OrganizationViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> OrganizationViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/organizations/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/organizations/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_view_by_id`]\n\n[`ClientProjectsExt::project_view_by_id`]: super::ClientProjectsExt::project_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct ProjectViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> ProjectViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/projects/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/projects/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_view_by_id`]\n\n[`ClientSnapshotsExt::snapshot_view_by_id`]: super::ClientSnapshotsExt::snapshot_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct SnapshotViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> SnapshotViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/snapshots/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/snapshots/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_view_by_id`]\n\n[`ClientVpcsExt::vpc_router_route_view_by_id`]: super::ClientVpcsExt::vpc_router_route_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcRouterRouteViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/vpc-router-routes/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_view_by_id`]\n\n[`ClientVpcsExt::vpc_router_view_by_id`]: super::ClientVpcsExt::vpc_router_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcRouterViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/vpc-routers/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpc-routers/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_view_by_id`]\n\n[`ClientVpcsExt::vpc_subnet_view_by_id`]: super::ClientVpcsExt::vpc_subnet_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcSubnetViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/vpc-subnets/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpc-subnets/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_view_by_id`]\n\n[`ClientVpcsExt::vpc_view_by_id`]: super::ClientVpcsExt::vpc_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct VpcViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> VpcViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/by-id/vpcs/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/by-id/vpcs/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::device_auth_request`]\n\n[`ClientHiddenExt::device_auth_request`]: super::ClientHiddenExt::device_auth_request"]
    #[derive(Debug, Clone)]
    pub struct DeviceAuthRequest<'a> {
        client: &'a super::Client,
        body: Result<types::DeviceAuthRequest, String>,
    }

    impl<'a> DeviceAuthRequest<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAuthRequest>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DeviceAuthRequest` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/device/auth`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/auth", client.baseurl,);
            let request = client.client.post(url).form_urlencoded(&body)?.build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::device_auth_confirm`]\n\n[`ClientHiddenExt::device_auth_confirm`]: super::ClientHiddenExt::device_auth_confirm"]
    #[derive(Debug, Clone)]
    pub struct DeviceAuthConfirm<'a> {
        client: &'a super::Client,
        body: Result<types::DeviceAuthVerify, String>,
    }

    impl<'a> DeviceAuthConfirm<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAuthVerify>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DeviceAuthVerify` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/device/confirm`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/confirm", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::device_access_token`]\n\n[`ClientHiddenExt::device_access_token`]: super::ClientHiddenExt::device_access_token"]
    #[derive(Debug, Clone)]
    pub struct DeviceAccessToken<'a> {
        client: &'a super::Client,
        body: Result<types::DeviceAccessTokenRequest, String>,
    }

    impl<'a> DeviceAccessToken<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DeviceAccessTokenRequest>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `DeviceAccessTokenRequest` for body failed".to_string()
            });
            self
        }

        #[doc = "Sends a `POST` request to `/device/token`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<ByteStream>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/device/token", client.baseurl,);
            let request = client.client.post(url).form_urlencoded(&body)?.build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                _ => Err(Error::ErrorResponse(ResponseValue::stream(response))),
            }
        }
    }

    #[doc = "Builder for [`ClientSilosExt::group_list`]\n\n[`ClientSilosExt::group_list`]: super::ClientSilosExt::group_list"]
    #[derive(Debug, Clone)]
    pub struct GroupList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> GroupList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/groups`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/groups", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/groups`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::login_spoof`]\n\n[`ClientHiddenExt::login_spoof`]: super::ClientHiddenExt::login_spoof"]
    #[derive(Debug, Clone)]
    pub struct LoginSpoof<'a> {
        client: &'a super::Client,
        body: Result<types::SpoofLoginBody, String>,
    }

    impl<'a> LoginSpoof<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SpoofLoginBody>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SpoofLoginBody` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/login`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/login", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientLoginExt::login_local`]\n\n[`ClientLoginExt::login_local`]: super::ClientLoginExt::login_local"]
    #[derive(Debug, Clone)]
    pub struct LoginLocal<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::UsernamePasswordCredentials, String>,
    }

    impl<'a> LoginLocal<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UsernamePasswordCredentials>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `UsernamePasswordCredentials` for body failed".to_string()
            });
            self
        }

        #[doc = "Sends a `POST` request to `/login/{silo_name}/local`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/local",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientLoginExt::login_saml_begin`]\n\n[`ClientLoginExt::login_saml_begin`]: super::ClientLoginExt::login_saml_begin"]
    #[derive(Debug, Clone)]
    pub struct LoginSamlBegin<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
    }

    impl<'a> LoginSamlBegin<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/login/{silo_name}/saml/{provider_name}`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientLoginExt::login_saml`]\n\n[`ClientLoginExt::login_saml`]: super::ClientLoginExt::login_saml"]
    #[derive(Debug)]
    pub struct LoginSaml<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
        body: Result<reqwest::Body, String>,
    }

    impl<'a> LoginSaml<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        pub fn body<B>(mut self, value: B) -> Self
        where
            B: std::convert::TryInto<reqwest::Body>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `reqwest::Body` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/login/{silo_name}/saml/{provider_name}`"]
        pub async fn send(self) -> Result<ResponseValue<ByteStream>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/login/{}/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            let request = client
                .client
                .post(url)
                .header(
                    reqwest::header::CONTENT_TYPE,
                    reqwest::header::HeaderValue::from_static("application/octet-stream"),
                )
                .body(body)
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200..=299 => Ok(ResponseValue::stream(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::logout`]\n\n[`ClientHiddenExt::logout`]: super::ClientHiddenExt::logout"]
    #[derive(Debug, Clone)]
    pub struct Logout<'a> {
        client: &'a super::Client,
    }

    impl<'a> Logout<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `POST` request to `/logout`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/logout", client.baseurl,);
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_list`]\n\n[`ClientOrganizationsExt::organization_list`]: super::ClientOrganizationsExt::organization_list"]
    #[derive(Debug, Clone)]
    pub struct OrganizationList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> OrganizationList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/organizations", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_create`]\n\n[`ClientOrganizationsExt::organization_create`]: super::ClientOrganizationsExt::organization_create"]
    #[derive(Debug, Clone)]
    pub struct OrganizationCreate<'a> {
        client: &'a super::Client,
        body: Result<types::OrganizationCreate, String>,
    }

    impl<'a> OrganizationCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `OrganizationCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/organizations", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_view`]\n\n[`ClientOrganizationsExt::organization_view`]: super::ClientOrganizationsExt::organization_view"]
    #[derive(Debug, Clone)]
    pub struct OrganizationView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
    }

    impl<'a> OrganizationView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_update`]\n\n[`ClientOrganizationsExt::organization_update`]: super::ClientOrganizationsExt::organization_update"]
    #[derive(Debug, Clone)]
    pub struct OrganizationUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        body: Result<types::OrganizationUpdate, String>,
    }

    impl<'a> OrganizationUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `OrganizationUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_delete`]\n\n[`ClientOrganizationsExt::organization_delete`]: super::ClientOrganizationsExt::organization_delete"]
    #[derive(Debug, Clone)]
    pub struct OrganizationDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
    }

    impl<'a> OrganizationDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_policy_view`]\n\n[`ClientOrganizationsExt::organization_policy_view`]: super::ClientOrganizationsExt::organization_policy_view"]
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
    }

    impl<'a> OrganizationPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_policy_update`]\n\n[`ClientOrganizationsExt::organization_policy_update`]: super::ClientOrganizationsExt::organization_policy_update"]
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        body: Result<types::OrganizationRolePolicy, String>,
    }

    impl<'a> OrganizationPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `OrganizationRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_list`]\n\n[`ClientProjectsExt::project_list`]: super::ClientProjectsExt::project_list"]
    #[derive(Debug, Clone)]
    pub struct ProjectList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProjectList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_create`]\n\n[`ClientProjectsExt::project_create`]: super::ClientProjectsExt::project_create"]
    #[derive(Debug, Clone)]
    pub struct ProjectCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        body: Result<types::ProjectCreate, String>,
    }

    impl<'a> ProjectCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ProjectCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects",
                client.baseurl,
                encode_path(&organization_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_view`]\n\n[`ClientProjectsExt::project_view`]: super::ClientProjectsExt::project_view"]
    #[derive(Debug, Clone)]
    pub struct ProjectView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
    }

    impl<'a> ProjectView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_update`]\n\n[`ClientProjectsExt::project_update`]: super::ClientProjectsExt::project_update"]
    #[derive(Debug, Clone)]
    pub struct ProjectUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::ProjectUpdate, String>,
    }

    impl<'a> ProjectUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ProjectUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_delete`]\n\n[`ClientProjectsExt::project_delete`]: super::ClientProjectsExt::project_delete"]
    #[derive(Debug, Clone)]
    pub struct ProjectDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
    }

    impl<'a> ProjectDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_list`]\n\n[`ClientDisksExt::disk_list`]: super::ClientDisksExt::disk_list"]
    #[derive(Debug, Clone)]
    pub struct DiskList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> DiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_create`]\n\n[`ClientDisksExt::disk_create`]: super::ClientDisksExt::disk_create"]
    #[derive(Debug, Clone)]
    pub struct DiskCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::DiskCreate, String>,
    }

    impl<'a> DiskCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DiskCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/disks`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_view`]\n\n[`ClientDisksExt::disk_view`]: super::ClientDisksExt::disk_view"]
    #[derive(Debug, Clone)]
    pub struct DiskView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        disk_name: Result<types::Name, String>,
    }

    impl<'a> DiskView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                disk_name: Err("disk_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn disk_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.disk_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for disk_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let disk_name = disk_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_delete`]\n\n[`ClientDisksExt::disk_delete`]: super::ClientDisksExt::disk_delete"]
    #[derive(Debug, Clone)]
    pub struct DiskDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        disk_name: Result<types::Name, String>,
    }

    impl<'a> DiskDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                disk_name: Err("disk_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn disk_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.disk_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for disk_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let disk_name = disk_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_metrics_list`]\n\n[`ClientDisksExt::disk_metrics_list`]: super::ClientDisksExt::disk_metrics_list"]
    #[derive(Debug, Clone)]
    pub struct DiskMetricsList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        disk_name: Result<types::Name, String>,
        metric_name: Result<types::DiskMetricName, String>,
        end_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        start_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
    }

    impl<'a> DiskMetricsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                disk_name: Err("disk_name was not initialized".to_string()),
                metric_name: Err("metric_name was not initialized".to_string()),
                end_time: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn disk_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.disk_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for disk_name failed".to_string());
            self
        }

        pub fn metric_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskMetricName>,
        {
            self.metric_name = value
                .try_into()
                .map_err(|_| "conversion to `DiskMetricName` for metric_name failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self . end_time = value . try_into () . map (Some) . map_err (| _ | "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for end_time failed" . to_string ()) ;
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self . start_time = value . try_into () . map (Some) . map_err (| _ | "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for start_time failed" . to_string ()) ;
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}/metrics/{metric_name}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                disk_name,
                metric_name,
                end_time,
                limit,
                page_token,
                start_time,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let disk_name = disk_name.map_err(Error::InvalidRequest)?;
            let metric_name = metric_name.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/disks/{}/metrics/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&disk_name.to_string()),
                encode_path(&metric_name.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &end_time {
                query.push(("end_time", v.to_string()));
            }
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &start_time {
                query.push(("start_time", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/disks/{disk_name}/metrics/{metric_name}`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                end_time: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                start_time: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_list`]\n\n[`ClientImagesExt::image_list`]: super::ClientImagesExt::image_list"]
    #[derive(Debug, Clone)]
    pub struct ImageList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> ImageList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/images`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/images`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Image, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_create`]\n\n[`ClientImagesExt::image_create`]: super::ClientImagesExt::image_create"]
    #[derive(Debug, Clone)]
    pub struct ImageCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::ImageCreate, String>,
    }

    impl<'a> ImageCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImageCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ImageCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/images`"]
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_view`]\n\n[`ClientImagesExt::image_view`]: super::ClientImagesExt::image_view"]
    #[derive(Debug, Clone)]
    pub struct ImageView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        image_name: Result<types::Name, String>,
    }

    impl<'a> ImageView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/images/{image_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                image_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&image_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_delete`]\n\n[`ClientImagesExt::image_delete`]: super::ClientImagesExt::image_delete"]
    #[derive(Debug, Clone)]
    pub struct ImageDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        image_name: Result<types::Name, String>,
    }

    impl<'a> ImageDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/images/{image_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                image_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/images/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&image_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_list`]\n\n[`ClientInstancesExt::instance_list`]: super::ClientInstancesExt::instance_list"]
    #[derive(Debug, Clone)]
    pub struct InstanceList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> InstanceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/instances`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_create`]\n\n[`ClientInstancesExt::instance_create`]: super::ClientInstancesExt::instance_create"]
    #[derive(Debug, Clone)]
    pub struct InstanceCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::InstanceCreate, String>,
    }

    impl<'a> InstanceCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `InstanceCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_view`]\n\n[`ClientInstancesExt::instance_view`]: super::ClientInstancesExt::instance_view"]
    #[derive(Debug, Clone)]
    pub struct InstanceView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_delete`]\n\n[`ClientInstancesExt::instance_delete`]: super::ClientInstancesExt::instance_delete"]
    #[derive(Debug, Clone)]
    pub struct InstanceDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_disk_list`]\n\n[`ClientInstancesExt::instance_disk_list`]: super::ClientInstancesExt::instance_disk_list"]
    #[derive(Debug, Clone)]
    pub struct InstanceDiskList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> InstanceDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_disk_attach`]\n\n[`ClientInstancesExt::instance_disk_attach`]: super::ClientInstancesExt::instance_disk_attach"]
    #[derive(Debug, Clone)]
    pub struct InstanceDiskAttach<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::DiskIdentifier, String>,
    }

    impl<'a> InstanceDiskAttach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskIdentifier>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DiskIdentifier` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/attach`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks/attach",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_disk_detach`]\n\n[`ClientInstancesExt::instance_disk_detach`]: super::ClientInstancesExt::instance_disk_detach"]
    #[derive(Debug, Clone)]
    pub struct InstanceDiskDetach<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::DiskIdentifier, String>,
    }

    impl<'a> InstanceDiskDetach<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskIdentifier>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DiskIdentifier` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/disks/detach`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/disks/detach",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_external_ip_list`]\n\n[`ClientInstancesExt::instance_external_ip_list`]: super::ClientInstancesExt::instance_external_ip_list"]
    #[derive(Debug, Clone)]
    pub struct InstanceExternalIpList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceExternalIpList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/external-ips`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExternalIpResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/external-ips",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_migrate`]\n\n[`ClientInstancesExt::instance_migrate`]: super::ClientInstancesExt::instance_migrate"]
    #[derive(Debug, Clone)]
    pub struct InstanceMigrate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::InstanceMigrate, String>,
    }

    impl<'a> InstanceMigrate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceMigrate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `InstanceMigrate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/migrate`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/migrate",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_list`]\n\n[`ClientInstancesExt::instance_network_interface_list`]: super::ClientInstancesExt::instance_network_interface_list"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> InstanceNetworkInterfaceList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_create`]\n\n[`ClientInstancesExt::instance_network_interface_create`]: super::ClientInstancesExt::instance_network_interface_create"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        body: Result<types::NetworkInterfaceCreate, String>,
    }

    impl<'a> InstanceNetworkInterfaceCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkInterfaceCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `NetworkInterfaceCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_view`]\n\n[`ClientInstancesExt::instance_network_interface_view`]: super::ClientInstancesExt::instance_network_interface_view"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        interface_name: Result<types::Name, String>,
    }

    impl<'a> InstanceNetworkInterfaceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                interface_name: Err("interface_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn interface_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.interface_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for interface_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let interface_name = interface_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_update`]\n\n[`ClientInstancesExt::instance_network_interface_update`]: super::ClientInstancesExt::instance_network_interface_update"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        interface_name: Result<types::Name, String>,
        body: Result<types::NetworkInterfaceUpdate, String>,
    }

    impl<'a> InstanceNetworkInterfaceUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                interface_name: Err("interface_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn interface_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.interface_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for interface_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkInterfaceUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `NetworkInterfaceUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let interface_name = interface_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_delete`]\n\n[`ClientInstancesExt::instance_network_interface_delete`]: super::ClientInstancesExt::instance_network_interface_delete"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        interface_name: Result<types::Name, String>,
    }

    impl<'a> InstanceNetworkInterfaceDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                interface_name: Err("interface_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn interface_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.interface_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for interface_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/network-interfaces/{interface_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                interface_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let interface_name = interface_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/network-interfaces/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
                encode_path(&interface_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_reboot`]\n\n[`ClientInstancesExt::instance_reboot`]: super::ClientInstancesExt::instance_reboot"]
    #[derive(Debug, Clone)]
    pub struct InstanceReboot<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceReboot<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/reboot`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/reboot",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_serial_console`]\n\n[`ClientInstancesExt::instance_serial_console`]: super::ClientInstancesExt::instance_serial_console"]
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsole<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
        from_start: Result<Option<u64>, String>,
        max_bytes: Result<Option<u64>, String>,
        most_recent: Result<Option<u64>, String>,
    }

    impl<'a> InstanceSerialConsole<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
                from_start: Ok(None),
                max_bytes: Ok(None),
                most_recent: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        pub fn from_start<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.from_start = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for from_start failed".to_string());
            self
        }

        pub fn max_bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.max_bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for max_bytes failed".to_string());
            self
        }

        pub fn most_recent<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.most_recent = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for most_recent failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/serial-console`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceSerialConsoleData>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
                from_start,
                max_bytes,
                most_recent,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let from_start = from_start.map_err(Error::InvalidRequest)?;
            let max_bytes = max_bytes.map_err(Error::InvalidRequest)?;
            let most_recent = most_recent.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/serial-console",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &from_start {
                query.push(("from_start", v.to_string()));
            }
            if let Some(v) = &max_bytes {
                query.push(("max_bytes", v.to_string()));
            }
            if let Some(v) = &most_recent {
                query.push(("most_recent", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_serial_console_stream`]\n\n[`ClientInstancesExt::instance_serial_console_stream`]: super::ClientInstancesExt::instance_serial_console_stream"]
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleStream<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceSerialConsoleStream<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/serial-console/stream`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<reqwest::Upgraded>, Error<reqwest::Upgraded>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/serial-console/stream",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client
                .client
                .get(url)
                .header(reqwest::header::CONNECTION, "Upgrade")
                .header(reqwest::header::UPGRADE, "websocket")
                .header(reqwest::header::SEC_WEBSOCKET_VERSION, "13")
                .header(
                    reqwest::header::SEC_WEBSOCKET_KEY,
                    base64::Engine::encode(
                        &base64::engine::general_purpose::STANDARD,
                        rand::random::<[u8; 16]>(),
                    ),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                101u16 => ResponseValue::upgrade(response).await,
                200..=299 => ResponseValue::upgrade(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_start`]\n\n[`ClientInstancesExt::instance_start`]: super::ClientInstancesExt::instance_start"]
    #[derive(Debug, Clone)]
    pub struct InstanceStart<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/start`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/start",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_stop`]\n\n[`ClientInstancesExt::instance_stop`]: super::ClientInstancesExt::instance_stop"]
    #[derive(Debug, Clone)]
    pub struct InstanceStop<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        instance_name: Result<types::Name, String>,
    }

    impl<'a> InstanceStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                instance_name: Err("instance_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn instance_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.instance_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for instance_name failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/instances/{instance_name}/stop`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                instance_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let instance_name = instance_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/instances/{}/stop",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&instance_name.to_string()),
            );
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_policy_view`]\n\n[`ClientProjectsExt::project_policy_view`]: super::ClientProjectsExt::project_policy_view"]
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
    }

    impl<'a> ProjectPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_policy_update`]\n\n[`ClientProjectsExt::project_policy_update`]: super::ClientProjectsExt::project_policy_update"]
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::ProjectRolePolicy, String>,
    }

    impl<'a> ProjectPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ProjectRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/policy",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_list`]\n\n[`ClientSnapshotsExt::snapshot_list`]: super::ClientSnapshotsExt::snapshot_list"]
    #[derive(Debug, Clone)]
    pub struct SnapshotList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SnapshotList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/snapshots`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/snapshots`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_create`]\n\n[`ClientSnapshotsExt::snapshot_create`]: super::ClientSnapshotsExt::snapshot_create"]
    #[derive(Debug, Clone)]
    pub struct SnapshotCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::SnapshotCreate, String>,
    }

    impl<'a> SnapshotCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SnapshotCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/snapshots`"]
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_view`]\n\n[`ClientSnapshotsExt::snapshot_view`]: super::ClientSnapshotsExt::snapshot_view"]
    #[derive(Debug, Clone)]
    pub struct SnapshotView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        snapshot_name: Result<types::Name, String>,
    }

    impl<'a> SnapshotView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                snapshot_name: Err("snapshot_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn snapshot_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.snapshot_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for snapshot_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/snapshots/{snapshot_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                snapshot_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let snapshot_name = snapshot_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&snapshot_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_delete`]\n\n[`ClientSnapshotsExt::snapshot_delete`]: super::ClientSnapshotsExt::snapshot_delete"]
    #[derive(Debug, Clone)]
    pub struct SnapshotDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        snapshot_name: Result<types::Name, String>,
    }

    impl<'a> SnapshotDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                snapshot_name: Err("snapshot_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn snapshot_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.snapshot_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for snapshot_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/snapshots/{snapshot_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                snapshot_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let snapshot_name = snapshot_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/snapshots/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&snapshot_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_list`]\n\n[`ClientVpcsExt::vpc_list`]: super::ClientVpcsExt::vpc_list"]
    #[derive(Debug, Clone)]
    pub struct VpcList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_create`]\n\n[`ClientVpcsExt::vpc_create`]: super::ClientVpcsExt::vpc_create"]
    #[derive(Debug, Clone)]
    pub struct VpcCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        body: Result<types::VpcCreate, String>,
    }

    impl<'a> VpcCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_view`]\n\n[`ClientVpcsExt::vpc_view`]: super::ClientVpcsExt::vpc_view"]
    #[derive(Debug, Clone)]
    pub struct VpcView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
    }

    impl<'a> VpcView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_update`]\n\n[`ClientVpcsExt::vpc_update`]: super::ClientVpcsExt::vpc_update"]
    #[derive(Debug, Clone)]
    pub struct VpcUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::VpcUpdate, String>,
    }

    impl<'a> VpcUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_delete`]\n\n[`ClientVpcsExt::vpc_delete`]: super::ClientVpcsExt::vpc_delete"]
    #[derive(Debug, Clone)]
    pub struct VpcDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
    }

    impl<'a> VpcDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_firewall_rules_view`]\n\n[`ClientVpcsExt::vpc_firewall_rules_view`]: super::ClientVpcsExt::vpc_firewall_rules_view"]
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
    }

    impl<'a> VpcFirewallRulesView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_firewall_rules_update`]\n\n[`ClientVpcsExt::vpc_firewall_rules_update`]: super::ClientVpcsExt::vpc_firewall_rules_update"]
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::VpcFirewallRuleUpdateParams, String>,
    }

    impl<'a> VpcFirewallRulesUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcFirewallRuleUpdateParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `VpcFirewallRuleUpdateParams` for body failed".to_string()
            });
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/firewall/rules`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/firewall/rules",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_list`]\n\n[`ClientVpcsExt::vpc_router_list`]: super::ClientVpcsExt::vpc_router_list"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcRouterList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_create`]\n\n[`ClientVpcsExt::vpc_router_create`]: super::ClientVpcsExt::vpc_router_create"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::VpcRouterCreate, String>,
    }

    impl<'a> VpcRouterCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcRouterCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_view`]\n\n[`ClientVpcsExt::vpc_router_view`]: super::ClientVpcsExt::vpc_router_view"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_update`]\n\n[`ClientVpcsExt::vpc_router_update`]: super::ClientVpcsExt::vpc_router_update"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        body: Result<types::VpcRouterUpdate, String>,
    }

    impl<'a> VpcRouterUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcRouterUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_delete`]\n\n[`ClientVpcsExt::vpc_router_delete`]: super::ClientVpcsExt::vpc_router_delete"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_list`]\n\n[`ClientVpcsExt::vpc_router_route_list`]: super::ClientVpcsExt::vpc_router_route_list"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcRouterRouteList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_create`]\n\n[`ClientVpcsExt::vpc_router_route_create`]: super::ClientVpcsExt::vpc_router_route_create"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        body: Result<types::RouterRouteCreate, String>,
    }

    impl<'a> VpcRouterRouteCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `RouterRouteCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_view`]\n\n[`ClientVpcsExt::vpc_router_route_view`]: super::ClientVpcsExt::vpc_router_route_view"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        route_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterRouteView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                route_name: Err("route_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn route_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.route_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for route_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let route_name = route_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_update`]\n\n[`ClientVpcsExt::vpc_router_route_update`]: super::ClientVpcsExt::vpc_router_route_update"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        route_name: Result<types::Name, String>,
        body: Result<types::RouterRouteUpdate, String>,
    }

    impl<'a> VpcRouterRouteUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                route_name: Err("route_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn route_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.route_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for route_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `RouterRouteUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let route_name = route_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_delete`]\n\n[`ClientVpcsExt::vpc_router_route_delete`]: super::ClientVpcsExt::vpc_router_route_delete"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        router_name: Result<types::Name, String>,
        route_name: Result<types::Name, String>,
    }

    impl<'a> VpcRouterRouteDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                router_name: Err("router_name was not initialized".to_string()),
                route_name: Err("route_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn router_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.router_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for router_name failed".to_string());
            self
        }

        pub fn route_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.route_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for route_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/routers/{router_name}/routes/{route_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                router_name,
                route_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let router_name = router_name.map_err(Error::InvalidRequest)?;
            let route_name = route_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/routers/{}/routes/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&router_name.to_string()),
                encode_path(&route_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_list`]\n\n[`ClientVpcsExt::vpc_subnet_list`]: super::ClientVpcsExt::vpc_subnet_list"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetList<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> VpcSubnetList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_create`]\n\n[`ClientVpcsExt::vpc_subnet_create`]: super::ClientVpcsExt::vpc_subnet_create"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetCreate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        body: Result<types::VpcSubnetCreate, String>,
    }

    impl<'a> VpcSubnetCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcSubnetCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_view`]\n\n[`ClientVpcsExt::vpc_subnet_view`]: super::ClientVpcsExt::vpc_subnet_view"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetView<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
    }

    impl<'a> VpcSubnetView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_update`]\n\n[`ClientVpcsExt::vpc_subnet_update`]: super::ClientVpcsExt::vpc_subnet_update"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetUpdate<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
        body: Result<types::VpcSubnetUpdate, String>,
    }

    impl<'a> VpcSubnetUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcSubnetUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
                body,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_delete`]\n\n[`ClientVpcsExt::vpc_subnet_delete`]: super::ClientVpcsExt::vpc_subnet_delete"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetDelete<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
    }

    impl<'a> VpcSubnetDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_list_network_interfaces`]\n\n[`ClientVpcsExt::vpc_subnet_list_network_interfaces`]: super::ClientVpcsExt::vpc_subnet_list_network_interfaces"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetListNetworkInterfaces<'a> {
        client: &'a super::Client,
        organization_name: Result<types::Name, String>,
        project_name: Result<types::Name, String>,
        vpc_name: Result<types::Name, String>,
        subnet_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> VpcSubnetListNetworkInterfaces<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization_name: Err("organization_name was not initialized".to_string()),
                project_name: Err("project_name was not initialized".to_string()),
                vpc_name: Err("vpc_name was not initialized".to_string()),
                subnet_name: Err("subnet_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn organization_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.organization_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for organization_name failed".to_string());
            self
        }

        pub fn project_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.project_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for project_name failed".to_string());
            self
        }

        pub fn vpc_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.vpc_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for vpc_name failed".to_string());
            self
        }

        pub fn subnet_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.subnet_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for subnet_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}/network-interfaces`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                organization_name,
                project_name,
                vpc_name,
                subnet_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let organization_name = organization_name.map_err(Error::InvalidRequest)?;
            let project_name = project_name.map_err(Error::InvalidRequest)?;
            let vpc_name = vpc_name.map_err(Error::InvalidRequest)?;
            let subnet_name = subnet_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/organizations/{}/projects/{}/vpcs/{}/subnets/{}/network-interfaces",
                client.baseurl,
                encode_path(&organization_name.to_string()),
                encode_path(&project_name.to_string()),
                encode_path(&vpc_name.to_string()),
                encode_path(&subnet_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/organizations/{organization_name}/projects/{project_name}/vpcs/{vpc_name}/subnets/{subnet_name}/network-interfaces`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSilosExt::policy_view`]\n\n[`ClientSilosExt::policy_view`]: super::ClientSilosExt::policy_view"]
    #[derive(Debug, Clone)]
    pub struct PolicyView<'a> {
        client: &'a super::Client,
    }

    impl<'a> PolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/policy", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSilosExt::policy_update`]\n\n[`ClientSilosExt::policy_update`]: super::ClientSilosExt::policy_update"]
    #[derive(Debug, Clone)]
    pub struct PolicyUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::SiloRolePolicy, String>,
    }

    impl<'a> PolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SiloRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/policy", client.baseurl,);
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientRolesExt::role_list`]\n\n[`ClientRolesExt::role_list`]: super::ClientRolesExt::role_list"]
    #[derive(Debug, Clone)]
    pub struct RoleList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> RoleList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/roles`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RoleResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/roles", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/roles`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Role, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientRolesExt::role_view`]\n\n[`ClientRolesExt::role_view`]: super::ClientRolesExt::role_view"]
    #[derive(Debug, Clone)]
    pub struct RoleView<'a> {
        client: &'a super::Client,
        role_name: Result<String, String>,
    }

    impl<'a> RoleView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                role_name: Err("role_name was not initialized".to_string()),
            }
        }

        pub fn role_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.role_name = value
                .try_into()
                .map_err(|_| "conversion to `String` for role_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/roles/{role_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Role>, Error<types::Error>> {
            let Self { client, role_name } = self;
            let role_name = role_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/roles/{}",
                client.baseurl,
                encode_path(&role_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::session_me`]\n\n[`ClientHiddenExt::session_me`]: super::ClientHiddenExt::session_me"]
    #[derive(Debug, Clone)]
    pub struct SessionMe<'a> {
        client: &'a super::Client,
    }

    impl<'a> SessionMe<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/session/me`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/session/me", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientHiddenExt::session_me_groups`]\n\n[`ClientHiddenExt::session_me_groups`]: super::ClientHiddenExt::session_me_groups"]
    #[derive(Debug, Clone)]
    pub struct SessionMeGroups<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SessionMeGroups<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/session/me/groups`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/session/me/groups", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/session/me/groups`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSessionExt::session_sshkey_list`]\n\n[`ClientSessionExt::session_sshkey_list`]: super::ClientSessionExt::session_sshkey_list"]
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SessionSshkeyList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/session/me/sshkeys`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/session/me/sshkeys", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/session/me/sshkeys`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSessionExt::session_sshkey_create`]\n\n[`ClientSessionExt::session_sshkey_create`]: super::ClientSessionExt::session_sshkey_create"]
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyCreate<'a> {
        client: &'a super::Client,
        body: Result<types::SshKeyCreate, String>,
    }

    impl<'a> SessionSshkeyCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SshKeyCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SshKeyCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/session/me/sshkeys`"]
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/session/me/sshkeys", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSessionExt::session_sshkey_view`]\n\n[`ClientSessionExt::session_sshkey_view`]: super::ClientSessionExt::session_sshkey_view"]
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyView<'a> {
        client: &'a super::Client,
        ssh_key_name: Result<types::Name, String>,
    }

    impl<'a> SessionSshkeyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ssh_key_name: Err("ssh_key_name was not initialized".to_string()),
            }
        }

        pub fn ssh_key_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.ssh_key_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for ssh_key_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/session/me/sshkeys/{ssh_key_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self {
                client,
                ssh_key_name,
            } = self;
            let ssh_key_name = ssh_key_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/session/me/sshkeys/{}",
                client.baseurl,
                encode_path(&ssh_key_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSessionExt::session_sshkey_delete`]\n\n[`ClientSessionExt::session_sshkey_delete`]: super::ClientSessionExt::session_sshkey_delete"]
    #[derive(Debug, Clone)]
    pub struct SessionSshkeyDelete<'a> {
        client: &'a super::Client,
        ssh_key_name: Result<types::Name, String>,
    }

    impl<'a> SessionSshkeyDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ssh_key_name: Err("ssh_key_name was not initialized".to_string()),
            }
        }

        pub fn ssh_key_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.ssh_key_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for ssh_key_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/session/me/sshkeys/{ssh_key_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                ssh_key_name,
            } = self;
            let ssh_key_name = ssh_key_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/session/me/sshkeys/{}",
                client.baseurl,
                encode_path(&ssh_key_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_image_view_by_id`]\n\n[`ClientSystemExt::system_image_view_by_id`]: super::ClientSystemExt::system_image_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct SystemImageViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> SystemImageViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/by-id/images/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/by-id/images/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_view_by_id`]\n\n[`ClientSystemExt::ip_pool_view_by_id`]: super::ClientSystemExt::ip_pool_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct IpPoolViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> IpPoolViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/by-id/ip-pools/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/by-id/ip-pools/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_view_by_id`]\n\n[`ClientSystemExt::silo_view_by_id`]: super::ClientSystemExt::silo_view_by_id"]
    #[derive(Debug, Clone)]
    pub struct SiloViewById<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> SiloViewById<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/by-id/silos/{id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/by-id/silos/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_list`]\n\n[`ClientSystemExt::certificate_list`]: super::ClientSystemExt::certificate_list"]
    #[derive(Debug, Clone)]
    pub struct CertificateList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> CertificateList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/certificates`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CertificateResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/certificates", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/certificates`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Certificate, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_create`]\n\n[`ClientSystemExt::certificate_create`]: super::ClientSystemExt::certificate_create"]
    #[derive(Debug, Clone)]
    pub struct CertificateCreate<'a> {
        client: &'a super::Client,
        body: Result<types::CertificateCreate, String>,
    }

    impl<'a> CertificateCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CertificateCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `CertificateCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/certificates`"]
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/certificates", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_view`]\n\n[`ClientSystemExt::certificate_view`]: super::ClientSystemExt::certificate_view"]
    #[derive(Debug, Clone)]
    pub struct CertificateView<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/certificates/{certificate}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_delete`]\n\n[`ClientSystemExt::certificate_delete`]: super::ClientSystemExt::certificate_delete"]
    #[derive(Debug, Clone)]
    pub struct CertificateDelete<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/system/certificates/{certificate}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::physical_disk_list`]\n\n[`ClientSystemExt::physical_disk_list`]: super::ClientSystemExt::physical_disk_list"]
    #[derive(Debug, Clone)]
    pub struct PhysicalDiskList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> PhysicalDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/hardware/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/hardware/disks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/hardware/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::rack_list`]\n\n[`ClientSystemExt::rack_list`]: super::ClientSystemExt::rack_list"]
    #[derive(Debug, Clone)]
    pub struct RackList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> RackList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/hardware/racks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/hardware/racks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/hardware/racks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::rack_view`]\n\n[`ClientSystemExt::rack_view`]: super::ClientSystemExt::rack_view"]
    #[derive(Debug, Clone)]
    pub struct RackView<'a> {
        client: &'a super::Client,
        rack_id: Result<uuid::Uuid, String>,
    }

    impl<'a> RackView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rack_id: Err("rack_id was not initialized".to_string()),
            }
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/hardware/racks/{rack_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Rack>, Error<types::Error>> {
            let Self { client, rack_id } = self;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/hardware/racks/{}",
                client.baseurl,
                encode_path(&rack_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::sled_list`]\n\n[`ClientSystemExt::sled_list`]: super::ClientSystemExt::sled_list"]
    #[derive(Debug, Clone)]
    pub struct SledList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/hardware/sleds`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/hardware/sleds", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/hardware/sleds`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::sled_view`]\n\n[`ClientSystemExt::sled_view`]: super::ClientSystemExt::sled_view"]
    #[derive(Debug, Clone)]
    pub struct SledView<'a> {
        client: &'a super::Client,
        sled_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SledView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                sled_id: Err("sled_id was not initialized".to_string()),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/hardware/sleds/{sled_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Sled>, Error<types::Error>> {
            let Self { client, sled_id } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/hardware/sleds/{}",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::sled_physical_disk_list`]\n\n[`ClientSystemExt::sled_physical_disk_list`]: super::ClientSystemExt::sled_physical_disk_list"]
    #[derive(Debug, Clone)]
    pub struct SledPhysicalDiskList<'a> {
        client: &'a super::Client,
        sled_id: Result<uuid::Uuid, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledPhysicalDiskList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                sled_id: Err("sled_id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/hardware/sleds/{sled_id}/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                sled_id,
                limit,
                page_token,
                sort_by,
            } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/hardware/sleds/{}/disks",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/hardware/sleds/{sled_id}/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_image_list`]\n\n[`ClientSystemExt::system_image_list`]: super::ClientSystemExt::system_image_list"]
    #[derive(Debug, Clone)]
    pub struct SystemImageList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SystemImageList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/images`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GlobalImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/images", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/images`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::GlobalImage, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_image_create`]\n\n[`ClientSystemExt::system_image_create`]: super::ClientSystemExt::system_image_create"]
    #[derive(Debug, Clone)]
    pub struct SystemImageCreate<'a> {
        client: &'a super::Client,
        body: Result<types::GlobalImageCreate, String>,
    }

    impl<'a> SystemImageCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::GlobalImageCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `GlobalImageCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/images`"]
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/images", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_image_view`]\n\n[`ClientSystemExt::system_image_view`]: super::ClientSystemExt::system_image_view"]
    #[derive(Debug, Clone)]
    pub struct SystemImageView<'a> {
        client: &'a super::Client,
        image_name: Result<types::Name, String>,
    }

    impl<'a> SystemImageView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/images/{image_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::GlobalImage>, Error<types::Error>> {
            let Self { client, image_name } = self;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/images/{}",
                client.baseurl,
                encode_path(&image_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_image_delete`]\n\n[`ClientSystemExt::system_image_delete`]: super::ClientSystemExt::system_image_delete"]
    #[derive(Debug, Clone)]
    pub struct SystemImageDelete<'a> {
        client: &'a super::Client,
        image_name: Result<types::Name, String>,
    }

    impl<'a> SystemImageDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                image_name: Err("image_name was not initialized".to_string()),
            }
        }

        pub fn image_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.image_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for image_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/system/images/{image_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, image_name } = self;
            let image_name = image_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/images/{}",
                client.baseurl,
                encode_path(&image_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_list`]\n\n[`ClientSystemExt::ip_pool_list`]: super::ClientSystemExt::ip_pool_list"]
    #[derive(Debug, Clone)]
    pub struct IpPoolList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> IpPoolList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/ip-pools`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/ip-pools`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPool, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_create`]\n\n[`ClientSystemExt::ip_pool_create`]: super::ClientSystemExt::ip_pool_create"]
    #[derive(Debug, Clone)]
    pub struct IpPoolCreate<'a> {
        client: &'a super::Client,
        body: Result<types::IpPoolCreate, String>,
    }

    impl<'a> IpPoolCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpPoolCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/ip-pools`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_view`]\n\n[`ClientSystemExt::ip_pool_view`]: super::ClientSystemExt::ip_pool_view"]
    #[derive(Debug, Clone)]
    pub struct IpPoolView<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
    }

    impl<'a> IpPoolView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool_name: Err("pool_name was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/ip-pools/{pool_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, pool_name } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_update`]\n\n[`ClientSystemExt::ip_pool_update`]: super::ClientSystemExt::ip_pool_update"]
    #[derive(Debug, Clone)]
    pub struct IpPoolUpdate<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        body: Result<types::IpPoolUpdate, String>,
    }

    impl<'a> IpPoolUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool_name: Err("pool_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpPoolUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/system/ip-pools/{pool_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                body,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_delete`]\n\n[`ClientSystemExt::ip_pool_delete`]: super::ClientSystemExt::ip_pool_delete"]
    #[derive(Debug, Clone)]
    pub struct IpPoolDelete<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
    }

    impl<'a> IpPoolDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool_name: Err("pool_name was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/system/ip-pools/{pool_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool_name } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_range_list`]\n\n[`ClientSystemExt::ip_pool_range_list`]: super::ClientSystemExt::ip_pool_range_list"]
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeList<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> IpPoolRangeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool_name: Err("pool_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/ip-pools/{pool_name}/ranges`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                limit,
                page_token,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}/ranges",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/ip-pools/{pool_name}/ranges`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_range_add`]\n\n[`ClientSystemExt::ip_pool_range_add`]: super::ClientSystemExt::ip_pool_range_add"]
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeAdd<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool_name: Err("pool_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/ip-pools/{pool_name}/ranges/add`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                body,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}/ranges/add",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_range_remove`]\n\n[`ClientSystemExt::ip_pool_range_remove`]: super::ClientSystemExt::ip_pool_range_remove"]
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeRemove<'a> {
        client: &'a super::Client,
        pool_name: Result<types::Name, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool_name: Err("pool_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.pool_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for pool_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/ip-pools/{pool_name}/ranges/remove`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                pool_name,
                body,
            } = self;
            let pool_name = pool_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/ip-pools/{}/ranges/remove",
                client.baseurl,
                encode_path(&pool_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_view`]\n\n[`ClientSystemExt::ip_pool_service_view`]: super::ClientSystemExt::ip_pool_service_view"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceView<'a> {
        client: &'a super::Client,
    }

    impl<'a> IpPoolServiceView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/system/ip-pools-service`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/system/ip-pools-service", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_range_list`]\n\n[`ClientSystemExt::ip_pool_service_range_list`]: super::ClientSystemExt::ip_pool_service_range_list"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> IpPoolServiceRangeList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/ip-pools-service/ranges`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools-service/ranges", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/ip-pools-service/ranges`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_range_add`]\n\n[`ClientSystemExt::ip_pool_service_range_add`]: super::ClientSystemExt::ip_pool_service_range_add"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeAdd<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeAdd<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/ip-pools-service/ranges/add`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools-service/ranges/add", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_range_remove`]\n\n[`ClientSystemExt::ip_pool_service_range_remove`]: super::ClientSystemExt::ip_pool_service_range_remove"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeRemove<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeRemove<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/ip-pools-service/ranges/remove`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/ip-pools-service/ranges/remove", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_metric`]\n\n[`ClientSystemExt::system_metric`]: super::ClientSystemExt::system_metric"]
    #[derive(Debug, Clone)]
    pub struct SystemMetric<'a> {
        client: &'a super::Client,
        metric_name: Result<types::SystemMetricName, String>,
        end_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        id: Result<uuid::Uuid, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        start_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
    }

    impl<'a> SystemMetric<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                metric_name: Err("metric_name was not initialized".to_string()),
                end_time: Ok(None),
                id: Err("id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn metric_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemMetricName>,
        {
            self.metric_name = value
                .try_into()
                .map_err(|_| "conversion to `SystemMetricName` for metric_name failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self . end_time = value . try_into () . map (Some) . map_err (| _ | "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for end_time failed" . to_string ()) ;
            self
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self . start_time = value . try_into () . map (Some) . map_err (| _ | "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for start_time failed" . to_string ()) ;
            self
        }

        #[doc = "Sends a `GET` request to `/system/metrics/{metric_name}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                metric_name,
                end_time,
                id,
                limit,
                page_token,
                start_time,
            } = self;
            let metric_name = metric_name.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let id = id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/metrics/{}",
                client.baseurl,
                encode_path(&metric_name.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &end_time {
                query.push(("end_time", v.to_string()));
            }
            query.push(("id", id.to_string()));
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &start_time {
                query.push(("start_time", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientPolicyExt::system_policy_view`]\n\n[`ClientPolicyExt::system_policy_view`]: super::ClientPolicyExt::system_policy_view"]
    #[derive(Debug, Clone)]
    pub struct SystemPolicyView<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/system/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/system/policy", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientPolicyExt::system_policy_update`]\n\n[`ClientPolicyExt::system_policy_update`]: super::ClientPolicyExt::system_policy_update"]
    #[derive(Debug, Clone)]
    pub struct SystemPolicyUpdate<'a> {
        client: &'a super::Client,
        body: Result<types::FleetRolePolicy, String>,
    }

    impl<'a> SystemPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FleetRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `FleetRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/system/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/policy", client.baseurl,);
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saga_list`]\n\n[`ClientSystemExt::saga_list`]: super::ClientSystemExt::saga_list"]
    #[derive(Debug, Clone)]
    pub struct SagaList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SagaList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/sagas`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/sagas", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/sagas`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saga_view`]\n\n[`ClientSystemExt::saga_view`]: super::ClientSystemExt::saga_view"]
    #[derive(Debug, Clone)]
    pub struct SagaView<'a> {
        client: &'a super::Client,
        saga_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SagaView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                saga_id: Err("saga_id was not initialized".to_string()),
            }
        }

        pub fn saga_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.saga_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for saga_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/sagas/{saga_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Saga>, Error<types::Error>> {
            let Self { client, saga_id } = self;
            let saga_id = saga_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/sagas/{}",
                client.baseurl,
                encode_path(&saga_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_list`]\n\n[`ClientSystemExt::silo_list`]: super::ClientSystemExt::silo_list"]
    #[derive(Debug, Clone)]
    pub struct SiloList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/silos", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/silos`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_create`]\n\n[`ClientSystemExt::silo_create`]: super::ClientSystemExt::silo_create"]
    #[derive(Debug, Clone)]
    pub struct SiloCreate<'a> {
        client: &'a super::Client,
        body: Result<types::SiloCreate, String>,
    }

    impl<'a> SiloCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SiloCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/silos`"]
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/silos", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_view`]\n\n[`ClientSystemExt::silo_view`]: super::ClientSystemExt::silo_view"]
    #[derive(Debug, Clone)]
    pub struct SiloView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
    }

    impl<'a> SiloView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos/{silo_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_delete`]\n\n[`ClientSystemExt::silo_delete`]: super::ClientSystemExt::silo_delete"]
    #[derive(Debug, Clone)]
    pub struct SiloDelete<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
    }

    impl<'a> SiloDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/system/silos/{silo_name}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_identity_provider_list`]\n\n[`ClientSystemExt::silo_identity_provider_list`]: super::ClientSystemExt::silo_identity_provider_list"]
    #[derive(Debug, Clone)]
    pub struct SiloIdentityProviderList<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SiloIdentityProviderList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos/{silo_name}/identity-providers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IdentityProviderResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                silo_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/silos/{silo_name}/identity-providers`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IdentityProvider, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::local_idp_user_create`]\n\n[`ClientSystemExt::local_idp_user_create`]: super::ClientSystemExt::local_idp_user_create"]
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserCreate<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::UserCreate, String>,
    }

    impl<'a> LocalIdpUserCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UserCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/silos/{silo_name}/identity-providers/local/users`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/local/users",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::local_idp_user_delete`]\n\n[`ClientSystemExt::local_idp_user_delete`]: super::ClientSystemExt::local_idp_user_delete"]
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserDelete<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        user_id: Result<uuid::Uuid, String>,
    }

    impl<'a> LocalIdpUserDelete<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                user_id: Err("user_id was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/system/silos/{silo_name}/identity-providers/local/users/{user_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                user_id,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/local/users/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&user_id.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::local_idp_user_set_password`]\n\n[`ClientSystemExt::local_idp_user_set_password`]: super::ClientSystemExt::local_idp_user_set_password"]
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserSetPassword<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        user_id: Result<uuid::Uuid, String>,
        body: Result<types::UserPassword, String>,
    }

    impl<'a> LocalIdpUserSetPassword<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                user_id: Err("user_id was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserPassword>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UserPassword` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/system/silos/{silo_name}/identity-providers/local/users/{user_id}/set-password`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                user_id,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/local/users/{}/set-password",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&user_id.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saml_identity_provider_create`]\n\n[`ClientSystemExt::saml_identity_provider_create`]: super::ClientSystemExt::saml_identity_provider_create"]
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderCreate<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::SamlIdentityProviderCreate, String>,
    }

    impl<'a> SamlIdentityProviderCreate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SamlIdentityProviderCreate>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SamlIdentityProviderCreate` for body failed".to_string()
            });
            self
        }

        #[doc = "Sends a `POST` request to `/system/silos/{silo_name}/identity-providers/saml`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/saml",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saml_identity_provider_view`]\n\n[`ClientSystemExt::saml_identity_provider_view`]: super::ClientSystemExt::saml_identity_provider_view"]
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        provider_name: Result<types::Name, String>,
    }

    impl<'a> SamlIdentityProviderView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                provider_name: Err("provider_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn provider_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.provider_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for provider_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos/{silo_name}/identity-providers/saml/{provider_name}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                provider_name,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let provider_name = provider_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/identity-providers/saml/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&provider_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_policy_view`]\n\n[`ClientSystemExt::silo_policy_view`]: super::ClientSystemExt::silo_policy_view"]
    #[derive(Debug, Clone)]
    pub struct SiloPolicyView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
    }

    impl<'a> SiloPolicyView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos/{silo_name}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, silo_name } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_policy_update`]\n\n[`ClientSystemExt::silo_policy_update`]: super::ClientSystemExt::silo_policy_update"]
    #[derive(Debug, Clone)]
    pub struct SiloPolicyUpdate<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        body: Result<types::SiloRolePolicy, String>,
    }

    impl<'a> SiloPolicyUpdate<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SiloRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/system/silos/{silo_name}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                body,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_users_list`]\n\n[`ClientSystemExt::silo_users_list`]: super::ClientSystemExt::silo_users_list"]
    #[derive(Debug, Clone)]
    pub struct SiloUsersList<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SiloUsersList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos/{silo_name}/users/all`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                limit,
                page_token,
                sort_by,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/users/all",
                client.baseurl,
                encode_path(&silo_name.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/silos/{silo_name}/users/all`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_user_view`]\n\n[`ClientSystemExt::silo_user_view`]: super::ClientSystemExt::silo_user_view"]
    #[derive(Debug, Clone)]
    pub struct SiloUserView<'a> {
        client: &'a super::Client,
        silo_name: Result<types::Name, String>,
        user_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SiloUserView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo_name: Err("silo_name was not initialized".to_string()),
                user_id: Err("user_id was not initialized".to_string()),
            }
        }

        pub fn silo_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.silo_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for silo_name failed".to_string());
            self
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/silos/{silo_name}/users/id/{user_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self {
                client,
                silo_name,
                user_id,
            } = self;
            let silo_name = silo_name.map_err(Error::InvalidRequest)?;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/silos/{}/users/id/{}",
                client.baseurl,
                encode_path(&silo_name.to_string()),
                encode_path(&user_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_user_list`]\n\n[`ClientSystemExt::system_user_list`]: super::ClientSystemExt::system_user_list"]
    #[derive(Debug, Clone)]
    pub struct SystemUserList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameSortMode>, String>,
    }

    impl<'a> SystemUserList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/user`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserBuiltinResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/system/user", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/system/user`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UserBuiltin, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_user_view`]\n\n[`ClientSystemExt::system_user_view`]: super::ClientSystemExt::system_user_view"]
    #[derive(Debug, Clone)]
    pub struct SystemUserView<'a> {
        client: &'a super::Client,
        user_name: Result<types::Name, String>,
    }

    impl<'a> SystemUserView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                user_name: Err("user_name was not initialized".to_string()),
            }
        }

        pub fn user_name<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::Name>,
        {
            self.user_name = value
                .try_into()
                .map_err(|_| "conversion to `Name` for user_name failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/system/user/{user_name}`"]
        pub async fn send(self) -> Result<ResponseValue<types::UserBuiltin>, Error<types::Error>> {
            let Self { client, user_name } = self;
            let user_name = user_name.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/system/user/{}",
                client.baseurl,
                encode_path(&user_name.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientMetricsExt::timeseries_schema_get`]\n\n[`ClientMetricsExt::timeseries_schema_get`]: super::ClientMetricsExt::timeseries_schema_get"]
    #[derive(Debug, Clone)]
    pub struct TimeseriesSchemaGet<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> TimeseriesSchemaGet<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/timeseries/schema`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TimeseriesSchemaResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/timeseries/schema", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/timeseries/schema`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::TimeseriesSchema, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSilosExt::user_list`]\n\n[`ClientSilosExt::user_list`]: super::ClientSilosExt::user_list"]
    #[derive(Debug, Clone)]
    pub struct UserList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> UserList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/users`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/users", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/users`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_list_v1`]\n\n[`ClientDisksExt::disk_list_v1`]: super::ClientDisksExt::disk_list_v1"]
    #[derive(Debug, Clone)]
    pub struct DiskListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> DiskListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/disks", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_create_v1`]\n\n[`ClientDisksExt::disk_create_v1`]: super::ClientDisksExt::disk_create_v1"]
    #[derive(Debug, Clone)]
    pub struct DiskCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::DiskCreate, String>,
    }

    impl<'a> DiskCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DiskCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/disks`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/disks", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_view_v1`]\n\n[`ClientDisksExt::disk_view_v1`]: super::ClientDisksExt::disk_view_v1"]
    #[derive(Debug, Clone)]
    pub struct DiskViewV1<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                disk: Err("disk was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/disks/{disk}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                disk,
                organization,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_delete_v1`]\n\n[`ClientDisksExt::disk_delete_v1`]: super::ClientDisksExt::disk_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct DiskDeleteV1<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> DiskDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                disk: Err("disk was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/disks/{disk}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                disk,
                organization,
                project,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientDisksExt::disk_metrics_list_v1`]\n\n[`ClientDisksExt::disk_metrics_list_v1`]: super::ClientDisksExt::disk_metrics_list_v1"]
    #[derive(Debug, Clone)]
    pub struct DiskMetricsListV1<'a> {
        client: &'a super::Client,
        disk: Result<types::NameOrId, String>,
        metric: Result<types::DiskMetricName, String>,
        end_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        start_time: Result<Option<chrono::DateTime<chrono::offset::Utc>>, String>,
    }

    impl<'a> DiskMetricsListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                disk: Err("disk was not initialized".to_string()),
                metric: Err("metric was not initialized".to_string()),
                end_time: Ok(None),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                start_time: Ok(None),
            }
        }

        pub fn disk<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.disk = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for disk failed".to_string());
            self
        }

        pub fn metric<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskMetricName>,
        {
            self.metric = value
                .try_into()
                .map_err(|_| "conversion to `DiskMetricName` for metric failed".to_string());
            self
        }

        pub fn end_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self . end_time = value . try_into () . map (Some) . map_err (| _ | "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for end_time failed" . to_string ()) ;
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn start_time<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<chrono::DateTime<chrono::offset::Utc>>,
        {
            self . start_time = value . try_into () . map (Some) . map_err (| _ | "conversion to `chrono :: DateTime < chrono :: offset :: Utc >` for start_time failed" . to_string ()) ;
            self
        }

        #[doc = "Sends a `GET` request to `/v1/disks/{disk}/metrics/{metric}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::MeasurementResultsPage>, Error<types::Error>> {
            let Self {
                client,
                disk,
                metric,
                end_time,
                limit,
                organization,
                page_token,
                project,
                start_time,
            } = self;
            let disk = disk.map_err(Error::InvalidRequest)?;
            let metric = metric.map_err(Error::InvalidRequest)?;
            let end_time = end_time.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let start_time = start_time.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/disks/{}/metrics/{}",
                client.baseurl,
                encode_path(&disk.to_string()),
                encode_path(&metric.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &end_time {
                query.push(("end_time", v.to_string()));
            }
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &start_time {
                query.push(("start_time", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/disks/{disk}/metrics/{metric}`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Measurement, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                end_time: Ok(None),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                start_time: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSilosExt::group_list_v1`]\n\n[`ClientSilosExt::group_list_v1`]: super::ClientSilosExt::group_list_v1"]
    #[derive(Debug, Clone)]
    pub struct GroupListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> GroupListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/groups`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/groups", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/groups`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSilosExt::group_view`]\n\n[`ClientSilosExt::group_view`]: super::ClientSilosExt::group_view"]
    #[derive(Debug, Clone)]
    pub struct GroupView<'a> {
        client: &'a super::Client,
        group: Result<uuid::Uuid, String>,
    }

    impl<'a> GroupView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                group: Err("group was not initialized".to_string()),
            }
        }

        pub fn group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.group = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for group failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/groups/{group}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Group>, Error<types::Error>> {
            let Self { client, group } = self;
            let group = group.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/groups/{}",
                client.baseurl,
                encode_path(&group.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_list_v1`]\n\n[`ClientImagesExt::image_list_v1`]: super::ClientImagesExt::image_list_v1"]
    #[derive(Debug, Clone)]
    pub struct ImageListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ImageListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/images`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ImageResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/images", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/images`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Image, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_create_v1`]\n\n[`ClientImagesExt::image_create_v1`]: super::ClientImagesExt::image_create_v1"]
    #[derive(Debug, Clone)]
    pub struct ImageCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::ImageCreate, String>,
    }

    impl<'a> ImageCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ImageCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ImageCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/images`"]
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/images", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_view_v1`]\n\n[`ClientImagesExt::image_view_v1`]: super::ClientImagesExt::image_view_v1"]
    #[derive(Debug, Clone)]
    pub struct ImageViewV1<'a> {
        client: &'a super::Client,
        image: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ImageViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                image: Err("image was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn image<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.image = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for image failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/images/{image}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Image>, Error<types::Error>> {
            let Self {
                client,
                image,
                organization,
                project,
            } = self;
            let image = image.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/images/{}",
                client.baseurl,
                encode_path(&image.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientImagesExt::image_delete_v1`]\n\n[`ClientImagesExt::image_delete_v1`]: super::ClientImagesExt::image_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct ImageDeleteV1<'a> {
        client: &'a super::Client,
        image: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ImageDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                image: Err("image was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn image<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.image = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for image failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/images/{image}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                image,
                organization,
                project,
            } = self;
            let image = image.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/images/{}",
                client.baseurl,
                encode_path(&image.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_list_v1`]\n\n[`ClientInstancesExt::instance_list_v1`]: super::ClientInstancesExt::instance_list_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/instances`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/instances", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/instances`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Instance, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_create_v1`]\n\n[`ClientInstancesExt::instance_create_v1`]: super::ClientInstancesExt::instance_create_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::InstanceCreate, String>,
    }

    impl<'a> InstanceCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `InstanceCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/instances", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_view_v1`]\n\n[`ClientInstancesExt::instance_view_v1`]: super::ClientInstancesExt::instance_view_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceViewV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/instances/{instance}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_delete_v1`]\n\n[`ClientInstancesExt::instance_delete_v1`]: super::ClientInstancesExt::instance_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceDeleteV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/instances/{instance}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_disk_list_v1`]\n\n[`ClientInstancesExt::instance_disk_list_v1`]: super::ClientInstancesExt::instance_disk_list_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceDiskListV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceDiskListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/instances/{instance}/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/instances/{instance}/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Disk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_disk_attach_v1`]\n\n[`ClientInstancesExt::instance_disk_attach_v1`]: super::ClientInstancesExt::instance_disk_attach_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceDiskAttachV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::DiskPath, String>,
    }

    impl<'a> InstanceDiskAttachV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskPath>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DiskPath` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances/{instance}/disks/attach`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks/attach",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_disk_detach_v1`]\n\n[`ClientInstancesExt::instance_disk_detach_v1`]: super::ClientInstancesExt::instance_disk_detach_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceDiskDetachV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::DiskPath, String>,
    }

    impl<'a> InstanceDiskDetachV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::DiskPath>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `DiskPath` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances/{instance}/disks/detach`"]
        pub async fn send(self) -> Result<ResponseValue<types::Disk>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/disks/detach",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_external_ip_list_v1`]\n\n[`ClientInstancesExt::instance_external_ip_list_v1`]: super::ClientInstancesExt::instance_external_ip_list_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceExternalIpListV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceExternalIpListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/instances/{instance}/external-ips`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ExternalIpResultsPage>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/external-ips",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_migrate_v1`]\n\n[`ClientInstancesExt::instance_migrate_v1`]: super::ClientInstancesExt::instance_migrate_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceMigrateV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::InstanceMigrate, String>,
    }

    impl<'a> InstanceMigrateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::InstanceMigrate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `InstanceMigrate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances/{instance}/migrate`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/migrate",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_reboot_v1`]\n\n[`ClientInstancesExt::instance_reboot_v1`]: super::ClientInstancesExt::instance_reboot_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceRebootV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceRebootV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances/{instance}/reboot`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/reboot",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_serial_console_v1`]\n\n[`ClientInstancesExt::instance_serial_console_v1`]: super::ClientInstancesExt::instance_serial_console_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        from_start: Result<Option<u64>, String>,
        max_bytes: Result<Option<u64>, String>,
        most_recent: Result<Option<u64>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceSerialConsoleV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                from_start: Ok(None),
                max_bytes: Ok(None),
                most_recent: Ok(None),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn from_start<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.from_start = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for from_start failed".to_string());
            self
        }

        pub fn max_bytes<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.max_bytes = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for max_bytes failed".to_string());
            self
        }

        pub fn most_recent<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<u64>,
        {
            self.most_recent = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `u64` for most_recent failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/instances/{instance}/serial-console`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::InstanceSerialConsoleData>, Error<types::Error>> {
            let Self {
                client,
                instance,
                from_start,
                max_bytes,
                most_recent,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let from_start = from_start.map_err(Error::InvalidRequest)?;
            let max_bytes = max_bytes.map_err(Error::InvalidRequest)?;
            let most_recent = most_recent.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/serial-console",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &from_start {
                query.push(("from_start", v.to_string()));
            }
            if let Some(v) = &max_bytes {
                query.push(("max_bytes", v.to_string()));
            }
            if let Some(v) = &most_recent {
                query.push(("most_recent", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_serial_console_stream_v1`]\n\n[`ClientInstancesExt::instance_serial_console_stream_v1`]: super::ClientInstancesExt::instance_serial_console_stream_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceSerialConsoleStreamV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceSerialConsoleStreamV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/instances/{instance}/serial-console/stream`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<reqwest::Upgraded>, Error<reqwest::Upgraded>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/serial-console/stream",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client
                .client
                .get(url)
                .query(&query)
                .header(reqwest::header::CONNECTION, "Upgrade")
                .header(reqwest::header::UPGRADE, "websocket")
                .header(reqwest::header::SEC_WEBSOCKET_VERSION, "13")
                .header(
                    reqwest::header::SEC_WEBSOCKET_KEY,
                    base64::Engine::encode(
                        &base64::engine::general_purpose::STANDARD,
                        rand::random::<[u8; 16]>(),
                    ),
                )
                .build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                101u16 => ResponseValue::upgrade(response).await,
                200..=299 => ResponseValue::upgrade(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_start_v1`]\n\n[`ClientInstancesExt::instance_start_v1`]: super::ClientInstancesExt::instance_start_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceStartV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceStartV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances/{instance}/start`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/start",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_stop_v1`]\n\n[`ClientInstancesExt::instance_stop_v1`]: super::ClientInstancesExt::instance_stop_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceStopV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceStopV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/instances/{instance}/stop`"]
        pub async fn send(self) -> Result<ResponseValue<types::Instance>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/instances/{}/stop",
                client.baseurl,
                encode_path(&instance.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSessionExt::current_user_view_v1`]\n\n[`ClientSessionExt::current_user_view_v1`]: super::ClientSessionExt::current_user_view_v1"]
    #[derive(Debug, Clone)]
    pub struct CurrentUserViewV1<'a> {
        client: &'a super::Client,
    }

    impl<'a> CurrentUserViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/v1/me`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/me", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSessionExt::current_user_groups_v1`]\n\n[`ClientSessionExt::current_user_groups_v1`]: super::ClientSessionExt::current_user_groups_v1"]
    #[derive(Debug, Clone)]
    pub struct CurrentUserGroupsV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> CurrentUserGroupsV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/me/groups`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::GroupResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/me/groups", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/me/groups`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Group, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSessionExt::current_user_ssh_key_list_v1`]\n\n[`ClientSessionExt::current_user_ssh_key_list_v1`]: super::ClientSessionExt::current_user_ssh_key_list_v1"]
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> CurrentUserSshKeyListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/me/ssh-keys`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SshKeyResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/me/ssh-keys", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/me/ssh-keys`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SshKey, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSessionExt::current_user_ssh_key_create_v1`]\n\n[`ClientSessionExt::current_user_ssh_key_create_v1`]: super::ClientSessionExt::current_user_ssh_key_create_v1"]
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyCreateV1<'a> {
        client: &'a super::Client,
        body: Result<types::SshKeyCreate, String>,
    }

    impl<'a> CurrentUserSshKeyCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SshKeyCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SshKeyCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/me/ssh-keys`"]
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/me/ssh-keys", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSessionExt::current_user_ssh_key_view_v1`]\n\n[`ClientSessionExt::current_user_ssh_key_view_v1`]: super::ClientSessionExt::current_user_ssh_key_view_v1"]
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyViewV1<'a> {
        client: &'a super::Client,
        ssh_key: Result<types::NameOrId, String>,
    }

    impl<'a> CurrentUserSshKeyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ssh_key: Err("ssh_key was not initialized".to_string()),
            }
        }

        pub fn ssh_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.ssh_key = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for ssh_key failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/me/ssh-keys/{ssh_key}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SshKey>, Error<types::Error>> {
            let Self { client, ssh_key } = self;
            let ssh_key = ssh_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/me/ssh-keys/{}",
                client.baseurl,
                encode_path(&ssh_key.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSessionExt::current_user_ssh_key_delete_v1`]\n\n[`ClientSessionExt::current_user_ssh_key_delete_v1`]: super::ClientSessionExt::current_user_ssh_key_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct CurrentUserSshKeyDeleteV1<'a> {
        client: &'a super::Client,
        ssh_key: Result<types::NameOrId, String>,
    }

    impl<'a> CurrentUserSshKeyDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                ssh_key: Err("ssh_key was not initialized".to_string()),
            }
        }

        pub fn ssh_key<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.ssh_key = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for ssh_key failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/me/ssh-keys/{ssh_key}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, ssh_key } = self;
            let ssh_key = ssh_key.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/me/ssh-keys/{}",
                client.baseurl,
                encode_path(&ssh_key.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_list_v1`]\n\n[`ClientInstancesExt::instance_network_interface_list_v1`]: super::ClientInstancesExt::instance_network_interface_list_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceListV1<'a> {
        client: &'a super::Client,
        instance: Result<Option<types::NameOrId>, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> InstanceNetworkInterfaceListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Ok(None),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/network-interfaces`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                instance,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/network-interfaces", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &instance {
                query.push(("instance", v.to_string()));
            }
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/network-interfaces`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                instance: Ok(None),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_create_v1`]\n\n[`ClientInstancesExt::instance_network_interface_create_v1`]: super::ClientInstancesExt::instance_network_interface_create_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceCreateV1<'a> {
        client: &'a super::Client,
        instance: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::NetworkInterfaceCreate, String>,
    }

    impl<'a> InstanceNetworkInterfaceCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                instance: Err("instance was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkInterfaceCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `NetworkInterfaceCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/network-interfaces`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                instance,
                organization,
                project,
                body,
            } = self;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/network-interfaces", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            query.push(("instance", instance.to_string()));
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_view_v1`]\n\n[`ClientInstancesExt::instance_network_interface_view_v1`]: super::ClientInstancesExt::instance_network_interface_view_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceViewV1<'a> {
        client: &'a super::Client,
        interface: Result<types::NameOrId, String>,
        instance: Result<Option<types::NameOrId>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceNetworkInterfaceViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                interface: Err("interface was not initialized".to_string()),
                instance: Ok(None),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn interface<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.interface = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for interface failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/network-interfaces/{interface}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                interface,
                instance,
                organization,
                project,
            } = self;
            let interface = interface.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/network-interfaces/{}",
                client.baseurl,
                encode_path(&interface.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &instance {
                query.push(("instance", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_update_v1`]\n\n[`ClientInstancesExt::instance_network_interface_update_v1`]: super::ClientInstancesExt::instance_network_interface_update_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceUpdateV1<'a> {
        client: &'a super::Client,
        interface: Result<types::NameOrId, String>,
        instance: Result<Option<types::NameOrId>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::NetworkInterfaceUpdate, String>,
    }

    impl<'a> InstanceNetworkInterfaceUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                interface: Err("interface was not initialized".to_string()),
                instance: Ok(None),
                organization: Ok(None),
                project: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn interface<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.interface = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for interface failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NetworkInterfaceUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `NetworkInterfaceUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/network-interfaces/{interface}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterface>, Error<types::Error>> {
            let Self {
                client,
                interface,
                instance,
                organization,
                project,
                body,
            } = self;
            let interface = interface.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/network-interfaces/{}",
                client.baseurl,
                encode_path(&interface.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &instance {
                query.push(("instance", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientInstancesExt::instance_network_interface_delete_v1`]\n\n[`ClientInstancesExt::instance_network_interface_delete_v1`]: super::ClientInstancesExt::instance_network_interface_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct InstanceNetworkInterfaceDeleteV1<'a> {
        client: &'a super::Client,
        interface: Result<types::NameOrId, String>,
        instance: Result<Option<types::NameOrId>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> InstanceNetworkInterfaceDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                interface: Err("interface was not initialized".to_string()),
                instance: Ok(None),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn interface<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.interface = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for interface failed".to_string());
            self
        }

        pub fn instance<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.instance = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for instance failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/network-interfaces/{interface}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                interface,
                instance,
                organization,
                project,
            } = self;
            let interface = interface.map_err(Error::InvalidRequest)?;
            let instance = instance.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/network-interfaces/{}",
                client.baseurl,
                encode_path(&interface.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &instance {
                query.push(("instance", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_list_v1`]\n\n[`ClientOrganizationsExt::organization_list_v1`]: super::ClientOrganizationsExt::organization_list_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> OrganizationListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/organizations`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/organizations", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/organizations`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Organization, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_create_v1`]\n\n[`ClientOrganizationsExt::organization_create_v1`]: super::ClientOrganizationsExt::organization_create_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationCreateV1<'a> {
        client: &'a super::Client,
        body: Result<types::OrganizationCreate, String>,
    }

    impl<'a> OrganizationCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `OrganizationCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/organizations`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/organizations", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_view_v1`]\n\n[`ClientOrganizationsExt::organization_view_v1`]: super::ClientOrganizationsExt::organization_view_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationViewV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
    }

    impl<'a> OrganizationViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Err("organization was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/organizations/{organization}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_update_v1`]\n\n[`ClientOrganizationsExt::organization_update_v1`]: super::ClientOrganizationsExt::organization_update_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationUpdateV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
        body: Result<types::OrganizationUpdate, String>,
    }

    impl<'a> OrganizationUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Err("organization was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `OrganizationUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/organizations/{organization}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Organization>, Error<types::Error>> {
            let Self {
                client,
                organization,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_delete_v1`]\n\n[`ClientOrganizationsExt::organization_delete_v1`]: super::ClientOrganizationsExt::organization_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationDeleteV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
    }

    impl<'a> OrganizationDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Err("organization was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/organizations/{organization}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                organization,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_policy_view_v1`]\n\n[`ClientOrganizationsExt::organization_policy_view_v1`]: super::ClientOrganizationsExt::organization_policy_view_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyViewV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
    }

    impl<'a> OrganizationPolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Err("organization was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/organizations/{organization}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientOrganizationsExt::organization_policy_update_v1`]\n\n[`ClientOrganizationsExt::organization_policy_update_v1`]: super::ClientOrganizationsExt::organization_policy_update_v1"]
    #[derive(Debug, Clone)]
    pub struct OrganizationPolicyUpdateV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
        body: Result<types::OrganizationRolePolicy, String>,
    }

    impl<'a> OrganizationPolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Err("organization was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::OrganizationRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `OrganizationRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/organizations/{organization}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::OrganizationRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                organization,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/organizations/{}/policy",
                client.baseurl,
                encode_path(&organization.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSilosExt::policy_view_v1`]\n\n[`ClientSilosExt::policy_view_v1`]: super::ClientSilosExt::policy_view_v1"]
    #[derive(Debug, Clone)]
    pub struct PolicyViewV1<'a> {
        client: &'a super::Client,
    }

    impl<'a> PolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/v1/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/policy", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSilosExt::policy_update_v1`]\n\n[`ClientSilosExt::policy_update_v1`]: super::ClientSilosExt::policy_update_v1"]
    #[derive(Debug, Clone)]
    pub struct PolicyUpdateV1<'a> {
        client: &'a super::Client,
        body: Result<types::SiloRolePolicy, String>,
    }

    impl<'a> PolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SiloRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/policy", client.baseurl,);
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_list_v1`]\n\n[`ClientProjectsExt::project_list_v1`]: super::ClientProjectsExt::project_list_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> ProjectListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/projects`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/projects", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/projects`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Project, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_create_v1`]\n\n[`ClientProjectsExt::project_create_v1`]: super::ClientProjectsExt::project_create_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<types::NameOrId, String>,
        body: Result<types::ProjectCreate, String>,
    }

    impl<'a> ProjectCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Err("organization was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ProjectCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/projects`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                organization,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/projects", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            query.push(("organization", organization.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_view_v1`]\n\n[`ClientProjectsExt::project_view_v1`]: super::ClientProjectsExt::project_view_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectViewV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ProjectViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/projects/{project}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_update_v1`]\n\n[`ClientProjectsExt::project_update_v1`]: super::ClientProjectsExt::project_update_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectUpdateV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        body: Result<types::ProjectUpdate, String>,
    }

    impl<'a> ProjectUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ProjectUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/projects/{project}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Project>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_delete_v1`]\n\n[`ClientProjectsExt::project_delete_v1`]: super::ClientProjectsExt::project_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectDeleteV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ProjectDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/projects/{project}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_policy_view_v1`]\n\n[`ClientProjectsExt::project_policy_view_v1`]: super::ClientProjectsExt::project_policy_view_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyViewV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> ProjectPolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/projects/{project}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}/policy",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientProjectsExt::project_policy_update_v1`]\n\n[`ClientProjectsExt::project_policy_update_v1`]: super::ClientProjectsExt::project_policy_update_v1"]
    #[derive(Debug, Clone)]
    pub struct ProjectPolicyUpdateV1<'a> {
        client: &'a super::Client,
        project: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        body: Result<types::ProjectRolePolicy, String>,
    }

    impl<'a> ProjectPolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                project: Err("project was not initialized".to_string()),
                organization: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::ProjectRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `ProjectRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/projects/{project}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ProjectRolePolicy>, Error<types::Error>> {
            let Self {
                client,
                project,
                organization,
                body,
            } = self;
            let project = project.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/projects/{}/policy",
                client.baseurl,
                encode_path(&project.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_list_v1`]\n\n[`ClientSnapshotsExt::snapshot_list_v1`]: super::ClientSnapshotsExt::snapshot_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SnapshotListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SnapshotListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/snapshots`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SnapshotResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/snapshots", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/snapshots`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Snapshot, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_create_v1`]\n\n[`ClientSnapshotsExt::snapshot_create_v1`]: super::ClientSnapshotsExt::snapshot_create_v1"]
    #[derive(Debug, Clone)]
    pub struct SnapshotCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::SnapshotCreate, String>,
    }

    impl<'a> SnapshotCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SnapshotCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SnapshotCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/snapshots`"]
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/snapshots", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_view_v1`]\n\n[`ClientSnapshotsExt::snapshot_view_v1`]: super::ClientSnapshotsExt::snapshot_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SnapshotViewV1<'a> {
        client: &'a super::Client,
        snapshot: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> SnapshotViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                snapshot: Err("snapshot was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.snapshot = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for snapshot failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/snapshots/{snapshot}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Snapshot>, Error<types::Error>> {
            let Self {
                client,
                snapshot,
                organization,
                project,
            } = self;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/snapshots/{}",
                client.baseurl,
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSnapshotsExt::snapshot_delete_v1`]\n\n[`ClientSnapshotsExt::snapshot_delete_v1`]: super::ClientSnapshotsExt::snapshot_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct SnapshotDeleteV1<'a> {
        client: &'a super::Client,
        snapshot: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> SnapshotDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                snapshot: Err("snapshot was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn snapshot<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.snapshot = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for snapshot failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/snapshots/{snapshot}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                snapshot,
                organization,
                project,
            } = self;
            let snapshot = snapshot.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/snapshots/{}",
                client.baseurl,
                encode_path(&snapshot.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_list_v1`]\n\n[`ClientSystemExt::certificate_list_v1`]: super::ClientSystemExt::certificate_list_v1"]
    #[derive(Debug, Clone)]
    pub struct CertificateListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> CertificateListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/certificates`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CertificateResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/certificates", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/certificates`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Certificate, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_create_v1`]\n\n[`ClientSystemExt::certificate_create_v1`]: super::ClientSystemExt::certificate_create_v1"]
    #[derive(Debug, Clone)]
    pub struct CertificateCreateV1<'a> {
        client: &'a super::Client,
        body: Result<types::CertificateCreate, String>,
    }

    impl<'a> CertificateCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CertificateCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `CertificateCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/certificates`"]
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/certificates", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_view_v1`]\n\n[`ClientSystemExt::certificate_view_v1`]: super::ClientSystemExt::certificate_view_v1"]
    #[derive(Debug, Clone)]
    pub struct CertificateViewV1<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/certificates/{certificate}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Certificate>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::certificate_delete_v1`]\n\n[`ClientSystemExt::certificate_delete_v1`]: super::ClientSystemExt::certificate_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct CertificateDeleteV1<'a> {
        client: &'a super::Client,
        certificate: Result<types::NameOrId, String>,
    }

    impl<'a> CertificateDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                certificate: Err("certificate was not initialized".to_string()),
            }
        }

        pub fn certificate<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.certificate = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for certificate failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/system/certificates/{certificate}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                certificate,
            } = self;
            let certificate = certificate.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/certificates/{}",
                client.baseurl,
                encode_path(&certificate.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::physical_disk_list_v1`]\n\n[`ClientSystemExt::physical_disk_list_v1`]: super::ClientSystemExt::physical_disk_list_v1"]
    #[derive(Debug, Clone)]
    pub struct PhysicalDiskListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> PhysicalDiskListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/hardware/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/disks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/hardware/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::rack_list_v1`]\n\n[`ClientSystemExt::rack_list_v1`]: super::ClientSystemExt::rack_list_v1"]
    #[derive(Debug, Clone)]
    pub struct RackListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> RackListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/hardware/racks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RackResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/racks", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/hardware/racks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Rack, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::rack_view_v1`]\n\n[`ClientSystemExt::rack_view_v1`]: super::ClientSystemExt::rack_view_v1"]
    #[derive(Debug, Clone)]
    pub struct RackViewV1<'a> {
        client: &'a super::Client,
        rack_id: Result<uuid::Uuid, String>,
    }

    impl<'a> RackViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                rack_id: Err("rack_id was not initialized".to_string()),
            }
        }

        pub fn rack_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.rack_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for rack_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/hardware/racks/{rack_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Rack>, Error<types::Error>> {
            let Self { client, rack_id } = self;
            let rack_id = rack_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/racks/{}",
                client.baseurl,
                encode_path(&rack_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::sled_list_v1`]\n\n[`ClientSystemExt::sled_list_v1`]: super::ClientSystemExt::sled_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SledListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/hardware/sleds`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SledResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/hardware/sleds", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/hardware/sleds`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Sled, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::sled_view_v1`]\n\n[`ClientSystemExt::sled_view_v1`]: super::ClientSystemExt::sled_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SledViewV1<'a> {
        client: &'a super::Client,
        sled_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SledViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                sled_id: Err("sled_id was not initialized".to_string()),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Sled>, Error<types::Error>> {
            let Self { client, sled_id } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/sleds/{}",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::sled_physical_disk_list_v1`]\n\n[`ClientSystemExt::sled_physical_disk_list_v1`]: super::ClientSystemExt::sled_physical_disk_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SledPhysicalDiskListV1<'a> {
        client: &'a super::Client,
        sled_id: Result<uuid::Uuid, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SledPhysicalDiskListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                sled_id: Err("sled_id was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn sled_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.sled_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for sled_id failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/hardware/sleds/{sled_id}/disks`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::PhysicalDiskResultsPage>, Error<types::Error>> {
            let Self {
                client,
                sled_id,
                limit,
                page_token,
                sort_by,
            } = self;
            let sled_id = sled_id.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/hardware/sleds/{}/disks",
                client.baseurl,
                encode_path(&sled_id.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/hardware/sleds/{sled_id}/disks`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::PhysicalDisk, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_identity_provider_list_v1`]\n\n[`ClientSystemExt::silo_identity_provider_list_v1`]: super::ClientSystemExt::silo_identity_provider_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloIdentityProviderListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        silo: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloIdentityProviderListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/identity-providers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IdentityProviderResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                silo,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/identity-providers", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &silo {
                query.push(("silo", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/identity-providers`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IdentityProvider, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::local_idp_user_create_v1`]\n\n[`ClientSystemExt::local_idp_user_create_v1`]: super::ClientSystemExt::local_idp_user_create_v1"]
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserCreateV1<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::UserCreate, String>,
    }

    impl<'a> LocalIdpUserCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo: Err("silo was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UserCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/identity-providers/local/users`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/local/users",
                client.baseurl,
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("silo", silo.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::local_idp_user_delete_v1`]\n\n[`ClientSystemExt::local_idp_user_delete_v1`]: super::ClientSystemExt::local_idp_user_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserDeleteV1<'a> {
        client: &'a super::Client,
        user_id: Result<uuid::Uuid, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> LocalIdpUserDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                user_id: Err("user_id was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/system/identity-providers/local/users/{user_id}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                user_id,
                silo,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/local/users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("silo", silo.to_string()));
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::local_idp_user_set_password_v1`]\n\n[`ClientSystemExt::local_idp_user_set_password_v1`]: super::ClientSystemExt::local_idp_user_set_password_v1"]
    #[derive(Debug, Clone)]
    pub struct LocalIdpUserSetPasswordV1<'a> {
        client: &'a super::Client,
        user_id: Result<uuid::Uuid, String>,
        silo: Result<types::NameOrId, String>,
        body: Result<types::UserPassword, String>,
    }

    impl<'a> LocalIdpUserSetPasswordV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                user_id: Err("user_id was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UserPassword>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `UserPassword` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/identity-providers/local/users/{user_id}/set-password`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                user_id,
                silo,
                body,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/local/users/{}/set-password",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("silo", silo.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saml_identity_provider_create_v1`]\n\n[`ClientSystemExt::saml_identity_provider_create_v1`]: super::ClientSystemExt::saml_identity_provider_create_v1"]
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderCreateV1<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::SamlIdentityProviderCreate, String>,
    }

    impl<'a> SamlIdentityProviderCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo: Err("silo was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SamlIdentityProviderCreate>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `SamlIdentityProviderCreate` for body failed".to_string()
            });
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/identity-providers/saml`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/identity-providers/saml", client.baseurl,);
            let mut query = Vec::with_capacity(1usize);
            query.push(("silo", silo.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saml_identity_provider_view_v1`]\n\n[`ClientSystemExt::saml_identity_provider_view_v1`]: super::ClientSystemExt::saml_identity_provider_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SamlIdentityProviderViewV1<'a> {
        client: &'a super::Client,
        provider: Result<types::NameOrId, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SamlIdentityProviderViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                provider: Err("provider was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn provider<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.provider = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for provider failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/identity-providers/saml/{provider}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SamlIdentityProvider>, Error<types::Error>> {
            let Self {
                client,
                provider,
                silo,
            } = self;
            let provider = provider.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/identity-providers/saml/{}",
                client.baseurl,
                encode_path(&provider.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("silo", silo.to_string()));
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_list_v1`]\n\n[`ClientSystemExt::ip_pool_list_v1`]: super::ClientSystemExt::ip_pool_list_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> IpPoolListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/ip-pools`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/ip-pools`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPool, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_create_v1`]\n\n[`ClientSystemExt::ip_pool_create_v1`]: super::ClientSystemExt::ip_pool_create_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolCreateV1<'a> {
        client: &'a super::Client,
        body: Result<types::IpPoolCreate, String>,
    }

    impl<'a> IpPoolCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpPoolCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/ip-pools`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_view_v1`]\n\n[`ClientSystemExt::ip_pool_view_v1`]: super::ClientSystemExt::ip_pool_view_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolViewV1<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
    }

    impl<'a> IpPoolViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool: Err("pool was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/ip-pools/{pool}`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, pool } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_update_v1`]\n\n[`ClientSystemExt::ip_pool_update_v1`]: super::ClientSystemExt::ip_pool_update_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolUpdateV1<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::IpPoolUpdate, String>,
    }

    impl<'a> IpPoolUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool: Err("pool was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpPoolUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpPoolUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/system/ip-pools/{pool}`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_delete_v1`]\n\n[`ClientSystemExt::ip_pool_delete_v1`]: super::ClientSystemExt::ip_pool_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolDeleteV1<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
    }

    impl<'a> IpPoolDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool: Err("pool was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/system/ip-pools/{pool}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_range_list_v1`]\n\n[`ClientSystemExt::ip_pool_range_list_v1`]: super::ClientSystemExt::ip_pool_range_list_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeListV1<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> IpPoolRangeListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool: Err("pool was not initialized".to_string()),
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/ip-pools/{pool}/ranges`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                pool,
                limit,
                page_token,
            } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/ranges",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/ip-pools/{pool}/ranges`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_range_add_v1`]\n\n[`ClientSystemExt::ip_pool_range_add_v1`]: super::ClientSystemExt::ip_pool_range_add_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeAddV1<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeAddV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool: Err("pool was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/add`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/ranges/add",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_range_remove_v1`]\n\n[`ClientSystemExt::ip_pool_range_remove_v1`]: super::ClientSystemExt::ip_pool_range_remove_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolRangeRemoveV1<'a> {
        client: &'a super::Client,
        pool: Result<types::NameOrId, String>,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolRangeRemoveV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                pool: Err("pool was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn pool<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.pool = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for pool failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/ip-pools/{pool}/ranges/remove`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, pool, body } = self;
            let pool = pool.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools/{}/ranges/remove",
                client.baseurl,
                encode_path(&pool.to_string()),
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_view_v1`]\n\n[`ClientSystemExt::ip_pool_service_view_v1`]: super::ClientSystemExt::ip_pool_service_view_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceViewV1<'a> {
        client: &'a super::Client,
    }

    impl<'a> IpPoolServiceViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/v1/system/ip-pools-service`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPool>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/ip-pools-service", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_range_list_v1`]\n\n[`ClientSystemExt::ip_pool_service_range_list_v1`]: super::ClientSystemExt::ip_pool_service_range_list_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
    }

    impl<'a> IpPoolServiceRangeListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/ip-pools-service/ranges`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::IpPoolRangeResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools-service/ranges", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/ip-pools-service/ranges`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::IpPoolRange, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_range_add_v1`]\n\n[`ClientSystemExt::ip_pool_service_range_add_v1`]: super::ClientSystemExt::ip_pool_service_range_add_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeAddV1<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeAddV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/ip-pools-service/ranges/add`"]
        pub async fn send(self) -> Result<ResponseValue<types::IpPoolRange>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/ip-pools-service/ranges/add", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::ip_pool_service_range_remove_v1`]\n\n[`ClientSystemExt::ip_pool_service_range_remove_v1`]: super::ClientSystemExt::ip_pool_service_range_remove_v1"]
    #[derive(Debug, Clone)]
    pub struct IpPoolServiceRangeRemoveV1<'a> {
        client: &'a super::Client,
        body: Result<types::IpRange, String>,
    }

    impl<'a> IpPoolServiceRangeRemoveV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IpRange>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `IpRange` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/ip-pools-service/ranges/remove`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/ip-pools-service/ranges/remove",
                client.baseurl,
            );
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientPolicyExt::system_policy_view_v1`]\n\n[`ClientPolicyExt::system_policy_view_v1`]: super::ClientPolicyExt::system_policy_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SystemPolicyViewV1<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemPolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/v1/system/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/policy", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientPolicyExt::system_policy_update_v1`]\n\n[`ClientPolicyExt::system_policy_update_v1`]: super::ClientPolicyExt::system_policy_update_v1"]
    #[derive(Debug, Clone)]
    pub struct SystemPolicyUpdateV1<'a> {
        client: &'a super::Client,
        body: Result<types::FleetRolePolicy, String>,
    }

    impl<'a> SystemPolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::FleetRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `FleetRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/system/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::FleetRolePolicy>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/policy", client.baseurl,);
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saga_list_v1`]\n\n[`ClientSystemExt::saga_list_v1`]: super::ClientSystemExt::saga_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SagaListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SagaListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/sagas`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SagaResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/sagas", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/sagas`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Saga, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::saga_view_v1`]\n\n[`ClientSystemExt::saga_view_v1`]: super::ClientSystemExt::saga_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SagaViewV1<'a> {
        client: &'a super::Client,
        saga_id: Result<uuid::Uuid, String>,
    }

    impl<'a> SagaViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                saga_id: Err("saga_id was not initialized".to_string()),
            }
        }

        pub fn saga_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.saga_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for saga_id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/sagas/{saga_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Saga>, Error<types::Error>> {
            let Self { client, saga_id } = self;
            let saga_id = saga_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/sagas/{}",
                client.baseurl,
                encode_path(&saga_id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_list_v1`]\n\n[`ClientSystemExt::silo_list_v1`]: super::ClientSystemExt::silo_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> SiloListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/silos`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/silos", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/silos`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Silo, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_create_v1`]\n\n[`ClientSystemExt::silo_create_v1`]: super::ClientSystemExt::silo_create_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloCreateV1<'a> {
        client: &'a super::Client,
        body: Result<types::SiloCreate, String>,
    }

    impl<'a> SiloCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SiloCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/silos`"]
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/silos", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_view_v1`]\n\n[`ClientSystemExt::silo_view_v1`]: super::ClientSystemExt::silo_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloViewV1<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/silos/{silo}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Silo>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_delete_v1`]\n\n[`ClientSystemExt::silo_delete_v1`]: super::ClientSystemExt::silo_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloDeleteV1<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/system/silos/{silo}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let request = client.client.delete(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_policy_view_v1`]\n\n[`ClientSystemExt::silo_policy_view_v1`]: super::ClientSystemExt::silo_policy_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloPolicyViewV1<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloPolicyViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/silos/{silo}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, silo } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_policy_update_v1`]\n\n[`ClientSystemExt::silo_policy_update_v1`]: super::ClientSystemExt::silo_policy_update_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloPolicyUpdateV1<'a> {
        client: &'a super::Client,
        silo: Result<types::NameOrId, String>,
        body: Result<types::SiloRolePolicy, String>,
    }

    impl<'a> SiloPolicyUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                silo: Err("silo was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SiloRolePolicy>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SiloRolePolicy` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/system/silos/{silo}/policy`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SiloRolePolicy>, Error<types::Error>> {
            let Self { client, silo, body } = self;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/silos/{}/policy",
                client.baseurl,
                encode_path(&silo.to_string()),
            );
            let request = client.client.put(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_component_version_list`]\n\n[`ClientSystemExt::system_component_version_list`]: super::ClientSystemExt::system_component_version_list"]
    #[derive(Debug, Clone)]
    pub struct SystemComponentVersionList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SystemComponentVersionList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/components`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateableComponentResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/components", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/update/components`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UpdateableComponent, Error<types::Error>>>
               + Unpin
               + 'a {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::update_deployments_list`]\n\n[`ClientSystemExt::update_deployments_list`]: super::ClientSystemExt::update_deployments_list"]
    #[derive(Debug, Clone)]
    pub struct UpdateDeploymentsList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> UpdateDeploymentsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/deployments`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDeploymentResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/deployments", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/update/deployments`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::UpdateDeployment, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::update_deployment_view`]\n\n[`ClientSystemExt::update_deployment_view`]: super::ClientSystemExt::update_deployment_view"]
    #[derive(Debug, Clone)]
    pub struct UpdateDeploymentView<'a> {
        client: &'a super::Client,
        id: Result<uuid::Uuid, String>,
    }

    impl<'a> UpdateDeploymentView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                id: Err("id was not initialized".to_string()),
            }
        }

        pub fn id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for id failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/deployments/{id}`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::Error>> {
            let Self { client, id } = self;
            let id = id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/update/deployments/{}",
                client.baseurl,
                encode_path(&id.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_update_refresh`]\n\n[`ClientSystemExt::system_update_refresh`]: super::ClientSystemExt::system_update_refresh"]
    #[derive(Debug, Clone)]
    pub struct SystemUpdateRefresh<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemUpdateRefresh<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `POST` request to `/v1/system/update/refresh`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/refresh", client.baseurl,);
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_update_start`]\n\n[`ClientSystemExt::system_update_start`]: super::ClientSystemExt::system_update_start"]
    #[derive(Debug, Clone)]
    pub struct SystemUpdateStart<'a> {
        client: &'a super::Client,
        body: Result<types::SystemUpdateStart, String>,
    }

    impl<'a> SystemUpdateStart<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SystemUpdateStart>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `SystemUpdateStart` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/system/update/start`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UpdateDeployment>, Error<types::Error>> {
            let Self { client, body } = self;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/start", client.baseurl,);
            let request = client.client.post(url).json(&body).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                202u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_update_stop`]\n\n[`ClientSystemExt::system_update_stop`]: super::ClientSystemExt::system_update_stop"]
    #[derive(Debug, Clone)]
    pub struct SystemUpdateStop<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemUpdateStop<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `POST` request to `/v1/system/update/stop`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/stop", client.baseurl,);
            let request = client.client.post(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_update_list`]\n\n[`ClientSystemExt::system_update_list`]: super::ClientSystemExt::system_update_list"]
    #[derive(Debug, Clone)]
    pub struct SystemUpdateList<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SystemUpdateList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/updates`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SystemUpdateResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/update/updates", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/update/updates`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::SystemUpdate, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_update_view`]\n\n[`ClientSystemExt::system_update_view`]: super::ClientSystemExt::system_update_view"]
    #[derive(Debug, Clone)]
    pub struct SystemUpdateView<'a> {
        client: &'a super::Client,
        version: Result<types::SemverVersion, String>,
    }

    impl<'a> SystemUpdateView<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                version: Err("version was not initialized".to_string()),
            }
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SemverVersion>,
        {
            self.version = value
                .try_into()
                .map_err(|_| "conversion to `SemverVersion` for version failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/updates/{version}`"]
        pub async fn send(self) -> Result<ResponseValue<types::SystemUpdate>, Error<types::Error>> {
            let Self { client, version } = self;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/update/updates/{}",
                client.baseurl,
                encode_path(&version.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_update_components_list`]\n\n[`ClientSystemExt::system_update_components_list`]: super::ClientSystemExt::system_update_components_list"]
    #[derive(Debug, Clone)]
    pub struct SystemUpdateComponentsList<'a> {
        client: &'a super::Client,
        version: Result<types::SemverVersion, String>,
    }

    impl<'a> SystemUpdateComponentsList<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                version: Err("version was not initialized".to_string()),
            }
        }

        pub fn version<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::SemverVersion>,
        {
            self.version = value
                .try_into()
                .map_err(|_| "conversion to `SemverVersion` for version failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/updates/{version}/components`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ComponentUpdateResultsPage>, Error<types::Error>> {
            let Self { client, version } = self;
            let version = version.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/update/updates/{}/components",
                client.baseurl,
                encode_path(&version.to_string()),
            );
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::system_version`]\n\n[`ClientSystemExt::system_version`]: super::ClientSystemExt::system_version"]
    #[derive(Debug, Clone)]
    pub struct SystemVersion<'a> {
        client: &'a super::Client,
    }

    impl<'a> SystemVersion<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client }
        }

        #[doc = "Sends a `GET` request to `/v1/system/update/version`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::SystemVersion>, Error<types::Error>> {
            let Self { client } = self;
            let url = format!("{}/v1/system/update/version", client.baseurl,);
            let request = client.client.get(url).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_user_list_v1`]\n\n[`ClientSystemExt::silo_user_list_v1`]: super::ClientSystemExt::silo_user_list_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloUserListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        silo: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> SiloUserListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/users`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                page_token,
                silo,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/system/users", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &silo {
                query.push(("silo", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/system/users`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                page_token: Ok(None),
                silo: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientSystemExt::silo_user_view_v1`]\n\n[`ClientSystemExt::silo_user_view_v1`]: super::ClientSystemExt::silo_user_view_v1"]
    #[derive(Debug, Clone)]
    pub struct SiloUserViewV1<'a> {
        client: &'a super::Client,
        user_id: Result<uuid::Uuid, String>,
        silo: Result<types::NameOrId, String>,
    }

    impl<'a> SiloUserViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                user_id: Err("user_id was not initialized".to_string()),
                silo: Err("silo was not initialized".to_string()),
            }
        }

        pub fn user_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.user_id = value
                .try_into()
                .map_err(|_| "conversion to `uuid :: Uuid` for user_id failed".to_string());
            self
        }

        pub fn silo<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.silo = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for silo failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/system/users/{user_id}`"]
        pub async fn send(self) -> Result<ResponseValue<types::User>, Error<types::Error>> {
            let Self {
                client,
                user_id,
                silo,
            } = self;
            let user_id = user_id.map_err(Error::InvalidRequest)?;
            let silo = silo.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/system/users/{}",
                client.baseurl,
                encode_path(&user_id.to_string()),
            );
            let mut query = Vec::with_capacity(1usize);
            query.push(("silo", silo.to_string()));
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientSilosExt::user_list_v1`]\n\n[`ClientSilosExt::user_list_v1`]: super::ClientSilosExt::user_list_v1"]
    #[derive(Debug, Clone)]
    pub struct UserListV1<'a> {
        client: &'a super::Client,
        group: Result<Option<uuid::Uuid>, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        page_token: Result<Option<String>, String>,
        sort_by: Result<Option<types::IdSortMode>, String>,
    }

    impl<'a> UserListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                group: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn group<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<uuid::Uuid>,
        {
            self.group = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `uuid :: Uuid` for group failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::IdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `IdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/users`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::UserResultsPage>, Error<types::Error>> {
            let Self {
                client,
                group,
                limit,
                page_token,
                sort_by,
            } = self;
            let group = group.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/users", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &group {
                query.push(("group", v.to_string()));
            }
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/users`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::User, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                group: Ok(None),
                limit: Ok(None),
                page_token: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_firewall_rules_view_v1`]\n\n[`ClientVpcsExt::vpc_firewall_rules_view_v1`]: super::ClientVpcsExt::vpc_firewall_rules_view_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesViewV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
    }

    impl<'a> VpcFirewallRulesViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-firewall-rules`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                vpc,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-firewall-rules", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("vpc", vpc.to_string()));
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_firewall_rules_update_v1`]\n\n[`ClientVpcsExt::vpc_firewall_rules_update_v1`]: super::ClientVpcsExt::vpc_firewall_rules_update_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcFirewallRulesUpdateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::VpcFirewallRuleUpdateParams, String>,
    }

    impl<'a> VpcFirewallRulesUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcFirewallRuleUpdateParams>,
        {
            self.body = value.try_into().map_err(|_| {
                "conversion to `VpcFirewallRuleUpdateParams` for body failed".to_string()
            });
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/vpc-firewall-rules`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcFirewallRules>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                vpc,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-firewall-rules", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("vpc", vpc.to_string()));
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_list_v1`]\n\n[`ClientVpcsExt::vpc_router_route_list_v1`]: super::ClientVpcsExt::vpc_router_route_list_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterRouteListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                router: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-router-routes`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::RouterRouteResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                router,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-router-routes", client.baseurl,);
            let mut query = Vec::with_capacity(7usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &router {
                query.push(("router", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/vpc-router-routes`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::RouterRoute, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                router: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_create_v1`]\n\n[`ClientVpcsExt::vpc_router_route_create_v1`]: super::ClientVpcsExt::vpc_router_route_create_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<types::NameOrId, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::RouterRouteCreate, String>,
    }

    impl<'a> VpcRouterRouteCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Ok(None),
                router: Err("router was not initialized".to_string()),
                vpc: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `RouterRouteCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/vpc-router-routes`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                router,
                vpc,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-router-routes", client.baseurl,);
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("router", router.to_string()));
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_view_v1`]\n\n[`ClientVpcsExt::vpc_router_route_view_v1`]: super::ClientVpcsExt::vpc_router_route_view_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteViewV1<'a> {
        client: &'a super::Client,
        route: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<types::NameOrId, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterRouteViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                route: Err("route was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                router: Err("router was not initialized".to_string()),
                vpc: Ok(None),
            }
        }

        pub fn route<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.route = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for route failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-router-routes/{route}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                route,
                organization,
                project,
                router,
                vpc,
            } = self;
            let route = route.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&route.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("router", router.to_string()));
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_update_v1`]\n\n[`ClientVpcsExt::vpc_router_route_update_v1`]: super::ClientVpcsExt::vpc_router_route_update_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteUpdateV1<'a> {
        client: &'a super::Client,
        route: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::RouterRouteUpdate, String>,
    }

    impl<'a> VpcRouterRouteUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                route: Err("route was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                router: Ok(None),
                vpc: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn route<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.route = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for route failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::RouterRouteUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `RouterRouteUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/vpc-router-routes/{route}`"]
        pub async fn send(self) -> Result<ResponseValue<types::RouterRoute>, Error<types::Error>> {
            let Self {
                client,
                route,
                organization,
                project,
                router,
                vpc,
                body,
            } = self;
            let route = route.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&route.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &router {
                query.push(("router", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_route_delete_v1`]\n\n[`ClientVpcsExt::vpc_router_route_delete_v1`]: super::ClientVpcsExt::vpc_router_route_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterRouteDeleteV1<'a> {
        client: &'a super::Client,
        route: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        router: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterRouteDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                route: Err("route was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                router: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn route<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.route = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for route failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/vpc-router-routes/{route}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                route,
                organization,
                project,
                router,
                vpc,
            } = self;
            let route = route.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let router = router.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-router-routes/{}",
                client.baseurl,
                encode_path(&route.to_string()),
            );
            let mut query = Vec::with_capacity(4usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &router {
                query.push(("router", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_list_v1`]\n\n[`ClientVpcsExt::vpc_router_list_v1`]: super::ClientVpcsExt::vpc_router_list_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-routers`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcRouterResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-routers", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/vpc-routers`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcRouter, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_create_v1`]\n\n[`ClientVpcsExt::vpc_router_create_v1`]: super::ClientVpcsExt::vpc_router_create_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::VpcRouterCreate, String>,
    }

    impl<'a> VpcRouterCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcRouterCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/vpc-routers`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                vpc,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-routers", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("vpc", vpc.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_view_v1`]\n\n[`ClientVpcsExt::vpc_router_view_v1`]: super::ClientVpcsExt::vpc_router_view_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterViewV1<'a> {
        client: &'a super::Client,
        router: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
    }

    impl<'a> VpcRouterViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                router: Err("router was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
            }
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-routers/{router}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                router,
                organization,
                project,
                vpc,
            } = self;
            let router = router.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-routers/{}",
                client.baseurl,
                encode_path(&router.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("vpc", vpc.to_string()));
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_update_v1`]\n\n[`ClientVpcsExt::vpc_router_update_v1`]: super::ClientVpcsExt::vpc_router_update_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterUpdateV1<'a> {
        client: &'a super::Client,
        router: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::VpcRouterUpdate, String>,
    }

    impl<'a> VpcRouterUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                router: Err("router was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcRouterUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcRouterUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/vpc-routers/{router}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcRouter>, Error<types::Error>> {
            let Self {
                client,
                router,
                organization,
                project,
                vpc,
                body,
            } = self;
            let router = router.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-routers/{}",
                client.baseurl,
                encode_path(&router.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_router_delete_v1`]\n\n[`ClientVpcsExt::vpc_router_delete_v1`]: super::ClientVpcsExt::vpc_router_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcRouterDeleteV1<'a> {
        client: &'a super::Client,
        router: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcRouterDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                router: Err("router was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn router<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.router = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for router failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/vpc-routers/{router}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                router,
                organization,
                project,
                vpc,
            } = self;
            let router = router.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-routers/{}",
                client.baseurl,
                encode_path(&router.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_list_v1`]\n\n[`ClientVpcsExt::vpc_subnet_list_v1`]: super::ClientVpcsExt::vpc_subnet_list_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-subnets`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcSubnetResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-subnets", client.baseurl,);
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/vpc-subnets`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::VpcSubnet, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_create_v1`]\n\n[`ClientVpcsExt::vpc_subnet_create_v1`]: super::ClientVpcsExt::vpc_subnet_create_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<types::NameOrId, String>,
        body: Result<types::VpcSubnetCreate, String>,
    }

    impl<'a> VpcSubnetCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Ok(None),
                vpc: Err("vpc was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcSubnetCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/vpc-subnets`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                vpc,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpc-subnets", client.baseurl,);
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            query.push(("vpc", vpc.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_view_v1`]\n\n[`ClientVpcsExt::vpc_subnet_view_v1`]: super::ClientVpcsExt::vpc_subnet_view_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetViewV1<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                subnet: Err("subnet was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-subnets/{subnet}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                subnet,
                organization,
                project,
                vpc,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_update_v1`]\n\n[`ClientVpcsExt::vpc_subnet_update_v1`]: super::ClientVpcsExt::vpc_subnet_update_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetUpdateV1<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
        body: Result<types::VpcSubnetUpdate, String>,
    }

    impl<'a> VpcSubnetUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                subnet: Err("subnet was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcSubnetUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcSubnetUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/vpc-subnets/{subnet}`"]
        pub async fn send(self) -> Result<ResponseValue<types::VpcSubnet>, Error<types::Error>> {
            let Self {
                client,
                subnet,
                organization,
                project,
                vpc,
                body,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_delete_v1`]\n\n[`ClientVpcsExt::vpc_subnet_delete_v1`]: super::ClientVpcsExt::vpc_subnet_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetDeleteV1<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                subnet: Err("subnet was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/vpc-subnets/{subnet}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                subnet,
                organization,
                project,
                vpc,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut query = Vec::with_capacity(3usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_subnet_list_network_interfaces_v1`]\n\n[`ClientVpcsExt::vpc_subnet_list_network_interfaces_v1`]: super::ClientVpcsExt::vpc_subnet_list_network_interfaces_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcSubnetListNetworkInterfacesV1<'a> {
        client: &'a super::Client,
        subnet: Result<types::NameOrId, String>,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
        vpc: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcSubnetListNetworkInterfacesV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                subnet: Err("subnet was not initialized".to_string()),
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
            }
        }

        pub fn subnet<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.subnet = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for subnet failed".to_string());
            self
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpc-subnets/{subnet}/network-interfaces`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::NetworkInterfaceResultsPage>, Error<types::Error>>
        {
            let Self {
                client,
                subnet,
                limit,
                organization,
                page_token,
                project,
                sort_by,
                vpc,
            } = self;
            let subnet = subnet.map_err(Error::InvalidRequest)?;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpc-subnets/{}/network-interfaces",
                client.baseurl,
                encode_path(&subnet.to_string()),
            );
            let mut query = Vec::with_capacity(6usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            if let Some(v) = &vpc {
                query.push(("vpc", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/vpc-subnets/{subnet}/network-interfaces`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::NetworkInterface, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                vpc: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_list_v1`]\n\n[`ClientVpcsExt::vpc_list_v1`]: super::ClientVpcsExt::vpc_list_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcListV1<'a> {
        client: &'a super::Client,
        limit: Result<Option<std::num::NonZeroU32>, String>,
        organization: Result<Option<types::NameOrId>, String>,
        page_token: Result<Option<String>, String>,
        project: Result<Option<types::NameOrId>, String>,
        sort_by: Result<Option<types::NameOrIdSortMode>, String>,
    }

    impl<'a> VpcListV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
            }
        }

        pub fn limit<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<std::num::NonZeroU32>,
        {
            self.limit = value.try_into().map(Some).map_err(|_| {
                "conversion to `std :: num :: NonZeroU32` for limit failed".to_string()
            });
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn page_token<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<String>,
        {
            self.page_token = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `String` for page_token failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn sort_by<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrIdSortMode>,
        {
            self.sort_by = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrIdSortMode` for sort_by failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpcs`"]
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::VpcResultsPage>, Error<types::Error>> {
            let Self {
                client,
                limit,
                organization,
                page_token,
                project,
                sort_by,
            } = self;
            let limit = limit.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let page_token = page_token.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let sort_by = sort_by.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpcs", client.baseurl,);
            let mut query = Vec::with_capacity(5usize);
            if let Some(v) = &limit {
                query.push(("limit", v.to_string()));
            }
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &page_token {
                query.push(("page_token", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            if let Some(v) = &sort_by {
                query.push(("sort_by", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }

        #[doc = "Streams `GET` requests to `/v1/vpcs`"]
        pub fn stream(
            self,
        ) -> impl futures::Stream<Item = Result<types::Vpc, Error<types::Error>>> + Unpin + 'a
        {
            use futures::StreamExt;
            use futures::TryFutureExt;
            use futures::TryStreamExt;
            let next = Self {
                limit: Ok(None),
                organization: Ok(None),
                page_token: Ok(None),
                project: Ok(None),
                sort_by: Ok(None),
                ..self.clone()
            };
            self.send()
                .map_ok(move |page| {
                    let page = page.into_inner();
                    let first = futures::stream::iter(page.items.into_iter().map(Ok));
                    let rest = futures::stream::try_unfold(
                        (page.next_page, next),
                        |(next_page, next)| async {
                            if next_page.is_none() {
                                Ok(None)
                            } else {
                                Self {
                                    page_token: Ok(next_page),
                                    ..next.clone()
                                }
                                .send()
                                .map_ok(|page| {
                                    let page = page.into_inner();
                                    Some((
                                        futures::stream::iter(page.items.into_iter().map(Ok)),
                                        (page.next_page, next),
                                    ))
                                })
                                .await
                            }
                        },
                    )
                    .try_flatten();
                    first.chain(rest)
                })
                .try_flatten_stream()
                .boxed()
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_create_v1`]\n\n[`ClientVpcsExt::vpc_create_v1`]: super::ClientVpcsExt::vpc_create_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcCreateV1<'a> {
        client: &'a super::Client,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<types::NameOrId, String>,
        body: Result<types::VpcCreate, String>,
    }

    impl<'a> VpcCreateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                organization: Ok(None),
                project: Err("project was not initialized".to_string()),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcCreate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcCreate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `POST` request to `/v1/vpcs`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                organization,
                project,
                body,
            } = self;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!("{}/v1/vpcs", client.baseurl,);
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            query.push(("project", project.to_string()));
            let request = client.client.post(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_view_v1`]\n\n[`ClientVpcsExt::vpc_view_v1`]: super::ClientVpcsExt::vpc_view_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcViewV1<'a> {
        client: &'a super::Client,
        vpc: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcViewV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                vpc: Err("vpc was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `GET` request to `/v1/vpcs/{vpc}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                vpc,
                organization,
                project,
            } = self;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpcs/{}",
                client.baseurl,
                encode_path(&vpc.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.get(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_update_v1`]\n\n[`ClientVpcsExt::vpc_update_v1`]: super::ClientVpcsExt::vpc_update_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcUpdateV1<'a> {
        client: &'a super::Client,
        vpc: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
        body: Result<types::VpcUpdate, String>,
    }

    impl<'a> VpcUpdateV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                vpc: Err("vpc was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
                body: Err("body was not initialized".to_string()),
            }
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::VpcUpdate>,
        {
            self.body = value
                .try_into()
                .map_err(|_| "conversion to `VpcUpdate` for body failed".to_string());
            self
        }

        #[doc = "Sends a `PUT` request to `/v1/vpcs/{vpc}`"]
        pub async fn send(self) -> Result<ResponseValue<types::Vpc>, Error<types::Error>> {
            let Self {
                client,
                vpc,
                organization,
                project,
                body,
            } = self;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let body = body.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpcs/{}",
                client.baseurl,
                encode_path(&vpc.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.put(url).json(&body).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }

    #[doc = "Builder for [`ClientVpcsExt::vpc_delete_v1`]\n\n[`ClientVpcsExt::vpc_delete_v1`]: super::ClientVpcsExt::vpc_delete_v1"]
    #[derive(Debug, Clone)]
    pub struct VpcDeleteV1<'a> {
        client: &'a super::Client,
        vpc: Result<types::NameOrId, String>,
        organization: Result<Option<types::NameOrId>, String>,
        project: Result<Option<types::NameOrId>, String>,
    }

    impl<'a> VpcDeleteV1<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client,
                vpc: Err("vpc was not initialized".to_string()),
                organization: Ok(None),
                project: Ok(None),
            }
        }

        pub fn vpc<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.vpc = value
                .try_into()
                .map_err(|_| "conversion to `NameOrId` for vpc failed".to_string());
            self
        }

        pub fn organization<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.organization = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for organization failed".to_string());
            self
        }

        pub fn project<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::NameOrId>,
        {
            self.project = value
                .try_into()
                .map(Some)
                .map_err(|_| "conversion to `NameOrId` for project failed".to_string());
            self
        }

        #[doc = "Sends a `DELETE` request to `/v1/vpcs/{vpc}`"]
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::Error>> {
            let Self {
                client,
                vpc,
                organization,
                project,
            } = self;
            let vpc = vpc.map_err(Error::InvalidRequest)?;
            let organization = organization.map_err(Error::InvalidRequest)?;
            let project = project.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/v1/vpcs/{}",
                client.baseurl,
                encode_path(&vpc.to_string()),
            );
            let mut query = Vec::with_capacity(2usize);
            if let Some(v) = &organization {
                query.push(("organization", v.to_string()));
            }
            if let Some(v) = &project {
                query.push(("project", v.to_string()));
            }
            let request = client.client.delete(url).query(&query).build()?;
            let result = client.client.execute(request).await;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                400u16..=499u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                500u16..=599u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}

pub mod prelude {
    pub use super::Client;
    pub use super::ClientDisksExt;
    pub use super::ClientHiddenExt;
    pub use super::ClientImagesExt;
    pub use super::ClientInstancesExt;
    pub use super::ClientLoginExt;
    pub use super::ClientMetricsExt;
    pub use super::ClientOrganizationsExt;
    pub use super::ClientPolicyExt;
    pub use super::ClientProjectsExt;
    pub use super::ClientRolesExt;
    pub use super::ClientSessionExt;
    pub use super::ClientSilosExt;
    pub use super::ClientSnapshotsExt;
    pub use super::ClientSystemExt;
    pub use super::ClientVpcsExt;
}
